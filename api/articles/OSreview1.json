{"title":"计算机操作系统复习笔记（一）","uid":"36aa3041fb4e01bf3bb1e7de215967c2","slug":"OSreview1","date":"2023-03-16T14:27:01.000Z","updated":"2023-03-16T14:31:14.945Z","comments":true,"path":"api/articles/OSreview1.json","keywords":null,"cover":"https://picx.zhimg.com/v2-ab4d2e1f84d9a3d9cd65d7894164bcea_1440w.jpg?source=172ae18b","content":"<h1 id=\"第一部分-操作系统概述\"><a href=\"#第一部分-操作系统概述\" class=\"headerlink\" title=\"第一部分   操作系统概述\"></a>第一部分   操作系统概述</h1><p><strong>目录</strong></p>\n<p><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p><a href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\">操作系统概述</a></p>\n<p>​\t\t<a href=\"#1.1%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD\">操作系统的目标与功能</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89\">操作系统的定义</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E7%9B%AE%E6%A0%87\">目标</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E5%8A%9F%E8%83%BD\">功能</a></p>\n<p>​\t\t<a href=\"#1.2%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2\">操作系统的历史</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%C2%A0%E4%B8%B2%E8%A1%8C%E5%A4%84%E7%90%86\">单用户系统</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%C2%A0%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F\">简单批处理系统</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F\">多道批处理系统</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F\">分时系统</a></p>\n<p>​\t\t\t<a href=\"#%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%20%E2%86%92%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%20%E2%86%92%20%E4%BA%92%E8%81%94%E7%BD%91%E6%97%B6%E4%BB%A3%20%E2%86%92%20%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%97%B6%E4%BB%A3%20%E2%86%92%20......\">个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……</a></p>\n<p>​\t\t\t<a href=\"#%C2%A0%E2%9C%A6%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F\">实时系统</a></p>\n<p>​\t\t<a href=\"#1.3%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%88%90%E5%B0%B1\">操作系统的基本特征</a></p>\n<p>​\t\t\t<a href=\"#%E5%B9%B6%E5%8F%91\">并发</a></p>\n<p>​\t\t\t<a href=\"#%E5%85%B1%E4%BA%AB\">共享</a></p>\n<p>​\t\t\t<a href=\"#%E8%99%9A%E6%8B%9F\">虚拟</a></p>\n<p>​\t\t\t<a href=\"#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7\">不确定性</a></p>\n<p>​\t\t<a href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">操作系统的体系结构</a></p>\n<p>​\t\t\t<a href=\"#%E6%97%A0%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">无结构操作系统</a></p>\n<p>​\t\t\t<a href=\"#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\">模块化系统结构</a></p>\n<p>​\t\t\t<a href=\"#%E5%88%86%E5%B1%82%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\">分层式系统结构</a></p>\n<p>​\t\t<a href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8\">操作系统安全</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E5%86%85%E5%AD%98\">内存</a></p>\n<p>​\t\t\t<a href=\"#%E2%9C%A6%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8\">信息保护和安全</a></p>\n<hr>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>\n<ul>\n<li><strong>CM1</strong>：**操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>\n<li><strong>CM2</strong>：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>\n<li><strong>CM3</strong>：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>\n<li><strong>CM4</strong>：设备管理。I&#x2F;O系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>\n<li><strong>CM5</strong>：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>\n</ul>\n<p>本节要点在CM1，大致内容如下：</p>\n<p>第一章 计算机操作系统概论（6 学时，多媒体课件结合板书面授） CM1</p>\n<p>1、主要内容<br>批处理技术、多道程序设计技术、操作系统的概念、操作系统的发展、操作系统的基本类型、 操作系统相关的基本概念和特点、操作系统的特征、理解操作系统的服务、操作系统的功能模块、 操作系统的体系结构、系统调用、命令接口、程序接口、虚拟机、客户机&#x2F;服务器等。</p>\n<p>2、应达到的要求<br>记忆：操作系统的体系结构、操作系统的发展及主要类型。</p>\n<p>理解: 操作系统中的基本概念、操作系统的目标和作用、理解用户接口与系统调用的意义和类型。</p>\n<p>应用：批处理技术、多道程序设计技术。<br>分析：操作系统的基本类型、特征、操作系统的功能模块。</p>\n<p>第六章 操作系统安全（2 学时，多媒体课件结合板书面授） CM1</p>\n<p>1、主要内容<br>操作系统安全的概念、安全机制的实施：文件保护机制、身份认证、访问矩阵、访问矩阵的实现。<br>2、应达到的要求</p>\n<p>记忆：安全系统的模型、设计、可信度验证。<br>理解：操作系统安全的概念、安全机制的实施</p>\n<p>应用：文件保护、身份认证、访问矩阵、访问矩阵的实现。</p>\n<p> </p>\n<hr>\n<h1 id=\"操作系统概述\"><a href=\"#操作系统概述\" class=\"headerlink\" title=\"操作系统概述\"></a>操作系统概述</h1><hr>\n<h2 id=\"操作系统的目标与功能\"><a href=\"#操作系统的目标与功能\" class=\"headerlink\" title=\"操作系统的目标与功能\"></a>操作系统的目标与功能</h2><h3 id=\"操作系统的定义\"><a href=\"#操作系统的定义\" class=\"headerlink\" title=\"操作系统的定义\"></a>操作系统的定义</h3><p>操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/00f2d5bf5e494a4e868545c7ab9a20cc.png\"></p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a><strong>目标</strong></h3><ul>\n<li>方便性：使计算机更易于使用</li>\n<li>有效性：使用计算机资源更加有效</li>\n<li>扩展性：可开发、测试引入新功能</li>\n<li>开放性：应用程序的可移植和互操作</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a><strong>功能</strong></h3><ul>\n<li><strong>处理机管理：</strong>按照一定的算法把处理机分配给进程（线程），并对其进行有效的管理和控制。</li>\n<li><strong>存储器管理：</strong>为多道程序提供运行环境，方便使用，提高存储器利用率以及能从逻辑上扩充内存。</li>\n<li><strong>设备管理：</strong>完成用户提出的I&#x2F;O请求；为用户分配其所需的I&#x2F;O设备；提高CPU和I&#x2F;O设备的利用率；提高I&#x2F;O速度；方便用户使用I&#x2F;O设备。</li>\n<li><strong>文件管理：</strong>对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。</li>\n<li><strong>用户接口：</strong>OS提供给用户交互的命令集合</li>\n</ul>\n<hr>\n<h2 id=\"操作系统的历史\"><a href=\"#操作系统的历史\" class=\"headerlink\" title=\"操作系统的历史\"></a>操作系统的历史</h2><h3 id=\"单用户系统\"><a href=\"#单用户系统\" class=\"headerlink\" title=\"单用户系统\"></a>单用户系统</h3><p><strong>处理机制：</strong></p>\n<ul>\n<li>人工操作方式，所有资源用户独占</li>\n<li>脱机输入输出（与外围计算机进行I&#x2F;O）(→优化为简单批处理系统)</li>\n</ul>\n<h3 id=\"简单批处理系统\"><a href=\"#简单批处理系统\" class=\"headerlink\" title=\"简单批处理系统\"></a>简单批处理系统</h3><p><strong>处理机制</strong>: 对一批作业进行自动处理，内存中只能存放一道作业，运行结束&#x2F;出错→自动调用另一道作业（自动续接）</p>\n<p> <strong>主要特征</strong>: 自动性, 顺序性, 单道性</p>\n<p> <strong>优点</strong>: 减少了人工操作, 解决了作业自动续接问题</p>\n<p> <strong>缺点</strong>: 平均周转时间太长(处理器一次只能运行一道程序，在进行I&#x2F;O操作时会让处理器陷入等待，利用率仍较低), 没有交互能力(→优化为多道批处理系统)</p>\n<h3 id=\"多道批处理系统\"><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3><p><strong>在单道批处理上加以改进：</strong></p>\n<ul>\n<li>内存中同时存放多个作业</li>\n<li>当一个作业需要等待I&#x2F;O或运行结束&#x2F;出错时，处理器可以切换到另一个作业(自动调度)</li>\n<li>多个程序可并发执行</li>\n<li><strong>作业调度程序</strong>负责作业的调度</li>\n</ul>\n<p><strong>主要特征</strong>: 多道性, 无序性, 调度性</p>\n<p> <strong>优点</strong>: 提高了资源利用率和吞吐能力</p>\n<p> <strong>缺点</strong>: 没有交互能力(→优化为分时系统)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5f2514cc08f649539bc5d72bfa0930f5.png\"></p>\n<h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><p><strong>处理机制</strong>: 时钟中断: 时间片</p>\n<p> <strong>产生原因</strong>:人机交互、共享主机、方便上机</p>\n<p> <strong>主要特征</strong>: 多路性, 独立性, 及时性, 交互性</p>\n<p><strong>[与多道批处理系统的比较]</strong></p>\n<p>主要表现在用户交互层面, 用户可以在终端输入指令控制计算机, 而侧重点也有所不同: 多道批处理系统侧重于充分利用处理器, 而分时系统更注重作业效率</p>\n<h3 id=\"个人电脑-→-分布式系统-→-互联网时代-→-移动计算时代-→-……\"><a href=\"#个人电脑-→-分布式系统-→-互联网时代-→-移动计算时代-→-……\" class=\"headerlink\" title=\"个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……\"></a><strong>个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……</strong></h3><p>​\t\t<strong>了解即可, 略</strong></p>\n<h3 id=\"实时系统\"><a href=\"#实时系统\" class=\"headerlink\" title=\"实时系统\"></a>实时系统</h3><p><strong>定义：</strong></p>\n<p>系统能实时（及时） 相应外部事件的请求，在规定的时间内开始或完成该事件的处理，并控制所有实时任务协调一致的运行</p>\n<p><strong>应用领域：</strong></p>\n<p>航空航天、军事、工业控制、实时控制系统、实时信息系统</p>\n<p><strong>特性:</strong></p>\n<p>多路性、独立性、交互性、可靠性、及时性</p>\n<hr>\n<h2 id=\"操作系统的基本特征\"><a href=\"#操作系统的基本特征\" class=\"headerlink\" title=\"操作系统的基本特征\"></a>操作系统的基本特征</h2><ul>\n<li>并发（最重要的特征）</li>\n<li>共享</li>\n<li>虚拟</li>\n<li>不确定性</li>\n</ul>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>并行性是指两个或多个事件在同一时刻发生。（单处理机系统）</p>\n<p>并发性是指两个或多个事件在同一时间间隔内发生。（多处理机系统）</p>\n<h3 id=\"共享\"><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h3><p>系统中的资源可供内存中多个并发执行的进程共同使用。</p>\n<ul>\n<li><p>互斥共享方式：</p>\n</li>\n<li><p>临界资源是在一段时间内只允许一个进程访问的资源</p>\n</li>\n<li><p>系统中的临界资源可以提供给多个进程使用，但一次仅允许一个进程使用</p>\n</li>\n<li><p>同时访问方式：</p>\n</li>\n<li><p>宏观上，资源共享指多个任务可以同时使用系统的软硬件资源</p>\n</li>\n<li><p>微观上，资源共享指多个任务可以交替互斥的使用系统中的某个资源（例如磁盘）</p>\n</li>\n</ul>\n<h3 id=\"虚拟\"><a href=\"#虚拟\" class=\"headerlink\" title=\"虚拟\"></a>虚拟</h3><p>将物理实体抽象成逻辑产物。（时分[虚拟处理机&#x2F;虚拟设备]、空分[虚拟内存]…）</p>\n<h3 id=\"不确定性\"><a href=\"#不确定性\" class=\"headerlink\" title=\"不确定性\"></a>不确定性</h3><p>同样的程序，同样的输入，输出结果可能不同。</p>\n<ul>\n<li>异步：进程使用异步方式执行，运行速度与结果不可预知。</li>\n<li>随机函数：random(); gettimeofday()……</li>\n</ul>\n<p> </p>\n<hr>\n<h2 id=\"操作系统的体系结构\"><a href=\"#操作系统的体系结构\" class=\"headerlink\" title=\"操作系统的体系结构\"></a>操作系统的体系结构</h2><p>操作系统的四代变革：</p>\n<ul>\n<li>第一代：无结构操作系统</li>\n<li>第二代：模块式结构</li>\n<li>第三代：层次式结构</li>\n<li>第四代：工程学+软件开发→软件工程学</li>\n</ul>\n<p>常见OS整体结构：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/943eae6a438c4e078b00db58870c4a56.png\"></p>\n<h3 id=\"无结构操作系统\"><a href=\"#无结构操作系统\" class=\"headerlink\" title=\"无结构操作系统\"></a>无结构操作系统</h3><p>OS是众多过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构，既庞大又杂乱，因此也叫它整体系统结构。</p>\n<p>这样编织出的程序错误很多，调试与维护的成本很高，负担很大。</p>\n<h3 id=\"模块化系统结构\"><a href=\"#模块化系统结构\" class=\"headerlink\" title=\"模块化系统结构\"></a>模块化系统结构</h3><p>OS包含若干模块，每一模块实现一组基本概念及相关基本属性</p>\n<p>模块之间均可以引用任意其他各块的概念以及属性</p>\n<ul>\n<li><p>优点：</p>\n</li>\n<li><p>提高了OS设计的正确性、可理解性和可维护性。</p>\n</li>\n<li><p>增强了OS的可适应性。 加速了OS的开发过程。</p>\n</li>\n<li><p>缺点：</p>\n</li>\n<li><p>对模块的划分及对接口的规定要精确描述很困难。</p>\n</li>\n<li><p>从功能观点来划分模块时，未能将共享资源和独占资源加以区别；</p>\n</li>\n</ul>\n<h3 id=\"分层式系统结构\"><a href=\"#分层式系统结构\" class=\"headerlink\" title=\"分层式系统结构\"></a>分层式系统结构</h3><p>OS包含若干层，每一层实现一组基本概念及相关基本属性</p>\n<p>各层的实现只依赖其直接下层所提供的概念以及属性，并对其上各层隐藏其下各层的存在</p>\n<hr>\n<h2 id=\"操作系统安全\"><a href=\"#操作系统安全\" class=\"headerlink\" title=\"操作系统安全\"></a>操作系统安全</h2><h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p><strong>虚拟存储：</strong></p>\n<ul>\n<li>以逻辑方式访问储存器，不考虑物理内存可用的空间数量</li>\n<li>满足多个作业同时驻留内存的需求</li>\n<li>换入换出机制</li>\n<li>分页机制：每个进程的大小可能不同，整体换入换出时大小不匹配</li>\n<li>每个作业部分驻留：硬件检测到缺页时，安排载入</li>\n</ul>\n<p><strong>分页机制：</strong></p>\n<ul>\n<li>进程由若干个固定大小的块组成，每一块大小相同</li>\n<li>虚地址由页号和内页偏移量组成</li>\n<li>进程中每一页均可置于内存中任何位置</li>\n<li>提供了虚地址和内存中实地址（物理地址）之间的动态映射机制</li>\n</ul>\n<h3 id=\"信息保护和安全\"><a href=\"#信息保护和安全\" class=\"headerlink\" title=\"信息保护和安全\"></a>信息保护和安全</h3><ul>\n<li>可用性：保护系统不被中断</li>\n<li>保密性：保证用户不能读取未授权访问的数据</li>\n<li>数据完整性：保护数据不被未授权修改</li>\n<li>认证：涉及用户身份的正确认证和消息或数据的合法</li>\n</ul>\n<h1 id=\"第二部分进程与并发控制\"><a href=\"#第二部分进程与并发控制\" class=\"headerlink\" title=\"第二部分\t进程与并发控制\"></a>第二部分\t进程与并发控制</h1><p><strong>目录</strong></p>\n<p><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p><a href=\"#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\">进程管理</a></p>\n<p>​\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86\">进程基本知识</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C\">程序的顺序执行</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%89%8D%E8%B6%8B%E5%9B%BE\">前趋图</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C\">程序的并发执行</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F\">并发程序</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81%C2%A0\">进程的定义和特征 </a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E7%8A%B6%E6%80%81\">进程的特征和状态</a></p>\n<p>​\t\t<a href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8\">操作系统内核</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AE%9A%E4%B9%89\">定义</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8A%9F%E8%83%BD\">功能</a></p>\n<p>​\t\t<a href=\"#%E5%8E%9F%E8%AF%AD\">原语</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0\">原子操作的实现 </a></p>\n<p>​\t\t<a href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\">操作系统控制结构</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB\">进程控制块PCB</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%A0%91%EF%BC%89\">进程组织（进程树）</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA\">进程的创建</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%EF%BC%88fork%E4%B8%8Eexec%E4%B8%BA%E4%B8%BB%EF%BC%89\">进程控制函数（fork与exec为主）</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2\">进程的终止</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2\">进程切换</a></p>\n<p>​\t\t<a href=\"#%E7%BA%BF%E7%A8%8B\">线程</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB\">与进程的区别和联系</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF\">线程的优势</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9\">线程的特点</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81\">线程的状态</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB\">线程的分类</a></p>\n<p><a href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\">处理机调度</a></p>\n<p>​\t\t<a href=\"#%E2%AD%90%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐单处理机调度（重点）</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99\">调度原则</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98\">调度算法：资源分配问题</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%9AFCFS\">先来先服务：FCFS</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%9ASPF/SJF\">短作业优先：SPF&#x2F;SJF</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%9ATSRR\">时间片轮转调度：TSRR</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%EF%BC%9ASRT\">最短剩余时间调度：SRT</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E6%9D%83/%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\">基于优先权&#x2F;优先级的调度算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%9AHRRN\">高响应比优先算法：HRRN</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\">多级队列调度算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%EF%BC%9AMFQ\">多级反馈队列调度：MFQ</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<p>​\t\t<a href=\"#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%C2%A0\">实时调度 </a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6\">基本条件</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E4%B8%8B%E7%95%8C\">系统处理能力下界</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\">实时调度算法</a></p>\n<p>​\t\t<a href=\"#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\">多处理机调度</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%88%86%E7%B1%BB\">分类</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F\">进程分配方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8D%95%E9%98%9F%E5%88%97%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\">单队列多处理机调度</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%A4%9A%E9%98%9F%E5%88%97%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\">多队列多处理机调度</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%88%90%E7%BB%84%E8%B0%83%E5%BA%A6\">成组调度</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%93%E7%94%A8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%86%E9%85%8D%C2%A0\">专用处理机分配 </a></p>\n<p><a href=\"#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5\">进程并发控制：互斥与同步</a></p>\n<p>​\t\t<a href=\"#%E8%BF%9B%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\">进程&#x2F;线程的并发控制</a></p>\n<p>​\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t<a href=\"#%E5%90%8C%E6%AD%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5\">同步的解决策略</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95\">软件方法</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95\">硬件方法</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8F\">信号量</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%AE%A1%E7%A8%8B\">管程</a></p>\n<p><a href=\"#%E2%AD%90%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐进程并发控制：信号量的应用（重点）</a></p>\n<p>​\t\t<a href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E9%97%AE%E9%A2%98\">观察者问题</a></p>\n<p>​\t\t<a href=\"#%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%97%AE%E9%A2%98\">图书馆问题</a></p>\n<p>​\t\t<a href=\"#%E5%85%AC%E4%BA%A4%E8%BD%A6%E9%97%AE%E9%A2%98\">公交车问题</a></p>\n<p>​\t\t<a href=\"#%E2%AD%90%E7%94%9F%E4%BA%A7%E8%80%85/%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐生产者&#x2F;消费者问题（重点）</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BE%8B%E9%A2%98%EF%BC%9A\">例题：</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%90%AF%E7%A4%BA\">启示</a></p>\n<p>​\t\t<a href=\"#%E2%AD%90%E8%AF%BB/%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐读&#x2F;写者问题（重点）</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88\">读者优先</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88\">写者优先</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%AC%E5%B9%B3%E4%BC%98%E5%85%88\">公平优先</a></p>\n<p>​\t\t<a href=\"#%E2%AD%90%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐理发师问题（重点）</a></p>\n<p>​\t\t<a href=\"#%E2%AD%90%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\">⭐哲学家问题（重点）</a></p>\n<p>​\t\t<a href=\"#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE\">重点知识点回顾</a></p>\n<p>​\t<a href=\"#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E7%BB%83%E4%B9%A0%E9%A2%98\">进程并发控制：练习题</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%981\">问题1</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%982\">问题2</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%983\">问题3</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%984\">问题4</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%985\">问题5</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%986\">问题6</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%987\">问题7</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%988%C2%A0\">问题8 </a></p>\n<p>​\t\t\t\t<a href=\"#%E9%97%AE%E9%A2%989\">问题9</a></p>\n<p>​\t<a href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\">进程间通信</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92\">消息传递</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89%E9%80%9A%E4%BF%A1\">管道（Pipe）通信</a></p>\n<p>​\t<a href=\"#%E6%AD%BB%E9%94%81%C2%A0\">死锁 </a></p>\n<p>​\t\t<a href=\"#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0\">产生死锁的原因</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B\">系统模型</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B\">资源类型</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE\">资源分配图</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%E5%AE%9E%E4%BE%8B\">实例</a></p>\n<p>​\t\t<a href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6%C2%A0\">死锁的充要条件 </a></p>\n<p>​\t\t<a href=\"#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%C2%A0\">处理死锁的基本方法 </a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2\">死锁预防</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D\">死锁避免</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B\">死锁检测</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4\">死锁解除</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AD%BB%E9%94%81%E5%BF%BD%E7%95%A5\">死锁忽略</a></p>\n<hr>\n<h1 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>\n<ul>\n<li><strong>CM1</strong>：操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>\n<li><strong>CM2：</strong>进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>\n<li><strong>CM3</strong>：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>\n<li><strong>CM4</strong>：设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>\n<li><strong>CM5</strong>：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>\n</ul>\n<p>本节要点在CM2，大致内容如下：</p>\n<p><strong>第二章</strong> 进程与并发控制（20 学时，多媒体课件结合板书面授）CM2</p>\n<p>1、主要内容<br>程序顺序执行、程序并发执行、进程的定义与特征、进程的基本状态、进程的挂起状态、进程控制块、进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活。临界资源、临界区、利用软件和硬件解决进程互斥问题、整型信号量机制、记录型信号量机制、信号量集机制、生产者－消费者问题、读者和写者问题、哲学家进餐问题、管程机制、进程通信的类型、直接通信和间接通信方式、消息传递系统中的几个问题、消息缓冲队列通信机制。调度的类型、调度队列模型、调度方式和各种调度算法、产生死锁的原因和必要条件、处理死锁的基本方法、死锁的预防和避免、死锁的检测与解除。进程调度算法。满足实时系统要求时，应选择适合实时系统中的调度算法。线程的概念、线程间的同步和通信、用户线程和内核支持线程的概念。<br>2、应达到的要求</p>\n<p>记忆：进程的分配方式、管程机制。<br>理解：进程的并发执行与控制；实时系统的类型及实时调度算法。线程的概念、线程间的同步和通信、用户线程和内核支持线程的概念。<br>应用：程序的执行、进程的定义与特征、进程的基本状态、进程控制块、操作系统内核、进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活、线程与进程、进程调度算法。 临界资源、临界区、进程互斥问题、信号量的应用。<br>分析：进程调度和死锁、处理死锁的基本方法。进程（线程）的调度算法、生产者&#x2F;消费者</p>\n<p>问题、读者和写者问题、哲学家进餐问题。</p>\n<hr>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><hr>\n<h2 id=\"进程基本知识\"><a href=\"#进程基本知识\" class=\"headerlink\" title=\"进程基本知识\"></a>进程基本知识</h2><h3 id=\"程序的顺序执行\"><a href=\"#程序的顺序执行\" class=\"headerlink\" title=\"程序的顺序执行\"></a>程序的顺序执行</h3><p>程序执行有固定的时序</p>\n<p>特征：顺序性、封闭性、可再现性</p>\n<h3 id=\"前趋图\"><a href=\"#前趋图\" class=\"headerlink\" title=\"前趋图\"></a>前趋图</h3><ul>\n<li><p>有向无循环图</p>\n</li>\n<li><p>表示方式：</p>\n</li>\n<li><p>p1→p2</p>\n</li>\n<li><p>→&#x3D;{(p1,p2)| p1 必须在p2开始前完成}</p>\n</li>\n<li><p>节点表示：一条语句，一个程序段，一个进程</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c6a473528021428aa23df365e381e37b.png\"></p>\n<h3 id=\"程序的并发执行\"><a href=\"#程序的并发执行\" class=\"headerlink\" title=\"程序的并发执行\"></a>程序的并发执行</h3><p>特征：间断性、失去封闭性（主要由共享资源引起）、不可再现性（并发程序可能对共享资源做不同的修改）</p>\n<p>例子：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/678b664748e849fc9d5817461a02fba5.png\"><br>A在B之前，则N分别为 n+1, n+1, 0</p>\n<p>A在B之后，则N分别为 n, 0, 1</p>\n<p>A在B中间，则N分别为 n, n+1, 0 </p>\n<h3 id=\"并发程序\"><a href=\"#并发程序\" class=\"headerlink\" title=\"并发程序\"></a>并发程序</h3><p>资源共享：系统中资源被多个程序使用</p>\n<p>独立性和制约性：独立的相对速度、起始时间，程序之间相互作用&#x2F;制约</p>\n<p>程序与程序的执行不再一一对应</p>\n<p>引入并发的目的：提高资源利用率和系统效率<br>例子：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/04c9be4ba0f541b18c95eb1bc4a59a19.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0809946d29d847948900230a69f03499.png\"></p>\n<h3 id=\"进程的定义和特征\"><a href=\"#进程的定义和特征\" class=\"headerlink\" title=\"**进程的定义和特征 **\"></a>**进程的定义和特征 **</h3><p>定义：一个具有独立功能的程序在一个数据集合上的一次动态执行的过程。</p>\n<p>多进程可以i提高对硬件资源的利用率，但会增加额外的时间空间开销，增加OS的复杂性。</p>\n<p>特征：动态性、独立性、并发性、异步性、结构化</p>\n<p><strong>进程&#x3D;代码段+数据段+PCB（进程控制块）</strong></p>\n<p><strong>一个程序可以对应多个进程（进程：程序&#x3D;n：1）</strong></p>\n<p><strong>进程是资源申请和系统调度的基本单位</strong><br> 进程 程序 动态的 静态的 程序的执行 代码的集合 暂时的 永久的 状态变化过程 可以长久保存 真实地描述并发 不能真实地描述 可以创建其他进程 不可创建其他程序</p>\n<h3 id=\"进程的特征和状态\"><a href=\"#进程的特征和状态\" class=\"headerlink\" title=\"进程的特征和状态\"></a>进程的特征和状态</h3><p>进程的三种基本状态：就绪、执行、等待&#x2F;阻塞</p>\n<p><strong>进程状态图：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a6af1e104f66452d8432157e516f31b5.png\"></p>\n<hr>\n<h2 id=\"操作系统内核\"><a href=\"#操作系统内核\" class=\"headerlink\" title=\"操作系统内核\"></a>操作系统内核</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a><strong>定义</strong></h3><p>一些与硬件紧密相关的模块、运行频率较高的模块、共用基本操作模块等<strong>常驻内存的且便于提高操作系统运行效能的软件</strong>，称为操作系统内核。</p>\n<h3 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a><strong>功能</strong></h3><ul>\n<li><strong>进程管理</strong>：创建；撤销；调度；控制</li>\n<li><strong>存储管理</strong>：分配&#x2F;回收空间；虚拟存储管理</li>\n<li><strong>I&#x2F;O设备管理</strong>：设备、通道的分配&#x2F;回收；设备的管理；虚拟设备的实现</li>\n<li><strong>中断处理</strong>：操作系统的重要活动都依赖于中断</li>\n</ul>\n<hr>\n<h2 id=\"原语\"><a href=\"#原语\" class=\"headerlink\" title=\"原语\"></a>原语</h2><ul>\n<li>定义：由若干机器指令构成以完成一段特定功能，且在执行过程中不可分割。</li>\n<li>原子操作：一个操作中的所有动作，要么全做，要么不做（All-or-None）</li>\n</ul>\n<h3 id=\"原子操作的实现\"><a href=\"#原子操作的实现\" class=\"headerlink\" title=\"原子操作的实现\"></a>原子操作的实现</h3><ul>\n<li><p>单机系统（<strong>屏蔽中断</strong>）</p>\n</li>\n<li><p>单条指令</p>\n</li>\n<li><p>以屏蔽中断的方式来保证操作的原子性</p>\n</li>\n<li><p>多核系统（<strong>内存栅障</strong>）</p>\n</li>\n<li><p>一个CPU核执行原子操作时，其他CPU核必须不对指定的内存进行操作，避免<strong>数据竞争</strong>问题</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"操作系统控制结构\"><a href=\"#操作系统控制结构\" class=\"headerlink\" title=\"操作系统控制结构\"></a>操作系统控制结构</h2><p>操作系统管理计算机资源常用：</p>\n<ul>\n<li>表格：（或数据结构）记载各资源信息</li>\n<li>代码：对资源管理、维护、更新等</li>\n</ul>\n<h3 id=\"进程控制块PCB\"><a href=\"#进程控制块PCB\" class=\"headerlink\" title=\"进程控制块PCB\"></a>进程控制块PCB</h3><p>PCB：Process Control Block，是一个数据结构。</p>\n<ul>\n<li><strong>是进程存在的唯一标志，且常驻内存</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/37e3413ad65f4a70be4060f9b3051385.png\"></p>\n<p>PCB的组织方式</p>\n<ul>\n<li><p>链接方式</p>\n</li>\n<li><p>把具有同一状态的PCB用其中的链接指针链接成一个队列</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/dde105a7ffe846d1b8e72e9122bd745e.png\"></p>\n<ul>\n<li><p>索引方式</p>\n</li>\n<li><p>系统根据所有进程的状态建立几张索引表</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c1e86af0832943a084651dc3a7854826.png\"></p>\n<h3 id=\"进程组织（进程树）\"><a href=\"#进程组织（进程树）\" class=\"headerlink\" title=\"进程组织（进程树）\"></a>进程组织（进程树）</h3><p>描述了进程的家族关系</p>\n<ul>\n<li>子进程可继承父进程的资源</li>\n<li><strong>父进程的撤销会撤销全部子进程</strong></li>\n<li>根进程：init，launched，pid&#x3D;1</li>\n<li><strong>孤儿进程直接托管给根进程</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/dbba14ab15fb4298903180b31aeddcbc.png\"></p>\n<h3 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h3><p>创建场景：用户登录&#x2F;作业调度&#x2F;提供服务&#x2F;应用请求</p>\n<p>创建过程：申请空白PCB，分配资源，初始化PCB，插入就绪队列</p>\n<h3 id=\"进程控制函数（fork与exec为主）\"><a href=\"#进程控制函数（fork与exec为主）\" class=\"headerlink\" title=\"进程控制函数（fork与exec为主）\"></a>进程控制函数（fork与exec为主）</h3><p><strong>大多数程序中，系统调用的fork和exec是结合在一起使用的：父进程生成一个子进程，再通过调用exec覆盖该子进程。</strong><br><strong>fork()：创建新进程</strong></p>\n<ul>\n<li><p>调用格式：pid &#x3D; fork()</p>\n</li>\n<li><p>调用fork后，父子进程均在下一条语句上继续运行</p>\n</li>\n<li><p>父子进程fork返回值不同</p>\n</li>\n<li><p>失败返回-1</p>\n</li>\n<li><p>在子进程中返回时，pid为0</p>\n</li>\n<li><p>在父进程返回时，为其创建的子进程pid</p>\n</li>\n</ul>\n<p><strong>fork()：两个关键点</strong> </p>\n<ul>\n<li>运行顺序：父子进程运行无关，运行顺序也不固定。（若要运行顺序一定，需要用到进程间通信）</li>\n<li>数据共享：除子进程标识符和PCB特性参数不同外，子进程是父进程的精确复制</li>\n</ul>\n<p>例子：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e4276636ab944eabba6d31fb57c1ad04.png\"></p>\n<p><strong>exec()：执行一个文件的调用</strong></p>\n<ul>\n<li>子进程可以通过exec()调用加载新的程序文件</li>\n<li>子进程可以拥有自己的可执行代码，用新进程覆盖调用进程 </li>\n<li>调用参数：文件+命令行参数。成功：不返回；失败：返回-1</li>\n<li>exec指的是一组函数，一共有6个，分别是</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\t#include &lt;unistd.h&gt;\n\nint execl(const char *path, const char *arg, ...);\n\nint execlp(const char *file, const char *arg, ...);\n\nint execle(const char *path, const char *arg, ..., char *const envp[]);\n\nint execv(const char *path, char *const argv[]);\n\nint execvp(const char *file, char *const argv[]);\n\nint execve(const char *path, char *const argv[], char *const envp[]);</code></pre>\n\n<p>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。</p>\n<p>只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。</p>\n<p>例子:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/eafe9765583249faa1cef7deddd585f7.png\"></p>\n<h3 id=\"进程的终止\"><a href=\"#进程的终止\" class=\"headerlink\" title=\"进程的终止\"></a>进程的终止</h3><p>中止情况：正常结束&#x2F;异常结束&#x2F;外界干预</p>\n<ul>\n<li>正常结束：exit&#x2F;halt&#x2F;logoff</li>\n<li>异常结束：无可用存储器&#x2F;越界&#x2F;保护错误&#x2F;算术错误&#x2F;IO失败&#x2F;无效指令&#x2F;特权指令</li>\n<li>外界干预：kill进程&#x2F;父进程中止</li>\n</ul>\n<p>中止过程：</p>\n<ul>\n<li>检索PCB检查进程状态→执行态改为中止→检查有无子孙需要中止→归还资源给父进程或系统→从PCB队列中移除</li>\n<li>系统调用exit(int ret)，返回ret到父进程，释放所有资源，父进程通过wait()等待子进程结束。（wait(pid, status)，ret）</li>\n</ul>\n<p><strong>例子：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4a41c9ea703d4fce8a98e28f66986229.png\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tProcess A:\nvoid main()&#123;\n    printf(&quot;Hello World!&quot;);\n&#125;\n\nProcess B:\nvoid main()&#123;\n    if((child&#x3D;fork())&lt;0)&#123;\n        printf(&quot;Fork Failed!&quot;);\n    &#125;\n    else if(child&#x3D;&#x3D;0)&#123;\n        if(execv(A)&lt;0)&#123;\n            printf(&quot;Execv Failed!&quot;);\n        &#125;\n        else&#123;\n            printf(&quot;Bye!&quot;)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><ul>\n<li>阻塞&#x2F;唤醒，时间片</li>\n<li>保存现场&#x2F;恢复现场</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/bbb12d65bb9a4e05813c3e5067cfc57f.png\"></p>\n<p>系统调用：会引起从用户态进入核心态</p>\n<hr>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><h3 id=\"与进程的区别和联系\"><a href=\"#与进程的区别和联系\" class=\"headerlink\" title=\"与进程的区别和联系\"></a>与进程的区别和联系</h3><p>进程：线程&#x3D;1：n</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3511d3017b1c4cf0852f14d2ebee33d3.png\"></p>\n<h3 id=\"线程的优势\"><a href=\"#线程的优势\" class=\"headerlink\" title=\"线程的优势\"></a>线程的优势</h3><ul>\n<li><p>减少并发执行时的时空开销（进程的开销较大）</p>\n</li>\n<li><p>线程是系统独立调度的基本单位</p>\n</li>\n<li><p>基本不用有系统资源，只有少量资源，共享其所属进程所拥有的全部资源</p>\n</li>\n</ul>\n<p>【回顾】</p>\n<p><strong>进程是拥有资源和独立运行的基本单位，线程是系统独立调度的基本单位！！！</strong></p>\n<h3 id=\"线程的特点\"><a href=\"#线程的特点\" class=\"headerlink\" title=\"线程的特点\"></a>线程的特点</h3><ul>\n<li>单线程进程，包括进程控制块和用户地址空间，以及用户栈和内核栈。</li>\n<li>多线程环境中，有一个与进程相关联的进程控制块和用户地址空间，每个线程都有一个独立的栈和独立的控制块，包含寄存器值、优先级和其他与线程相关的状态信息。</li>\n<li>进程中的所有线程共享该进程的资源，驻留在同一块地址空间中，并且可以访问到相同的数据。</li>\n<li>线程阻塞不一定会引起进程阻塞。</li>\n</ul>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ul>\n<li><p>执行状态、阻塞状态、就绪状态等</p>\n</li>\n<li><p>阻塞：当线程需要等待一个事件时，它将阻塞，此时处理器执行另一个就绪线程</p>\n</li>\n<li><p>线程切换时保存的线程信息：</p>\n</li>\n<li><p>一个执行栈</p>\n</li>\n<li><p>每个线程静态存储局部变量</p>\n</li>\n<li><p>对存储器和其进程资源的访问</p>\n</li>\n<li><p>派生：产生一个新进程时，同时为其派生一个线程，随后还可以派生另一个线程，新线程被放置在就绪队列中</p>\n</li>\n<li><p>结束：线程完成时，其寄存器信息和栈都被释放</p>\n</li>\n</ul>\n<h3 id=\"线程的分类\"><a href=\"#线程的分类\" class=\"headerlink\" title=\"线程的分类\"></a>线程的分类</h3><ul>\n<li>内核级线程：每个线程在内核看来都是一个进程</li>\n<li>用户级线程：内核无法感知，用户自己控制</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li><p>调度开销</p>\n</li>\n<li><p>内核级线程切换类似于进程切换，开销较大</p>\n</li>\n<li><p>用户级线程切换在同一用户级进程中，无需进入内核，更快</p>\n</li>\n<li><p>执行时间</p>\n</li>\n<li><p>用户级线程以进程为单位平均分配时间，对线程间并发不利（单CPU）</p>\n</li>\n<li><p>内核级线程以线程为单位分配时间（多CPU）</p>\n</li>\n<li><p>并发效率</p>\n</li>\n<li><p>用户线程：线程阻塞导致进程阻塞（内核不知道线程的存在）</p>\n</li>\n<li><p>内核线程：线程阻塞，其他进程&#x2F;线程仍可运行</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"处理机调度\"><a href=\"#处理机调度\" class=\"headerlink\" title=\"处理机调度\"></a>处理机调度</h1><p>分配处理机的任务由进程调度程序完成</p>\n<p>处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能（吞吐量、响应时间），在很大程度上取决于进程调度性能的好坏</p>\n<hr>\n<h2 id=\"⭐单处理机调度（重点）\"><a href=\"#⭐单处理机调度（重点）\" class=\"headerlink\" title=\"⭐单处理机调度（重点）\"></a>⭐单处理机调度（重点）</h2><h3 id=\"调度原则\"><a href=\"#调度原则\" class=\"headerlink\" title=\"调度原则\"></a>调度原则</h3><ul>\n<li><p>面向用户的原则</p>\n</li>\n<li><p>周转时间：作业提交到完成的时间</p>\n</li>\n<li><p>平均周转时间：<img src=\"https://latex.codecogs.com/gif.latex?T=%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi=1%7D%5E%7Bn%7DT_%7Bi%7D\" alt=\"T=\\frac{1}{n}\\sum_{i=1}^{n}T_{i}\"></p>\n</li>\n<li><p>平均带权：<img src=\"https://latex.codecogs.com/gif.latex?T=%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi=1%7D%5E%7Bn%7D%5Cfrac%7BT_%7Bi%7D%7D%7BT_%7Bi,s%7D%7D\" alt=\"T=\\frac{1}{n}\\sum_{i=1}^{n}\\frac{T_{i}}{T_{i,s}}\">  越接近1越好，越大越差</p>\n</li>\n<li><p><img src=\"https://latex.codecogs.com/gif.latex?T_%7Bi%7D\" alt=\"T_{i}\">：周转时间</p>\n</li>\n<li><p><img src=\"https://latex.codecogs.com/gif.latex?T_%7Bi,s%7D\" alt=\"T_{i,s}\">：实际运行时间 </p>\n</li>\n<li><p>响应时间：（交互式作业）提交请求到首次响应的时间</p>\n</li>\n<li><p>截止时间：开始&#x2F;完成截止时间</p>\n</li>\n<li><p>优先级：需要抢占&#x2F;剥夺调度</p>\n</li>\n<li><p>面向系统的原则</p>\n</li>\n<li><p>吞吐量：单位时间完成作业数</p>\n</li>\n<li><p>利用率</p>\n</li>\n<li><p>公平性</p>\n</li>\n<li><p>优先级</p>\n</li>\n</ul>\n<h3 id=\"调度算法：资源分配问题\"><a href=\"#调度算法：资源分配问题\" class=\"headerlink\" title=\"调度算法：资源分配问题\"></a>调度算法：资源分配问题</h3><p><img src=\"https://img-blog.csdnimg.cn/4629489cda864f1880b667207dd0605e.png\"></p>\n<h3 id=\"先来先服务：FCFS\"><a href=\"#先来先服务：FCFS\" class=\"headerlink\" title=\"先来先服务：FCFS\"></a><strong>先来先服务：FCFS</strong></h3><p>简单来说，它就是按顺序执行。</p>\n<p> </p>\n<p>评价</p>\n<ul>\n<li>非抢占调度</li>\n<li>对长进程有利，不利于短进程</li>\n<li>适合CPU繁忙型进程，不适合I&#x2F;O繁忙型进程（系统角度）</li>\n<li>不能直接用于分时系统</li>\n<li>往往与其它调度算法综合使用</li>\n</ul>\n<p><strong>例子：</strong><br><img src=\"C:\\Users\\tao020704\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230214221142005.png\" alt=\"image-20230214221142005\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/18c7691829694703914613e5354d3afa.png\">**平均周转时间：((2-0)+(8-1)+(9-2)+(14-3))&#x2F;4 &#x3D; 6.75 **</p>\n<p><strong>平均等待时间：(0+1+6+6)&#x2F;4 &#x3D; 3.25(注意区分，可能会出审题性错误)</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/51dd740c7d1543359a7e0988dd40115c.png\"></p>\n<h3 id=\"短作业优先：SPF-x2F-SJF\"><a href=\"#短作业优先：SPF-x2F-SJF\" class=\"headerlink\" title=\"短作业优先：SPF&#x2F;SJF\"></a>短作业优先：SPF&#x2F;SJF</h3><p>执行时间短的先执行</p>\n<p>评价</p>\n<ul>\n<li>有利于短进程，提高了平均周转时间</li>\n<li>长进程可能被饿死（starvation）</li>\n<li>需要知道或估计每个进程的处理时间。</li>\n</ul>\n<p> </p>\n<p> </p>\n<p><strong>例子：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/773cd7dc97534e70bd10ee2cfd610da2.png\"> </p>\n<p><img src=\"https://img-blog.csdnimg.cn/ea116fa8ec354e288fb32452b6734c33.png\">**平均周转时间：(2+13+1+5)&#x2F;4 &#x3D; 5.25 **</p>\n<p><strong>平均等待时间：(0+7+0+0)&#x2F;4 &#x3D; 1.75</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed92484c83a145feaee6009842b47279.png\"></p>\n<h3 id=\"时间片轮转调度：TSRR\"><a href=\"#时间片轮转调度：TSRR\" class=\"headerlink\" title=\"时间片轮转调度：TSRR\"></a>时间片轮转调度：TSRR</h3><p> </p>\n<p>每过固定时间就换下一个进程（按FSCS） </p>\n<p>专门为分时系统设计（FCFS的优化）</p>\n<p>​\t <strong>时间片长度变化的影响</strong></p>\n<ul>\n<li>&#96;&#96;&#96;<ul>\n<li>过长：退化为FCFS，进程在一个时间片内执行完</li>\n<li>过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  **评价**\n\n* &#96;&#96;&#96;\n  * 相对公平\n  * 偏向于CPU型的进程\n  * 中断开销 </code></pre></li>\n</ul>\n</li>\n</ul>\n<p><strong>例子：</strong> </p>\n<p><strong>q指的是时间片长度</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f32026acfc428986d8e4f9d4ee7ea0.png\"></p>\n<p><strong>平均周转时间：(4+16+12+13+5)&#x2F;5 &#x3D; 10</strong></p>\n<p><strong>平均等待时间：(1+10+9+9+5)&#x2F;5 &#x3D; 6.8</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8488aa7a7acf4a0384e5fad501bc5f75.png\"></p>\n<p><strong>平均周转时间：(3+15+7+14+11)&#x2F;5 &#x3D; 10</strong></p>\n<p><strong>平均等待时间：(0+9+3+9+9)&#x2F;5 &#x3D; 6</strong></p>\n<h3 id=\"最短剩余时间调度：SRT\"><a href=\"#最短剩余时间调度：SRT\" class=\"headerlink\" title=\"最短剩余时间调度：SRT\"></a>最短剩余时间调度：SRT</h3><p>对SJF加入剥夺机制：当新进程进入时，可能比当前运行的进程具有更短的剩余时间</p>\n<ul>\n<li><p>优点</p>\n</li>\n<li><p>不偏爱长进程，也不像RR产生额外中断，减少了开销。</p>\n</li>\n<li><p>周转时间方面，比SJF好，短作业可以立即被选择执行。</p>\n</li>\n<li><p>问题</p>\n</li>\n<li><p>需要知道或估计每个进程所需处理时间；</p>\n</li>\n<li><p>若持续有短进程存在，长进程可能被饿死；</p>\n</li>\n<li><p>记录过去的服务时间（以便计算剩余时间）→ 增加了开销。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6d652bb8299b4e208ac789e801aab4a3.png\"></p>\n<h3 id=\"基于优先权-x2F-优先级的调度算法\"><a href=\"#基于优先权-x2F-优先级的调度算法\" class=\"headerlink\" title=\"基于优先权&#x2F;优先级的调度算法\"></a>基于优先权&#x2F;优先级的调度算法</h3><p>就是先运行优先级高的</p>\n<p>优先级</p>\n<ul>\n<li>&#96;&#96;&#96;<br>每个进程设有一个优先级，调度程序选择具有较高优先级的进程。<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n静态优先级(static)\n</code></pre>\n<ul>\n<li>优先数在进程创建时分配，生存期内不变。</li>\n<li>响应速度慢，开销小。</li>\n<li>适合批处理进程<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n动态优先级(dynamic)\n</code></pre></li>\n<li>进程创建时继承优先级，生存期内可以修改。</li>\n<li>响应速度快，开销大。<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n* 问题\n\n  &#96;低优先级的进程可能会饿死（无穷阻塞）&#96;\n\n* 改进\n\n  &#96;一个进程的优先级随着它的时间或执行历史而变化——老化策略(aging)。&#96; \n\n  &#96;执行过程中不断调整其优先级 （如：优先级随执行时间增加而下降，随等待时间增加而升高。）&#96;\n\n  &#96;优点：长短兼顾&#96;\n\n### 高响应比优先算法：HRRN\n\n响应比R &#x3D; 周转时间&#x2F;服务时间 &#x3D; (w+s)&#x2F;s       \n\n(w: 等待时间 ；s: 服务时间)\n\n就是先运行响应比高的（**综合考虑等待时间和作业长度**）\n\n* 评价\n\n  &#96;FCFS和SJF的结合，克服了两种算法的缺点&#96;\n\n  &#96;公平，吞吐率大&#96;\n\n  &#96;需要估计服务时间，增加了计算，增加了开销&#96;\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;c58da37a0c02412889d722d2b8020988.png)\n\n### 多级队列调度算法\n\n将就绪队列分成多个独立队列，进程所属的队列固定。通过对各队列的区别对待，达到一个综合的调度目标。 \n\n \n\n* 策略\n\n  &#96;不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）&#96;\n\n  &#96;队列之间的区别：采用固定优先级、可抢占调度来实现 （如前台队列优先级高于后台队列优先级。 ）&#96;\n\n  &#96;只有优先级高的队列中没有进程时，才可以调度优先级低的队列中的进程 &#96;\n\n### 多级反馈队列调度：MFQ\n\n多级反馈队列算法是多级队列和动态优先级算法的综合和发展。\n\n按时间片、等待时间，使用动态优先级机制；调度基于剥夺原则。\n\n* 策略\n\n  &#96;不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）&#96;\n\n  &#96;多个就绪队列，进程所属队列可变，即进程可以在不同的就绪队列之间移动&#96;\n\n  &#96;多个就绪队列分别赋予不同的优先级&#96;\n\n  &#96;队列优先级逐级降低，而时间片长度逐级递增&#96;\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;a437cca9aa7d49b8aa8d02e0db7e611a.png)\n\n调度过程\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>新进程进入后，先放入队列0的末尾，按RR顺序调度；</li>\n<li>若执行过程中阻塞，则离开队列，被唤醒后，放入同一优先级队列尾部；</li>\n<li>若在规定时间片未能执行完，则降低优先级投入队列1的末尾，同样按RR算法调度；如此下去，直到最后的队列；<br> 1. 若只有1个进程，则不降级；<br> 2. 可有效应对I&#x2F;O繁忙进程。</li>\n<li>最后队列按FCFS或者RR（但不再降级）调度直到完成；</li>\n<li>若在最后队列等待时间过长，提升优先级；</li>\n<li>仅当较高优先级的队列为空，才调度较低优先级的进程执行；<br> 1. 当前进程一旦开始执行，时间片结束前不被抢占；<br> 2. 若按优先级调度的进程为上一个被抢占的进程，则忽略之，调度下一个候选；</li>\n</ol>\n<p> </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3951b06c3ae2470dbef7aca37f42e95b.png)\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;7ca42f0c4b694272847487b5cc8ca218.png)\n\n### 总结\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;d521d900f4fe4bd29eeea6640c7d63e7.png)\n\n----\n\n## 实时调度 \n\n### 基本条件\n\n* 就绪时间：成为就绪状态的时间\n* 开始&#x2F;完成截止时间\n* 处理时间\n* 资源要求\n* 优先级\n\n### 系统处理能力下界\n\n假定系统中有m个周期性的实时任务，它们的处理时间为Ci，周期为Pi，则在单&#x2F;多处理机情况下，可调度的必要条件：\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;d8ef312a3d4f45d3b481ca28d7269161.png)![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;7e0f4bc0f76347aeabe145acd1e91d2d.png)\n\n### 实时调度算法\n\n* **基于时间片轮转调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;27b0c6fc983240ac92ccb54ea87719fa.png)\n\n  \n\n* **基于优先级的非抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fa38c8747d71449daf07bbb7a7b80dce.png)\n\n  \n\n* **基于抢占点的抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3155de64c2784a2b825a217426458dbf.png)\n\n  \n\n* **立即抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;710daa2463a6499c9eb9fb945d038b7b.png)\n\n  \n\n* **最早截止时间优先（EDF）**\n\n* 可以是抢占式或非抢占式\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fbd29d111c37415fa16c2d3bde7894b8.png)\n\n  \n\n* **最低松弛度优先算法（LLF）**\n\n* 主要用于可抢占调度方式\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;b213d20babb54559847ee09ba309f2dc.png)\n\n* 例子：\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;1c44a37039a34ad79a3959222d315f86.png)\n\n* 速度单调调度\n\n  &#96;任务周期：周期性任务&#96;\n\n  &#96;任务速度：1&#x2F;任务周期&#96;\n\n  &#96;速度越快，优先级越高&#96;\n\n----\n\n## 多处理机调度\n\n### 分类\n\n* 紧密耦合\n\n  &#96;共享RAM和I&#x2F;O&#96;\n\n  &#96;高速总线和交叉开关连接&#96;\n\n* 松弛耦合\n\n  &#96;独立RAM和I&#x2F;O&#96;\n\n  &#96;通道和通信线路连接&#96;\n\n* 对称多处理器系统 SMP：Symmetric Multiprocessing\n\n* 非对称多处理器系统 AMP：Asymmetric Multiprocessing \n\n### 进程分配方式\n\n* SMP中进程分配方式\n\n  &#96;静态分配&#96;\n\n  &#96;动态分配：可防止系统中多个处理器忙闲不均&#96;\n\n* 非SMP中进程分配方式\n\n  &#96;进程调度在主处理器上执行&#96;\n\n  &#96;有潜在的不可靠性&#96;\n\n### 单队列多处理机调度\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;98b40bf1bde045cb84c1043a360e72bf.png)\n\n各个处理机自行在就绪队列中取任务（先纵向看，再横向看）。\n\n优点：简单，分布式调度，多个CPU利用率都好\n\n缺点：瓶颈问题（单队列→共享资源→锁） 低效性：cache affinity （下图为改进） \n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;cf606d6b50d143d9959518710e9ad35f.png)\n\n### 多队列多处理机调度\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;8300a984b1364ed3ae63d982266c5b60.png)每个CPU一个队列：没有SQMS的问题，但是可能负载不均衡，导致资源分配不合理。\n\n### 成组调度\n\n* 优点：\n\n  &#96;对相互合作的进（线）程组调度，可以减小切换，减小系统开销。&#96;\n\n  &#96;每次分配一组CPU，减少了调度频率。&#96;\n\n* 分配时间\n\n  &#96;面向程序&#96;\n\n  &#96;面向线程：使处理机利用率更高。 &#96;\n\n### 专用处理机分配 \n\n* &#96;特点：每个进（线）程专用处理机，使其切换小，提高效率。&#96;\n\n* 主要用于大型计算，实时系统\n\n  &#96;Sony PlayStation 3 (PPU&#x2F;SPU) → CELL&#96;\n\n  &#96;神威太湖之光：众核（4+256)&#96;\n\n----\n\n# 进程并发控制：互斥与同步\n\n----\n\n## 进程&#x2F;线程的并发控制\n\n进程&#x2F;线程是计算机中的独立个体：异步性（并发性）\n\n资源是计算机中的稀缺个体：独占性（不可复用性）\n\n进程&#x2F;线程协作完成任务（协作）\n\n并发控制：进程&#x2F;线程在推进时的相互制约关系\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3b53006c85164ed19de54578f2d034f1.png)\n\n并发执行进程能有效地共享资源和相互合作，并按一定顺序执行。\n\n----\n\n## 基本概念\n\n* 进程间的制约关系\n\n  ​\t&#96;间接制约：资源共享→互斥&#96;\n\n  ​\t&#96;直接制约：进程合作→同步&#96;\n\n* 临界资源（Critical  Resource）\n\n  ​\t&#96;一次仅允许一个进程访问的资源&#96;\n\n* 临界区（Critical  Section）\n\n  ​\t&#96;进程中访问临界资源的代码段&#96;\n\n* 忙等、饥饿、死锁\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;741684ccdbc54bea99b73f3a3d308433.png)&#96;\n\n* 活锁\n\n* &#96;两个或多个进程不断更改其状态以响应其他进程的更改而不执行任何有用工作的情况。&#96;\n\n  ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;bf55e6d2eccb4b428f31f4a17df3e136.png)\n\n* 同步原则\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;dfc4a47195a4411c8c0bc549f29cffd9.png)\n\n----\n\n## 同步的解决策略\n\n### 软件方法\n\n进程通过执行相应的程序指令，实现与其他进程的互斥与同步\n\n### 硬件方法\n\n* &#96;&#96;&#96;\n  * 屏蔽中断：确保互斥执行\n    * 缺点：\n  \t* 系统无法响应外部请求\n  \t* 无法接受异常，处理系统故障\n  \t* 无法切换进程→性能下降\n  \t* 不支持多处理机</code></pre>\n\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">* 机器指令\n\t* 原子性：all-or-nothing\n\t* 单处理器：一个周期内完成的指令\n\t* 多处理器：LOCK总线\n\t\t* Test &amp; Set\n\t\t\t* 测试某个变量的值，如果为0，则置1，并返回当前值\n\t\t* Exchange\n\t\t\t* 原子性地交换寄存器和内存的值\n\t* 优点：\n\n\t\t* 支持多处理机\n\t\t* 简单易证明\n\t\t* 支持多临界区\n\t* 缺点：\n\t\t* 忙等现象\n\t\t* 饥饿现象\n\t\t* 死锁现象</code></pre>\n\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><ul>\n<li><p>原理：</p>\n<p><code>多进程通过信号传递协调工作，根据信号指示停止执行（阻塞等待）或者向前推进（唤醒）。</code></p>\n</li>\n<li><p>信号：信号量s</p>\n<p><code>+：资源数量</code></p>\n<p><code>-：排队数量</code></p>\n</li>\n<li><p>原语：</p>\n<p><code>wait(s)：等待信号，并占有资源        ——&gt;P操作</code></p>\n<p><code>signal(s)：释放资源，并激发信号     ——&gt;V操作</code></p>\n</li>\n<li><p>分类</p>\n</li>\n<li><p>&#96;&#96;&#96;</p>\n<ul>\n<li>整数型信号量（如下图）</li>\n<li>记录型信号量</li>\n<li>AND型信号量<ul>\n<li>将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。<ul>\n<li>只要有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给它</li>\n</ul>\n</li>\n<li>原子操作<ul>\n<li>要么全部分配到进程，要么全不分配</li>\n</ul>\n</li>\n<li>在wait操作中，增加一个AND条件，故称为AND同步，或称为同时wait操作<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  * ![整数型信号量](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;be11aba3992e42a1ab5d3d80949c01ad.png)\n\n* 信号量正负的含义\n\n  &#96;s.value ≥ 0：是可以在不挂起的情况下执行等待的进程数。&#96;\n\n  &#96;s.value &lt; 0：s.value 的大小是 s.queue 中挂起的进程数。&#96;\n\n* 信号量集\n\n  * 采用信号量集来控制，可以分配多个资源\n  * swait(S1, t1, d1, …, Sn, tn, dn） ti：资源下限； di：需求量\n    * ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;1868ea2fd95341c2af44532ae8972dce.png) \n\n\n### 管程\n\n管程的组成\n\n* 局部于该管程的共享数据，这些数据表示了相应资源的状态；\n* 针对上述数据的一组过程；\n* 对局部于该管程的数据的初始化。\n\n管程的特点\n\n* 模块化（Modularization）\n\n  &#96;管程是一个基本程序单位，可以单独编译;&#96;\n\n* 抽象数据类型（Abstraction)\n\n  &#96;管程中不仅有数据，而且有对数据的操作;&#96;\n\n* 信息隐藏（Encapsulation）\n\n  &#96;管程外可以调用管程内部定义的函数，但函数具体实现外部不可见;&#96;\n\n  &#96;局部数据变量只能被管程的过程访问，任何外部过程都不能访问。&#96;\n\n管程的同步\n\n* &#96;&#96;&#96;\n  * 进程通过调用管程的一个过程进入管程；\n  * 在任何时候，只能有一个进程在管程中执行；调用管程的任何其他进程都被挂起，以等待管程变成可用。\n  * 条件变量提供同步支持（非默认锁）。条件变量包含在管程中，并且只有在管程中才能被访问：\n  \t* cwait(x)：调用进程的执行在条件x上挂起，管程现在可被另一进程使用。\n  \t* csignal(x)：恢复阻塞在x上的进程。</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"⭐进程并发控制：信号量的应用（重点）\"><a href=\"#⭐进程并发控制：信号量的应用（重点）\" class=\"headerlink\" title=\"⭐进程并发控制：信号量的应用（重点）\"></a>⭐进程并发控制：信号量的应用（重点）</h1><p>展示一些信号量实例，也是重点考察的地方</p>\n<hr>\n<h2 id=\"观察者问题\"><a href=\"#观察者问题\" class=\"headerlink\" title=\"观察者问题\"></a>观察者问题</h2><p>观察者和报告者是两个并发执行的进程。 观察者不断观察并对通过的卡车计数； 报告者不停地将观察者的计数打印，并归零。 请用P、V原语进行正确描述。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6a0a37db3877451dac29553581d77fe4.png\"></p>\n<hr>\n<h2 id=\"图书馆问题\"><a href=\"#图书馆问题\" class=\"headerlink\" title=\"图书馆问题\"></a>图书馆问题</h2><p>图书馆有N个座位，一张登记表，要求： 读者进入时需先登记，取得座位号； 出来时注销 用P、V原语描述读者的使用过程。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fc43b4ee533d452cbedf8f19dc5e6289.png\"></p>\n<hr>\n<h2 id=\"公交车问题\"><a href=\"#公交车问题\" class=\"headerlink\" title=\"公交车问题\"></a>公交车问题</h2><p>司机启动车辆的动作必须于售票员关车门的动作取得同步；售票员开车门的动作也必须与司机停车取得同步。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1a472a231f0e45a58654c17c2c194e48.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7917f57a0cc948f29a6fa173296cd96a.png\"></p>\n<hr>\n<h2 id=\"⭐生产者-x2F-消费者问题（重点）\"><a href=\"#⭐生产者-x2F-消费者问题（重点）\" class=\"headerlink\" title=\"⭐生产者&#x2F;消费者问题（重点）\"></a>⭐生产者&#x2F;消费者问题（重点）</h2><p>生产者&#x2F;消费者模型：</p>\n<p>生产者：满则等待，空则填充</p>\n<p>消费者：空则等待，有则获取</p>\n<p>不允许同时进入缓冲区</p>\n<p>无限缓冲：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/efe8667c5ebc4ed5bbe0e472d4451bfe.png\"></p>\n<p>有限循环&#x2F;环形缓冲区：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7d8f755d21b649b3b5563f154be6a49d.png\"><img src=\"https://img-blog.csdnimg.cn/bdb72717399d4f098364b901b6abbd60.png\"></p>\n<h3 id=\"例题：\"><a href=\"#例题：\" class=\"headerlink\" title=\"例题：\"></a>例题：</h3><p>有3个进程PA，PB和PC合作解决文件打印问题：</p>\n<p>​\tPA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录;</p>\n<p>​\tPB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；</p>\n<p>​\tPC将缓冲区2的内容打印出来，每执行一次打印一个记录。</p>\n<p>​\t缓冲区的大小等于一个记录大小。</p>\n<p>请用P，V操作来保证文件的正确打印。 </p>\n<p><img src=\"https://img-blog.csdnimg.cn/da3280088066461e947198fb3e8d6d2f.png\"></p>\n<p>信号量：</p>\n<p>​\t\tempty1，empty2：分别表示缓冲区1及缓冲区2是否为空，初值为1。</p>\n<p>​\t\tfull1，full2：分别表示缓冲区1及缓冲区2是否有记录可供处理，初值为0。</p>\n<p>​\t\tmutex1，mutex2：分别表示缓冲区1及缓冲区2的访问控制，初值为1。 </p>\n<p><img src=\"https://img-blog.csdnimg.cn/c41db669a9f14466817b53abc9fae765.png\"></p>\n<h3 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h3><ul>\n<li>资源数量：资源信号量</li>\n<li>资源访问：互斥信号量</li>\n<li>先申请资源，再申请访问权</li>\n<li>资源信号量P、V操作分布在不同进程</li>\n<li>互斥信号量P、V操作出现在同一进程</li>\n</ul>\n<p> </p>\n<hr>\n<h2 id=\"⭐读-x2F-写者问题（重点）\"><a href=\"#⭐读-x2F-写者问题（重点）\" class=\"headerlink\" title=\"⭐读&#x2F;写者问题（重点）\"></a>⭐读&#x2F;写者问题（重点）</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">三个角色：一个共享的数据区； Reader: 只读取这个数据区的进程； Writer: 只往数据区中写数据的进程；\n三个条件：多个Reader可同时读数据区； 一次只有一个Writer可以往数据区写； 数据区不允许同时读写。（“读－写” 互斥；“写－写” 互斥；“读－读” 允许）</code></pre>\n\n<h3 id=\"读者优先\"><a href=\"#读者优先\" class=\"headerlink\" title=\"读者优先\"></a>读者优先</h3><p>一旦有读者正在读数据，则允许随后的读者进入读数据；只有当全部读者退出，才允许写者进入写数据；导致<strong>写者饥饿</strong></p>\n<p><strong>信号量设置：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">wsem：互斥信号量，用于Writers间互斥，Writers和Readers互斥\n\nreadcount：统计同时读数据的Readers个数\n\nmutex：对变量readcount互斥算术操作</code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tint readcount&#x3D;0；\nsemaphore mutex &#x3D; 1, wsem&#x3D;1;\n \nvoid reader() &#123; \n while (1) &#123;\n  P(mutex);\n   readcount++;\n   if (readcount&#x3D;&#x3D;1) P(wsem); \n  V(mutex);\n  READ;\n  P(mutex);\n   readcount--;\n   if (readcount&#x3D;&#x3D;0) V(wsem);\n  V(mutex);\n  &#125;\n&#125;\n \nvoid writer() &#123;\n while (1) &#123;\n   P(wsem);\n    WRITE;\n   V(wsem);\n &#125;\n&#125;</code></pre>\n\n<h3 id=\"写者优先\"><a href=\"#写者优先\" class=\"headerlink\" title=\"写者优先\"></a>写者优先</h3><p>当至少有一个写者声明想写数据时，则不再允许新的读者进入读数据。例如：队列：（尾)WWRRW(头)，让三个W进程能优先于R进程写数据。解决了写者饥饿问题，但<strong>降低了并发程度，系统的并发性能较差</strong>。</p>\n<p><strong>信号量设置:</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">wsem：互斥信号量，用于Writers间互斥，Reader互斥Writers\n\nrsem：互斥信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据。第一个写者受rsem影响，一旦有第一个写者，后续写者不受rsem其影响。但是读者需要在rsem上排队。\n\nmwc：用于控制writecount互斥算术操作\n\nmrc：用于控制readcount互斥算术操作\n\nz:  对读者进行控制，防止在rsem上出现读进程的长队列，否则写进程不能跳过这个队列</code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tint readcount, writecount;\nsemaphore mrc&#x3D;l, mwc&#x3D;1, z&#x3D;1, wsem&#x3D;1, rsem&#x3D;l;\n\nvoid reader( ) &#123;\n  while (1) &#123;\n   P(z);\n    P(rsem);\n     P(mrc);\n      readcount++;\n      if (readcount &#x3D;&#x3D; 1) P(wsem);\n     V(mrc);\n    V(rsem)；\n   V(z);\n   READ;\n   P(mrc);\n    readcount--;\n    if (readcount &#x3D;&#x3D; 0) V(wsem);\n   V(mrc);\n   &#125;\n &#125;\n\nvoid writer( ) &#123;\n  while (1) &#123;\n    P(mwc);\n     writecount++;\n     if (writecount &#x3D;&#x3D; 1) P(rsem);\n    V(mwc);\n    P(wsem);\n     WRITE;\n    V(wsem);\n    P(mwc);\n     writecount--;\n     if (writecount &#x3D;&#x3D; 0) V(rsem);\n    V(mwc);\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"公平优先\"><a href=\"#公平优先\" class=\"headerlink\" title=\"公平优先\"></a>公平优先</h3><p><strong>写过程中，若其它读者、写者到来，则按****到达顺序处理</strong></p>\n<p><strong>信号量设置：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">w：互斥信号量，用于Writers间互斥，Reader互斥Writers\n\nreadcount：统计同时读数据的Readers个数\n\nmrc：对变量readcount互斥算术操作\n\nr：互斥信号量，确定Writer 、Reader请求顺序</code></pre>\n\n<p>​\t\t在读者优先中，wsem只对第一个读者起阻塞作用，后续读者不受其影响。为了保证按照到达顺序处理，故公平优先方式设置wrsem,读者／写者按到达顺序在wrsem上排队。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tint readcount &#x3D; 0;\nsemaphore mrc &#x3D; 1, r &#x3D; 1, w &#x3D; 1;\n\nREADER &#123;\n  P(r);\n    P(mrc);\n      readcount++;\n      if (readcount &#x3D;&#x3D; 1) P(w);\n    V(mrc);          \n  V(r);\n \n  Read();\n \n  P(mrc);\n     readcount--;\n     if (readcount &#x3D;&#x3D; 0) V(w);\n  V(mrc);  \n&#125; \n\nWRITER &#123;\n  P(r);\n  P(w);\n\n  Write();\n\n  V(w);  \n  V(r);\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"⭐理发师问题（重点）\"><a href=\"#⭐理发师问题（重点）\" class=\"headerlink\" title=\"⭐理发师问题（重点）\"></a>⭐理发师问题（重点）</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">角色和资源：一个理发师 一个理发椅 一排座位 随机到来的客户\n\n场景：理发师：有客干活，无客睡觉；客户：唤醒理发师，有位等待，无位离开 \n\n此问题无死锁，有饥饿（以排队方式解决饥饿问题）</code></pre>\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\t&#x2F;* # of customers waiting *&#x2F;\nsemaphore customers &#x3D; 0; \n&#x2F;* barber status *&#x2F;\nsemaphore barbers &#x3D; 0;          \n&#x2F;* mutual exclusion to access seats *&#x2F;\nsemaphore mutex &#x3D; 1;            \n&#x2F;* # of available seats. *&#x2F;\nint nas &#x3D; N;                \n\nvoid barber(void) &#123;\n  while (TRUE) &#123;\n    P(customers); \n    P(mutex);           \n    nas++;  \n    V(barbers);           \n    V(mutex);             \n    cut_hair();             \n  &#125;\n&#125;\n\nvoid customer(void) &#123;\n  P(mutex); \n  if (nas &gt; 0) &#123;\n    nas--; \n    V(customers);        \n    V(mutex); \n    P(barbers);\n    get_haircut(); \n  &#125; else &#123;\n    V(mutex); \n    leave_shop();\n  &#125;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"⭐哲学家问题（重点）\"><a href=\"#⭐哲学家问题（重点）\" class=\"headerlink\" title=\"⭐哲学家问题（重点）\"></a>⭐哲学家问题（重点）</h2><p>哲学家就餐问题可以用来解释死锁和资源耗尽。</p>\n<p>描述：5个哲学家围坐一张餐桌；5只餐叉（筷子）间隔摆放；思考或进餐；进餐时必须同时拿到两边的餐叉；思考时将餐叉放回原处。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\t#define  N  5\n#define  LEFT  (i-1+N)%N\n#define  RIGHT (i+1)%N\n#define  THINKING   0\n#define  HUNGRY     1\n#define  EATING     2\n\nint state[N] &#x3D; &#123;0, 0, 0, 0, 0&#125;;\nsemaphore mutex &#x3D; 1;\nsemaphore s[N]&#x3D;&#123;0,0,0,0,0&#125;;\n\nvoid philosopher(int i)&#123;\n  while (TRUE) &#123;\n    think();\n    take_forks(i);\n    eat();\n    put_forks(i);\n  &#125;\n&#125;\n\nvoid take_forks(int i)\n&#123;\n     P(mutex);\n     state[i] &#x3D; HUNGRY;\n     test(i);\n     V(mutex);\n     P(s[i]);\n&#125;\n\nvoid put_forks(i)\n&#123;\n     P(mutex);\n     state[i] &#x3D; THINKING;\n     test(LEFT);\n     test(RIGHT);\n     V(mutex);\n&#125;\n\n\nvoid test(int i) \n&#123;\n  if (state[i] &#x3D;&#x3D; HUNGRY &amp;&amp; \n      state[LEFT] !&#x3D; EATING &amp;&amp; \n      state[RIGHT] !&#x3D; EATING) &#123;\n    state[i] &#x3D; EATING;\n    V(s[i]);\n  &#125;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"重点知识点回顾\"><a href=\"#重点知识点回顾\" class=\"headerlink\" title=\"重点知识点回顾\"></a>重点知识点回顾</h2><p><img src=\"https://img-blog.csdnimg.cn/890b9f1b2f4e4cde818e897180426e2a.png\"></p>\n<hr>\n<h1 id=\"进程并发控制：练习题\"><a href=\"#进程并发控制：练习题\" class=\"headerlink\" title=\"进程并发控制：练习题\"></a>进程并发控制：练习题</h1><h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h3><p>​\t桌子上有一只盘子，最多可以放入N（N&gt;0）个水果</p>\n<p>​\t爸爸随机向盘中放入苹果或桔子； 儿子只吃盘中的桔子； 女儿只吃盘中的苹果； 只有盘子中水果数目小于N时，爸爸才可以向盘子中放水果； 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果； 每次只能放入或取出一个水果，不允许多人同时使用盘子。</p>\n<p>​\t用P、V操作实现爸爸、儿子和女儿之间的同步与互斥活动。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tsemaphore mutex &#x3D; 1;                &#x2F;&#x2F;盘子操作互斥信号量\nsemaphore apple &#x3D; 0, orange &#x3D; 0;    &#x2F;&#x2F;苹果、桔子放入、取出的资源信号量\nsemaphore empty &#x3D; N;                &#x2F;&#x2F;盘子中可放入的水果数目\n\ndad()\n&#123;\n    while (true) &#123;\n       result&#x3D; prepare _fruit();    &#x2F;&#x2F;准备水果，result为水果类型\n       P(empty);                    &#x2F;&#x2F;盘子中可放入的水果数目减1\n       P(mutex);                    &#x2F;&#x2F;互斥访问盘子\n       put a fruit on the plate;    &#x2F;&#x2F;将一个水果放入盘子\n       V(mutex);                    &#x2F;&#x2F;恢复访问盘子\n       if (result &#x3D;&#x3D; fruit_apple)   &#x2F;&#x2F;准备的水果为苹果\n         V(apple);                  &#x2F;&#x2F;允许女儿取苹果\n       else                         &#x2F;&#x2F;准备的水果为桔子\n         V(orange);                 &#x2F;&#x2F;允许儿子取桔子\n    &#125;\n&#125;\n\nson() &#123;\n    while (true) &#123;\n         P(orange);                            &#x2F;&#x2F;互斥取桔子\n         P(mutex);                             &#x2F;&#x2F;互斥访问盘子\n         get an orage from plate();            &#x2F;&#x2F;取桔子\n         V(mutex);                             &#x2F;&#x2F;恢复访问盘子\n         V(empty);                             &#x2F;&#x2F;盘子中可放入的水果数目加1\n    &#125;\n&#125;\n\ndaughter() &#123;\n    while (true) &#123;\n         P(apple);                             &#x2F;&#x2F;互斥取水果\n         P(mutex);                             &#x2F;&#x2F;互斥访问盘子\n         get an apple from plate();            &#x2F;&#x2F;取苹果\n         V(mutex);                             &#x2F;&#x2F;恢复访问盘子\n         V(empty);                             &#x2F;&#x2F;盘子中可放入的水果数目加1\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>桌子上有一只盘子，只能放一只水果</p>\n<p>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子。 儿子只吃盘中的桔子，女儿只吃盘中的苹果。 只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果。 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果。 同一时刻只能有一个人操作盘子</p>\n<p>请用信号量机制实现爸爸、妈妈、儿子和女儿之间的同步与互斥活动。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tsemaphore plate &#x3D; 1;     &#x2F;&#x2F;盘子是否有空间\nsemaphore mutex &#x3D; 1;\nsemaphore apple &#x3D; 0, orange &#x3D; 0;  &#x2F;&#x2F;盘子中是否有苹果、桔子\n\ndad() &#123;\n    while (true) &#123;\n      prepare an apple;\n      P(plate);                               \n      P(mutex)\n      put the apple on the plate;  \n      V(mutex)\n      V(apple);                            \n    &#125;\n&#125;\n\nmom() &#123;\n  while (true) &#123;\n    prepare an orange;\n    P(plate); \n    P(mutex); \n    put the orange on the plate;  \n    V(mutex)\n    V(orange);                            \n  &#125;\n&#125;\n\nson()\n&#123;\n    while (true) &#123;\n      P(orange);\n      P(mutex);\n      get an orange; \n      V(mutex);\n      V(plate);                                       \n   &#125;\n&#125;\n\ndaughter()\n&#123;\n    while (true) &#123;\n      P(apple); \n      P(mutex);\n      get an apple;\n      V(mutex);\n      V(plate);\n    &#125;\n&#125;</code></pre>\n\n<p>因为缓冲区大小就为1，所以可以省略mutex信号量。</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>桌子上有一只盘子 最多可以放入2个水果。</p>\n<p>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果。 当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果。 不允多人同时使用盘子</p>\n<p>请用信号量机制实现爸爸、妈妈和女儿之间的同步与互斥活动。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tsemaphore apple &#x3D; 0, orange &#x3D; 0;    &#x2F;&#x2F;盘子中是否有苹果、桔子\nsemaphore empty_apple &#x3D; 1, empty_orange &#x3D; 1;    &#x2F;&#x2F;盘子是否可放入苹果、桔子\nsemaphore mutex &#x3D; 1;\n\ndad()&#123;\n    while (true) &#123;\n      prepare an apple;\n      P(empty_apple); \n      P(mutex);\n      put an apple on the plate;    \n      V(mutex);\n      V(apple);               \n    &#125;\n&#125;\n\nmom()&#123;\n    while (true) &#123;\n      prepare an orange;\n      P(empty_orange);  \n      P(mutex);\n      put an orange on the plate; \n      V(mutex);\n      V(orange);\n   &#125;\n&#125;\n\ndaughter() &#123;\n    while (true) &#123;\n         P(apple);\n         P(orange);\n         P(mutex);\n         get an apple  and an orange from plate; &#x2F;&#x2F;取水果\n         V(mutex);\n         V(empty_apple); \n         V(empty_orange); \n   &#125;\n&#125;</code></pre>\n\n<p>这里的mutex不可以省略，缓冲区的大小不为1，资源信号量无法兼顾互斥信号量的工作。</p>\n<h3 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h3><p>女儿画画，爸爸、妈妈欣赏。</p>\n<p>女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画。</p>\n<p>请用信号量机制实现女儿、爸爸和妈妈之间的同步与互斥活动。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\t&#x2F;&#x2F;爸爸、妈妈是否已看过女画的新画\nsemaphore empty_dad &#x3D; 1, empty_mom &#x3D; 1;\n&#x2F;&#x2F;是否存在可供爸爸、妈妈看的新画\nsemaphore full_dad &#x3D; 0, full_mom &#x3D; 0; \n\n\ndaughter()&#123;\n    while (true) &#123;\n         P(empty_dad);  &#x2F;&#x2F;爸爸是否看过\n         P(empty_mom);  &#x2F;&#x2F;妈妈是否看过\n         draw a new picture on the whiteboard; &#x2F;&#x2F;画一幅新画\n         V(full_dad); &#x2F;&#x2F;爸爸可以看了\n         V(full_mom); &#x2F;&#x2F;妈妈可以看了\n    &#125;\n&#125;\n\ndad() &#123;\n    while (true) &#123;\n         P(full_dad);    &#x2F;&#x2F;白板上是否存在没有看过的画\n         enjoy the picture on the whiteboard; &#x2F;&#x2F;看画\n         V(empty_dad); &#x2F;&#x2F;爸爸已看过新画\n    &#125;\n&#125;\n\nmom() &#123;\n    while (true) &#123;\n       P(full_mom);  &#x2F;&#x2F;白板上是否存在没有看过的画\n       enjoy the picture on the whiteboard; &#x2F;&#x2F;看画\n       V(empty_mom);  &#x2F;&#x2F;妈妈已看过新画\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"问题5\"><a href=\"#问题5\" class=\"headerlink\" title=\"问题5\"></a>问题5</h3><p>有一座东西方向的独木桥，每次只能有一人通过，且不允许行人在桥上停留。东、西两端各有若干行人在等待过桥。请用P、V操作来实现东西两端行人过桥问题。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tsemaphore mutex &#x3D; 1; &#x2F;&#x2F;互斥信号量\n\nvoid east_west( )\n&#123;\n    while (true) &#123;\n         P(mutex); &#x2F;&#x2F;互斥其他人过桥\n         walk across the bridge from east to west;&#x2F;&#x2F;行人从东向西过桥\n         V(mutex); &#x2F;&#x2F;允许其他人过桥\n    &#125;\n&#125;\n\nvoid west_east( )\n&#123;\n    while (true) &#123;\n         P(mutex); &#x2F;&#x2F;互斥其他人过桥\n         walk across the bridge from west to east;&#x2F;&#x2F;行人从西向东过桥\n         V(mutex); &#x2F;&#x2F;允许其他人过桥\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"问题6\"><a href=\"#问题6\" class=\"headerlink\" title=\"问题6\"></a>问题6</h3><p>有一座东西方向的独木桥</p>\n<p>同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待，直到对方全部通过。 桥上没有行人过桥时，任何一端的行人均可上桥。</p>\n<p>请用P、V操作来实现东西两端人过桥问题。      </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tint countA&#x3D;0, countB&#x3D;0；\nsemaphore mutex&#x3D;1, muteA&#x3D;1, mutexB&#x3D;1;\n\nvoid east_west() &#123; \n    while (1) &#123;\n        P(mutexA);\n          countA++;\n          if (countA&#x3D;&#x3D;1) P(mutex); \n        V(mutexA);\n        walk across the bridge from east to west;\n        P(mutexA);\n          countA--;\n          if (countA&#x3D;&#x3D;0) V(mutex);\n        V(mutexA);\n    &#125;\n&#125;\n\nvoid west_east() &#123; \n    while (1) &#123;\n        P(mutexB);\n          countB++;\n          if (countB&#x3D;&#x3D;1) P(mutex); \n        V(mutexB);\n        walk across the bridge from west to east;\n        P(mutexB);\n          countB--;\n          if (countB&#x3D;&#x3D;0) V(mutex);\n        V(mutexB);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"问题7\"><a href=\"#问题7\" class=\"headerlink\" title=\"问题7\"></a>问题7</h3><p>有一座东西方向的独木桥， 同一方向的行人可连续过桥。</p>\n<p>当某一方向有行人过桥时，另一方向行人必须等待。 桥上没有行人时，任何一端的行人均可上桥。 出于安全考虑，独木桥的最大承重为4人，即同时位于桥上的行人数目不能超过4。</p>\n<p>请用P、V操作来实现东西两端人过桥问题。      </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tint countA&#x3D;0, countB&#x3D;0；\nsemaphore mutex&#x3D;1, muteA&#x3D;1, mutexB&#x3D;1,count&#x3D;4;\n\nvoid east_west() &#123; \n    while (1) &#123;\n        P(mutexA);\n          countA++;\n          if (countA&#x3D;&#x3D;1) P(mutex); \n        V(mutexA);\n        P(count);\n          walk across the bridge from east to west;\n        V(count);\n        P(mutexA);\n          countA--;\n          if (countA&#x3D;&#x3D;0) V(mutex);\n        V(mutexA);\n    &#125;\n&#125;\n\nvoid west_east() &#123; \n    while (1) &#123;\n        P(mutexB);\n          countB++;\n          if (countB&#x3D;&#x3D;1) P(mutex); \n        V(mutexB);\n        P(count);\n          walk across the bridge from west to east;\n        V(count);\n        P(mutexB);\n          countB--;\n          if (countB&#x3D;&#x3D;0) V(mutex);\n        V(mutexB);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"问题8\"><a href=\"#问题8\" class=\"headerlink\" title=\"问题8\"></a>问题8</h3><p>某寺庙有小和尚和老和尚各若干人，水缸一只，由小和尚提水入缸给老和尚饮用。水缸可容水m桶，水取自同一口水井中。水井径窄，每次仅能容一只水桶取水，水桶总数为n个。若每次提水、取水仅为1桶，试用P, V操作描述小和尚和老和尚提水、取水的活动过程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\tsemaphore mutex1&#x3D;1, mutex2&#x3D;1;\nsemaphore empty&#x3D;m, full&#x3D;0;\nsemaphore count&#x3D;n;\n\nprocess 小和尚(i) (i&#x3D;1，2，…)\n  begin\n   repeat\n     P(empty);         &#x2F;&#x2F;水缸满否?\n     P(count);         &#x2F;&#x2F;取得水桶\n     P(mutex1);        &#x2F;&#x2F;互斥从井中取水\n          从井中取水;\n     V(mutex1);\n     P(mutex2);        &#x2F;&#x2F;互斥使用水缸\n       倒水入缸;\n     V(mutex2);\n     V(count);         &#x2F;&#x2F;归还水桶\n     V(full);           &#x2F;&#x2F;多了一桶水\n  until false;\n end\n\nprocess 老和尚(取水)j(j&#x3D;1，2，…)\n   begin\n    repeat\n     P(full);           &#x2F;&#x2F;有水吗?\n     P(count);         &#x2F;&#x2F;申请水桶\n     P(mutex2);        &#x2F;&#x2F;互斥取水\n       从缸中取水;\n     V(mutex2);\n     V(count);         &#x2F;&#x2F;归还水桶\n     V(empty);        &#x2F;&#x2F;水缸中少了一桶水\n     until false;\n  end</code></pre>\n\n<h3 id=\"问题9\"><a href=\"#问题9\" class=\"headerlink\" title=\"问题9\"></a>问题9</h3><p>N个生产者进程和M个消费者进程共享大小为K的缓冲区，遵循规则如下： 进程之间必须以互斥方式访问缓冲区； 对每1条放入缓冲区的数据，所有消费者都必须接收1次； 缓冲区满时，生产者必须阻塞； 缓冲区空时，消费者必须阻塞。 请用P、V操作实现其同步过程，须说明信号量含义。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/95a03ab21fd1416a8472a8cda4462b60.png\"><img src=\"https://img-blog.csdnimg.cn/def25bd450a0456cb05b6ce4e7f68a90.png\"></p>\n<hr>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><p>Inter Process Communication: IPC 是指进程之间的信息交换</p>\n<hr>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>进程通信分为两类：</p>\n<ul>\n<li><p>低级通信：以信号量作为通信工具，交换的信息量少。</p>\n</li>\n<li><p>高级通信：操作系统所提供的一组通信命令，高效地传送大量数据。</p>\n</li>\n<li><pre><code>* 共享存储（Shared Memory）\n* 消息传递/消息队列（Message Passing/Message Queue）\n* 管道（Pipe）\n* 套接字（Socket）\n* 文件（File）\n* 信号（Signal）\n* 内存映射文件（Memory Mapped File）\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  \n\n共享存储：\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;678d37f3307048c5a88316e84047f47e.png)\n\n----\n\n## 消息传递\n\n* 数据交换以格式化的消息为单位；直接利用系统提供的一组通信命令（原语）进行通信。\n\n* &#96;&#96;&#96;\n  * 间接通信方式 （Indirect Communication）\n  \t* 中介：信箱。\n  \t* 发送进程发送给目标进程的消息存放信箱； 接收进程则从该信箱中，取出发送给自己的消息；\n  \t* 消息在信箱中安全地保存，只允许核准的用户读取。\n  \t* 系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。\n  * 直接通信方式（Direct Communication）\n  \t* 直接把消息发送给目标进程。</code></pre>\n\n</code></pre>\n</li>\n<li><p>跨节点的进程间通信</p>\n<p><code>套接字（socket） </code></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"管道（Pipe）通信\"><a href=\"#管道（Pipe）通信\" class=\"headerlink\" title=\"管道（Pipe）通信\"></a>管道（Pipe）通信</h2><p>用于连接一个读进程和一个写进程以实现他们之间通信的共享文件，又名pipe文件。</p>\n<ul>\n<li><p>无名管道（unnamed pipe）</p>\n<p>​\t<code>$ ls | grep x</code></p>\n</li>\n<li><p>命名管道（named pipe）</p>\n<p>​\t<code>$ mkfifo mypipe</code></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><p>多个进程在运行过程中因争夺资源而造成的一种僵局（Deadly- Embrace），当进程处于这种僵持状态时，若无外力作用，它们都将无法向前推进。</p>\n<hr>\n<h2 id=\"产生死锁的原因\"><a href=\"#产生死锁的原因\" class=\"headerlink\" title=\"产生死锁的原因\"></a>产生死锁的原因</h2><ul>\n<li>资源不足导致的资源竞争：多个进程所共享的资源不足，引起它们对资源的竞争而产生死锁。</li>\n<li>并发执行的顺序不当：进程运行过程中，请求和释放资源的顺序不当，而导致进程死锁。</li>\n</ul>\n<hr>\n<h2 id=\"系统模型\"><a href=\"#系统模型\" class=\"headerlink\" title=\"系统模型\"></a>系统模型</h2><ul>\n<li><p>资源（R1, R2, . . ., Rm）</p>\n<p>​\t<code>CPU, memory, I/O devices</code></p>\n</li>\n<li><p>资源Ri拥有的实例数 Wi（instance）</p>\n</li>\n<li><p>进程使用资源的方式</p>\n<ul>\n<li><code>请求（request）</code></li>\n<li><code>占用/使用（use）</code></li>\n<li><code>释放（release）</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"资源类型\"><a href=\"#资源类型\" class=\"headerlink\" title=\"资源类型\"></a>资源类型</h2><ul>\n<li><p>重用型资源（Reusable Resource）</p>\n<ul>\n<li><code>一次只能供一个进程使用，不会由于使用而耗尽</code></li>\n<li><code>例: CPU、 I/O通道、主存和辅存、 设备、文件、数据库、信号量等数据结构</code></li>\n</ul>\n</li>\n<li><p>消费型资源（Consumable Resource）</p>\n<ul>\n<li><code>可以创建并且可以销毁的资源 数目没有限制，当一个进程得到一个可消费资源后，这个资源就不再存在了</code></li>\n<li><code>例: 中断、信号、 消息、 I/O缓冲区中的信息</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"资源分配图\"><a href=\"#资源分配图\" class=\"headerlink\" title=\"资源分配图\"></a>资源分配图</h2><p>RAG: Resource-Allocation Graph</p>\n<p>进程：P &#x3D; {P1, P2, …, Pn}</p>\n<p>资源：R &#x3D; {R1, R2, …, Rm}</p>\n<p>资源请求边（request）： Pi → Rj</p>\n<p>资源分配边（assignment ）：Rj → Pi </p>\n<p><img src=\"https://img-blog.csdnimg.cn/b4d5cd2a9ba948e098e790467f713b41.png\"></p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p><img src=\"https://img-blog.csdnimg.cn/753ea20488354768a7efbd2566537ec0.png\"> 实例 <img src=\"https://img-blog.csdnimg.cn/ca9fbee7dc2a4333a32675bb69ae5d2b.png\"> 死锁</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p><img src=\"https://img-blog.csdnimg.cn/55fd53a624eb442cbef849bed0784e28.png\"> 带环但无死锁</p>\n<hr>\n<h2 id=\"死锁的充要条件\"><a href=\"#死锁的充要条件\" class=\"headerlink\" title=\"死锁的充要条件\"></a>死锁的充要条件</h2><p><img src=\"https://img-blog.csdnimg.cn/2da4dcd9ff894b1b9a1715b80031f41c.png\"><br><strong>互斥条件</strong></p>\n<p>进程对所分配到的资源进行排它性使用。如果此时还有其它进程申请该资源，则只能阻塞，直至占有该资源的进程释放。</p>\n<p><strong>占有且等待（请求和保持条件）</strong></p>\n<p>进程已经占有了至少一个资源，又提出了新的资源要求，而该资源已被其它进程占有，此时请求进程阻塞，且对已经获得的其它资源保持不放。 </p>\n<p><strong>非抢占（非剥夺）条件</strong></p>\n<p>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>\n<p><strong>循环等待条件</strong></p>\n<p>在发生死锁时，存在一个进程—资源的封闭的环形链。</p>\n<p><strong>以上四条缺一不可。</strong></p>\n<hr>\n<h2 id=\"处理死锁的基本方法\"><a href=\"#处理死锁的基本方法\" class=\"headerlink\" title=\"处理死锁的基本方法\"></a>处理死锁的基本方法</h2><p><img src=\"https://img-blog.csdnimg.cn/13900bd7779c4a73af5876a5637434bd.png\"></p>\n<h3 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h3><p>通过限制申请资源的方法来破坏产生死锁的条件（四个方面）</p>\n<p><strong>互斥条件</strong></p>\n<p>由资源的固有特性所决定，不能被破坏。</p>\n<p><strong>打破“占有和等待”</strong></p>\n<p>进程开始运行前一次性地申请全部资源，启动后不再申请。</p>\n<p>优点: 简单、易于实现、安全</p>\n<p>缺点: 无法预知所需资源的全集；进程可能被阻塞很长时间，等待资源，发生饥饿；资源严重浪费（某个资源可能只用极短时间）</p>\n<p><strong>打破“非抢占”</strong></p>\n<p>资源拥有者拒绝其它请求后释放资源，或从被申请资源拥有者处抢占</p>\n<p>适用条件：资源的状态可保存和恢复，如CPU寄存器、内存空间；不适用于打印机、磁带机</p>\n<p>缺点：实现复杂，代价大，反复申请&#x2F;释放资源，周转时间长，系统吞吐量低；undo、redo</p>\n<p><strong>打破“环路等待”</strong></p>\n<p>系统把所有资源按类型进行线性排队；所有进程对资源的请求必须严格按资源序号递增的顺序提出，保证任何时刻的资源分配图不出现环路。即：如果一个进程已经分配了R类型的资源，它接下来请求的资源只能是排在R类型之后的资源。</p>\n<p>摒弃“环路等待” 方法的问题：资源变化：资源序号要稳定； 资源浪费： 只用第一个和最后一个资源； 使用顺序和申请顺序不一致； 程序设计：考虑申请顺序，编写困难</p>\n<h3 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h3><p>不需事先破坏产生死锁的条件</p>\n<p>在系统运行过程中，对进程发出的每一个资源申请进行检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配（阻塞），否则予以分配。</p>\n<p>防止系统进入<strong>不安全状态</strong>, 从而避免发生死锁。</p>\n<p><strong>安全状态：</strong>存在安全序列的系统状态</p>\n<p><strong>安全序列</strong>：一个进程序列{P1，…，Pn}是安全的：如果对于每一个进程Pi(1≤i≤n），它尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p>\n<p><strong>安全状态时一定没有死锁</strong>（当前状态非死锁，<strong>并不保证未来</strong>）</p>\n<p><strong>死锁一定是不安全状态</strong>，但不安全状态下不一定会死锁</p>\n<p> </p>\n<p>总结</p>\n<ul>\n<li><p>优点</p>\n<p>​\t<code>比死锁预防限制少</code></p>\n<p>​\t<code>无死锁检测方法中的资源剥夺，进程重启</code></p>\n</li>\n<li><p>缺点</p>\n<p>​\t<code>必须事先声明每个进程请求的最大资源</code></p>\n<p>​\t<code>进程必须是无关的：没有任何同步要求的限制</code></p>\n<p>​\t<code>进程数量保持不变，分配的资源数目必须是固定的</code></p>\n<p>​\t<code>在占有资源时，进程不能退出</code></p>\n<p>​\t<code>保守的分配方案（设置条件严格）</code></p>\n</li>\n</ul>\n<p><strong>银行家算法</strong></p>\n<p>当用户申请资源时，系统判断如果把这些资源分出去，系统是否还处于安全状态。</p>\n<p>若是，就可以分配这些资源； 否则，暂时不分配，阻塞进程。 </p>\n<p><strong>安全性算法</strong></p>\n<ol>\n<li><p>设Work和Finish分别是长度为m和n的向量，按如下方式进行初始化:</p>\n<ul>\n<li><p>Work &#x3D; Available</p>\n</li>\n<li><p>Finish[i] &#x3D; false for i &#x3D; 1,2, …, n.</p>\n</li>\n</ul>\n</li>\n<li><p>查找这样的i使其满足:</p>\n<ul>\n<li><p>Finish[i] &#x3D; false</p>\n</li>\n<li><p>Need[i] &lt;&#x3D; Work</p>\n</li>\n<li><p>如果未找到，转第4步.</p>\n</li>\n</ul>\n</li>\n<li><p>Work &#x3D; Work + Allocation[i]; Finish[i] &#x3D; True；返回第2步</p>\n</li>\n<li><p>如果对所有的i, Finish[i]&#x3D;&#x3D;True，那么处于安全状态，否则不安全状态。</p>\n</li>\n</ol>\n<p>**资源分配算法 **</p>\n<ul>\n<li><p>Requesti为进程Pi的请求向量。如果Requesti [j] &#x3D; k 那么进程Pi 所需要的资源类型Rj的实例数量为k。当进程Pi做出资源请求时，执行：  </p>\n<p>​\t<code>若Requesti &lt;=Needi 转1.2；否则，出错退出；</code></p>\n<p>​\t<code>若Requesti &lt;=Available 转2； 否则 Pi阻塞；</code></p>\n</li>\n<li><p>假定系统可以分配给进程Pi所请求的资源，并按如下方式修改状态:</p>\n<p>​\t<code>Available = Available - Requesti;</code></p>\n<p>​\t<code>Allocationi = Allocationi + Requesti;</code></p>\n<p>​\t<code>Needi = Needi – Requesti;</code></p>\n</li>\n<li><p>系统执行安全性算法</p>\n<p>​\t<code>如果处于安全状态，那么Pi可分配到其所需资源;</code></p>\n<p>​\t<code>如果新状态不安全，那么进程Pi必须等待，并恢复到原先资源分配状态</code></p>\n</li>\n</ul>\n<p><strong>实例</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6af93956765d4c2b8657cd9e4cf9ca32.png\"><img src=\"https://img-blog.csdnimg.cn/76c6695dbb8f45e0bfd2b92d88d67fd4.png\"></p>\n<h3 id=\"死锁检测\"><a href=\"#死锁检测\" class=\"headerlink\" title=\"死锁检测\"></a>死锁检测</h3><p>如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能会出现死锁。因此，系统应该提供：用来检查系统状态是否出现死锁的检测算法、从死锁状态中恢复的方法。</p>\n<ul>\n<li><p>死锁检测</p>\n<ul>\n<li>没有任何预先限制措施</li>\n<li>资源分配时不检查系统是否会进入不安全状态，被请求的资源都被授予给进程</li>\n<li>系统可能出现死锁</li>\n<li>周期性检测是否出现死锁（执行检测算法）</li>\n</ul>\n</li>\n<li><p>检测时机</p>\n<ul>\n<li>在每个资源请求时都进行</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时检测死锁</li>\n</ul>\n</li>\n<li><p>简化资源分配图</p>\n<ul>\n<li>简化规则：若已分配和申请能满足需求，则删除边，使其成为孤立点→运行完毕后资源释放；</li>\n<li>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全简化的；反之的是不可完全简化的。</li>\n<li>死锁定理：<strong>死锁状态的充要条件：资源分配图不可完全简化</strong></li>\n</ul>\n</li>\n<li><p>死锁定理与不安全状态的关系</p>\n<ul>\n<li>死锁定理：当前请求（request）</li>\n<li>不安全状态：所有剩余请求（need）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"死锁解除\"><a href=\"#死锁解除\" class=\"headerlink\" title=\"死锁解除\"></a>死锁解除</h3><ul>\n<li><p>撤销进程</p>\n<ul>\n<li>终止所有的死锁进程</li>\n<li>一次终止一个进程直到取消死锁循环→基于某种最小代价原则</li>\n</ul>\n</li>\n<li><p>选择原则</p>\n<ul>\n<li>已消耗CPU时间最少</li>\n<li>到目前为止产生的输出量最少</li>\n<li>预计剩余的时间最长</li>\n<li>目前为止分配的资源总量最少</li>\n<li>优先级最低</li>\n</ul>\n</li>\n<li><p>资源剥夺：逐步从进程中抢占资源给其它进程，直到死锁环被打破为止 。</p>\n<ul>\n<li>选择一个牺牲品：抢占哪些资源和哪个进程，确定抢占顺序以使代价最小。</li>\n<li>饥饿：确保资源不会总是从同一个进程中被抢占</li>\n</ul>\n</li>\n<li><p>进程回退：把每个死锁进程备份到前面定义的某些检查点，并且重新启动所有进程－需要系统构造重新运行和重新启动机制</p>\n</li>\n</ul>\n<h3 id=\"死锁忽略\"><a href=\"#死锁忽略\" class=\"headerlink\" title=\"死锁忽略\"></a>死锁忽略</h3><p>通常实际中采用的方式…摆烂的成本最低。 </p>\n","feature":true,"text":"第一部分 操作系统概述目录 前言 操作系统概述 ​ 操作系统的目标与功能 ​ 操作系统的定义 ​ 目标 ​ 功能 ​ 操作系统的历史 ​ 单用户系统 ​ 简单批处理系统 ​ 多道批处理系统 ​ 分时系统 ​ 个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → …… ​...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"复习笔记","slug":"复习笔记","count":5,"path":"api/categories/复习笔记.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">第一部分   操作系统概述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">操作系统概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">操作系统的目标与功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">操作系统的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">目标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">功能</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%86%E5%8F%B2\"><span class=\"toc-text\">操作系统的历史</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">单用户系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">简单批处理系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">多道批处理系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">分时系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91-%E2%86%92-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E2%86%92-%E4%BA%92%E8%81%94%E7%BD%91%E6%97%B6%E4%BB%A3-%E2%86%92-%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%97%B6%E4%BB%A3-%E2%86%92-%E2%80%A6%E2%80%A6\"><span class=\"toc-text\">个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">实时系统</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">操作系统的基本特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">并发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">共享</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F\"><span class=\"toc-text\">虚拟</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7\"><span class=\"toc-text\">不确定性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">操作系统的体系结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A0%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">无结构操作系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">模块化系统结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B1%82%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">分层式系统结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">操作系统安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98\"><span class=\"toc-text\">内存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">信息保护和安全</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">第二部分\t进程与并发控制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80-1\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">进程基本知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">程序的顺序执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%B6%8B%E5%9B%BE\"><span class=\"toc-text\">前趋图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">程序的并发执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">并发程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">**进程的定义和特征 **</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">进程的特征和状态</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">操作系统内核</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD-1\"><span class=\"toc-text\">功能</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E8%AF%AD\"><span class=\"toc-text\">原语</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">原子操作的实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">操作系统控制结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB\"><span class=\"toc-text\">进程控制块PCB</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%A0%91%EF%BC%89\"><span class=\"toc-text\">进程组织（进程树）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">进程的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%EF%BC%88fork%E4%B8%8Eexec%E4%B8%BA%E4%B8%BB%EF%BC%89\"><span class=\"toc-text\">进程控制函数（fork与exec为主）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2\"><span class=\"toc-text\">进程的终止</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">进程切换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB\"><span class=\"toc-text\">与进程的区别和联系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">线程的优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">线程的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">线程的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">线程的分类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%AD%90%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐单处理机调度（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">调度原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">调度算法：资源分配问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%9AFCFS\"><span class=\"toc-text\">先来先服务：FCFS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%9ASPF-x2F-SJF\"><span class=\"toc-text\">短作业优先：SPF&#x2F;SJF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%9ATSRR\"><span class=\"toc-text\">时间片轮转调度：TSRR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%EF%BC%9ASRT\"><span class=\"toc-text\">最短剩余时间调度：SRT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E6%9D%83-x2F-%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">基于优先权&#x2F;优先级的调度算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">信号量</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%AD%90%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐进程并发控制：信号量的应用（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">观察者问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">图书馆问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E4%BA%A4%E8%BD%A6%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">公交车问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%AD%90%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐生产者&#x2F;消费者问题（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">例题：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E7%A4%BA\"><span class=\"toc-text\">启示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%AD%90%E8%AF%BB-x2F-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐读&#x2F;写者问题（重点）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88\"><span class=\"toc-text\">读者优先</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88\"><span class=\"toc-text\">写者优先</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%B9%B3%E4%BC%98%E5%85%88\"><span class=\"toc-text\">公平优先</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%AD%90%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐理发师问题（重点）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%AD%90%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">⭐哲学家问题（重点）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">重点知识点回顾</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E7%BB%83%E4%B9%A0%E9%A2%98\"><span class=\"toc-text\">进程并发控制：练习题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%981\"><span class=\"toc-text\">问题1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%982\"><span class=\"toc-text\">问题2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%983\"><span class=\"toc-text\">问题3</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%984\"><span class=\"toc-text\">问题4</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%985\"><span class=\"toc-text\">问题5</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%986\"><span class=\"toc-text\">问题6</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%987\"><span class=\"toc-text\">问题7</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%988\"><span class=\"toc-text\">问题8</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%989\"><span class=\"toc-text\">问题9</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程间通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">管道（Pipe）通信</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">产生死锁的原因</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">系统模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">资源类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE\"><span class=\"toc-text\">资源分配图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">实例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">死锁的充要条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">处理死锁的基本方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2\"><span class=\"toc-text\">死锁预防</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D\"><span class=\"toc-text\">死锁避免</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">死锁检测</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4\"><span class=\"toc-text\">死锁解除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E5%BF%BD%E7%95%A5\"><span class=\"toc-text\">死锁忽略</span></a></li></ol></li></ol></li></ol>","author":{"name":"涛","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic_source/44/ff/3d/44ff3d6bd2819d524facfcc33205d4cd.jpg","link":"/","description":"一位Computer Science的学生","socials":{"github":"https://github.com/Blizzard-cyber","twitter":"","stackoverflow":"https://stackoverflow.com/users/17709435/blizzard","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wan-meng-ci-yi-xi","csdn":"https://blog.csdn.net/qq_55751352?spm=1010.2135.3001.5343","juejin":"https://juejin.cn/user/1289054417332301","customs":{}}},"mapped":true,"prev_post":{"title":"计算机操作系统复习笔记（二）","uid":"0a3e10a3d062b222add6594e3cd0bf1b","slug":"OSreview2","date":"2023-03-16T14:27:01.000Z","updated":"2023-03-16T14:47:03.430Z","comments":true,"path":"api/articles/OSreview2.json","keywords":null,"cover":"https://picx.zhimg.com/v2-ab4d2e1f84d9a3d9cd65d7894164bcea_1440w.jpg?source=172ae18b","text":"第三部分 存储器管理目录 前言 存储器管理 ​ 概述 ​ 存储管理 ​ 存储系统的结构 ​ 程序的诞生 ​ 空间分类 ​ 地址映射 ​ 程序链接的方式 ​ 静态链接 ​ 装入时动态链接 ​ 运行时动态链接 ​ 程序装入的方式 ​ 程序装入的两类三种方法 ​ 绝对装入 ​ 静态重定...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"复习笔记","slug":"复习笔记","count":5,"path":"api/categories/复习笔记.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}],"author":{"name":"涛","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic_source/44/ff/3d/44ff3d6bd2819d524facfcc33205d4cd.jpg","link":"/","description":"一位Computer Science的学生","socials":{"github":"https://github.com/Blizzard-cyber","twitter":"","stackoverflow":"https://stackoverflow.com/users/17709435/blizzard","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wan-meng-ci-yi-xi","csdn":"https://blog.csdn.net/qq_55751352?spm=1010.2135.3001.5343","juejin":"https://juejin.cn/user/1289054417332301","customs":{}}},"feature":true},"next_post":{"title":"计算机操作系统复习笔记（三）","uid":"7da07456a3be614155ce9d5c6f12f8ad","slug":"OSreview3","date":"2023-03-16T14:27:01.000Z","updated":"2023-03-16T14:47:42.687Z","comments":true,"path":"api/articles/OSreview3.json","keywords":null,"cover":"https://picx.zhimg.com/v2-ab4d2e1f84d9a3d9cd65d7894164bcea_1440w.jpg?source=172ae18b","text":"目录 前言 文件管理：基础 ​ 基本概念 ​ 文件 ​ 文件系统 ​ 文件系统的实现模型 ​ 文件的组成 ​ 文件名 ​ 文件分类 ​ 文件结构 ​ 逻辑结构 ​ 物理结构 ​ 练习题 文件管理：目录 ​ 文件控制块FCB ​ FCB：File Control Block ​ F...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"复习笔记","slug":"复习笔记","count":5,"path":"api/categories/复习笔记.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}],"author":{"name":"涛","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic_source/44/ff/3d/44ff3d6bd2819d524facfcc33205d4cd.jpg","link":"/","description":"一位Computer Science的学生","socials":{"github":"https://github.com/Blizzard-cyber","twitter":"","stackoverflow":"https://stackoverflow.com/users/17709435/blizzard","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wan-meng-ci-yi-xi","csdn":"https://blog.csdn.net/qq_55751352?spm=1010.2135.3001.5343","juejin":"https://juejin.cn/user/1289054417332301","customs":{}}},"feature":true}}