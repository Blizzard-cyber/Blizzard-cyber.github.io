{"title":"计算机操作系统复习笔记（二）","uid":"0a3e10a3d062b222add6594e3cd0bf1b","slug":"OSreview2","date":"2023-03-16T14:27:01.000Z","updated":"2023-03-16T14:47:03.430Z","comments":true,"path":"api/articles/OSreview2.json","keywords":null,"cover":"https://picx.zhimg.com/v2-ab4d2e1f84d9a3d9cd65d7894164bcea_1440w.jpg?source=172ae18b","content":"<h1 id=\"第三部分-存储器管理\"><a href=\"#第三部分-存储器管理\" class=\"headerlink\" title=\"第三部分   存储器管理\"></a>第三部分   存储器管理</h1><p><strong>目录</strong></p>\n<p><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p><a href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86\">存储器管理</a></p>\n<p>​\t\t<a href=\"#%E6%A6%82%E8%BF%B0\">概述</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\">存储管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84\">存储系统的结构</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%9E%E7%94%9F\">程序的诞生</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A9%BA%E9%97%B4%E5%88%86%E7%B1%BB\">空间分类</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\">地址映射</a></p>\n<p>​\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F\">程序链接的方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5\">静态链接</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\">装入时动态链接</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\">运行时动态链接</a></p>\n<p>​\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F\">程序装入的方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%A4%E7%B1%BB%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95\">程序装入的两类三种方法</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5\">绝对装入</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D\">静态重定位</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%88%9A\">动态重定位√</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%B3%E9%94%AE%E7%82%B9\">关键点</a></p>\n<p><a href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D\">存储器管理：连续分配</a></p>\n<p>​\t\t<a href=\"#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D\">单一连续分配</a></p>\n<p>​\t\t<a href=\"#%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86\">分区管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\">固定分区分配</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%89%5D\">        </a><a href=\"#%5B%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%89%5D\">[放置算法（分配算法）]</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\">动态分区分配</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%B8%B8%E7%94%A8%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95\">常用分区分配算法</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">        </a><a href=\"#%5B%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">[最先适配算法]  </a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">        </a><a href=\"#%5B%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">[循环最先适配算法]  </a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">        </a><a href=\"#%5B%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D%C2%A0%C2%A0\">[最佳适配算法]  </a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E6%9C%80%E5%9D%8F%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D\">        </a><a href=\"#%5B%E6%9C%80%E5%9D%8F%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95%5D\">[最坏适配算法]</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%5D\">        </a><a href=\"#%5B%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%5D\">[伙伴系统]</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%EF%BC%9A%E7%B4%A7%E5%87%91/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%5D\">        </a><a href=\"#%5B%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%EF%BC%9A%E7%B4%A7%E5%87%91/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%5D\">[碎片问题：紧凑&#x2F;动态重定位]</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%C2%A0\">动态分区分配算法总结 </a></p>\n<p>​\t\t<a href=\"#%E8%A6%86%E7%9B%96\">覆盖</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AE%9E%E4%BE%8B\">实例</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BC%BA%E7%82%B9\">缺点</a></p>\n<p>​\t\t<a href=\"#%E4%BA%A4%E6%8D%A2/%E5%AF%B9%E6%8D%A2\">交换&#x2F;对换</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BA%A4%E6%8D%A2%E7%B2%92%E5%BA%A6%C2%A0\">交换粒度 </a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BC%98%E7%BC%BA%E7%82%B9\">优缺点</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%A6%86%E7%9B%96%E7%9A%84%E6%AF%94%E8%BE%83\">交换与覆盖的比较</a></p>\n<p><a href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A6%BB%E6%95%A3%E5%88%86%E9%85%8D\">存储器管理：离散分配</a></p>\n<p>​\t\t<a href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\">页式存储管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%5D\">        </a><a href=\"#%5B%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%5D\">[分页逻辑地址结构]</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%5D\">        </a><a href=\"#%5B%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%5D\">[基本页式存储管理]</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%5D\">        </a><a href=\"#%5B%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%5D\">[地址变换机构]</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D\">页式存储中的重定位</a></p>\n<p>​\t\t\t\t<a href=\"#%E2%AD%90%E9%87%8D%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A\">⭐重点计算方法：</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84\">具有快表的地址变换机构</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E5%BF%AB%E8%A1%A8%5D\">        </a><a href=\"#%5B%E5%BF%AB%E8%A1%A8%5D\">[快表]</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%A1%E7%AE%97%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4\">计算页表存储空间</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8\">两级和多级页表</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E4%BE%8B%E9%A2%98%5D\">        </a><a href=\"#%5B%E4%BE%8B%E9%A2%98%5D\">[例题]</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8\">反置页表</a></p>\n<p>​\t\t\t\t<a href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93\">页式存储小结</a></p>\n<p>​\t\t<a href=\"#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\">段式存储管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t\t\t<a href=\"#%5B%E8%AF%84%E4%BB%B7%5D\">        </a><a href=\"#%5B%E8%AF%84%E4%BB%B7%5D\">[评价]</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\">段式地址变换</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%88%86%E9%85%8D%EF%BC%88%E7%B1%BB%E4%BC%BC%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%EF%BC%89\">分配（类似动态分区）</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E6%AF%94%E8%BE%83\">与分页的比较</a></p>\n<p>​\t\t<a href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\">段页式存储管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\">基本思想</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\">地址映射</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\">地址变换</a></p>\n<p>​\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E5%AE%9E%E4%BE%8B\">地址变换实例</a></p>\n<p><a href=\"#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%C2%A0\">虚拟存储器 </a></p>\n<p>​\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86\">局部性原理</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\">虚拟内存</a></p>\n<p>​\t\t<a href=\"#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F\">虚拟页式</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5\">请求分页</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5\">内存分配、置换策略</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86\">缺页中断处理</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8/%E6%8A%96%E5%8A%A8\">系统颠簸&#x2F;抖动</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%B7%A5%E4%BD%9C%E9%9B%86\">工作集</a></p>\n<p>​\t\t<a href=\"#%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2/%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%C2%A0\">页面替换&#x2F;置换算法 </a></p>\n<p>​\t\t\t\t<a href=\"#%E6%9C%80%E4%BD%B3%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89\">最佳算法（OPT）</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95(First%20in%20First%20Out%EF%BC%8CFIFO)\">先进先出算法(First in First Out，FIFO)</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95(LRU,%20Least%20Recently%20Used)\">最近最久未使用算法(LRU, Least Recently Used)</a></p>\n<p>​\t\t\t\t<a href=\"#Clock%E7%AE%97%E6%B3%95\">Clock算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%94%B9%E8%BF%9BClock%E7%AE%97%E6%B3%95\">改进Clock算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%B6%E4%BB%96%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\">其他置换算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BB%83%E4%B9%A0%E9%A2%98\">练习题</a></p>\n<p>​\t\t\t\t<a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">编辑</a></p>\n<p>​\t\t<a href=\"#%E8%99%9A%E6%8B%9F%E6%AE%B5%E5%BC%8F\">虚拟段式</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5\">请求分段</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B\">地址变换过程</a></p>\n<p>​\t\t<a href=\"#%E8%99%9A%E6%8B%9F%E6%AE%B5%E9%A1%B5%E5%BC%8F\">虚拟段页式</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%88%86%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%C2%A0\">分段的共享与保护 </a></p>\n<p><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本复习笔记基于<a href=\"https://so.csdn.net/so/search?q=%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6&spm=1001.2101.3001.7020\" title=\"电子科技大学\">电子科技大学</a>计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>\n<ul>\n<li><strong>CM1****：</strong>操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>\n<li><strong>CM2****：</strong>进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>\n<li><strong>CM3****：</strong>内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>\n<li><strong>CM4****：</strong>设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>\n<li><strong>CM5****：</strong>文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>\n</ul>\n<p>本节要点在CM3，大致内容如下：</p>\n<p>第三章 存储器管理（14 学时，多媒体课件结合板书面授）CM3</p>\n<p>1、主要内容<br>操作系统存储管理的需求分析；现代计算机系统的多级存储体系；存储划分技术；分区、动态分区分配算法；伙伴系统；分页&#x2F;分段存储管理；段页式存储管理技术。对换技术。虚拟存储器的基本概念，请求分页存储管理，请求分段存储管理，虚拟存储的软件策略：驻留集管理、页面获取、页面放置、页面置换算法、负载控制。<br>2、应达到的要求</p>\n<p>记忆：多级存储体系结构、程序的装入和链接。<br>理解：存储器管理相关技术、虚拟存储器的基本概念。</p>\n<p>应用：重定位与地址转换、分区存储管理、动态分区分配算法、交换技术、分页存储管理、各种页面置换算法、分段存储管理。</p>\n<p>分析：段页式存储管理、虚拟存储管理技术。</p>\n<p>本节涉及到4个PPT，分四个大块叙述。</p>\n<hr>\n<h1 id=\"存储器管理\"><a href=\"#存储器管理\" class=\"headerlink\" title=\"存储器管理\"></a>存储器管理</h1><hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"存储管理\"><a href=\"#存储管理\" class=\"headerlink\" title=\"存储管理\"></a>存储管理</h3><p>定义</p>\n<ul>\n<li>主要是指对内存储器的管理</li>\n<li>在多道程序环境之中，多个作业需共享内存资源，内存紧张的问题依然突出</li>\n<li>存储管理是操作系统的重要组成部分，能否合理有效地利用内存在很大程度上影响着整个计算机的性能。</li>\n</ul>\n<p>主要目的</p>\n<ul>\n<li>提高资源的利用率，尽量满足多个用户对内存的要求；</li>\n<li>方便用户使用内存，不必考虑作业具体放在哪块区域。</li>\n</ul>\n<p>应实现的主要功能</p>\n<ul>\n<li>分配和回收</li>\n<li>共享</li>\n<li>保护</li>\n<li>扩充</li>\n</ul>\n<h3 id=\"存储系统的结构\"><a href=\"#存储系统的结构\" class=\"headerlink\" title=\"存储系统的结构\"></a>存储系统的结构</h3><p><img src=\"https://img-blog.csdnimg.cn/e1466dffbfee4d45b8b3ebc6744aedbb.png\"></p>\n<h3 id=\"程序的诞生\"><a href=\"#程序的诞生\" class=\"headerlink\" title=\"程序的诞生\"></a>程序的诞生</h3><p>**从源代码 → 可以在内存中运行的程序 **</p>\n<ul>\n<li><p>编译</p>\n<p>​\t<code>由编译程序（Compiler）将用户源代码编译成若个目标模块</code></p>\n</li>\n<li><p>链接</p>\n<p>​\t<code>由链接程序（Linker）将目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块</code></p>\n</li>\n<li><p>装入</p>\n<p>​\t<code>由装入程序（Loader）将装入模块装入内存。</code></p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/1214694c57c1433fbcdd4a74f3e93043.png\"></p>\n<p> </p>\n<p>C语言的过程：预处理、编译、汇编、链接、加载</p>\n<h3 id=\"空间分类\"><a href=\"#空间分类\" class=\"headerlink\" title=\"空间分类\"></a>空间分类</h3><p><strong>名空间：代码里的变量名（个人理解）</strong></p>\n<ul>\n<li>用汇编语言或高级语言编写程序时，用符号名来访问某一单元。</li>\n<li>程序中由符号名组成的程序空间称为符号名空间，简称名空间。</li>\n</ul>\n<p><strong>逻辑空间：汇编时分配的地址（个人理解）</strong></p>\n<ul>\n<li>源程序经过编译形成目标程序，每个目标程序都以0为基址顺序进行编址，原来用符号名访问的单元用具体的数据——单元号取代。</li>\n<li>这样生成的目标程序占据一定的地址空间，称为逻辑地址空间，简称逻辑空间。</li>\n<li>在逻辑空间中每条指令的地址和指令中要访问的操作数地址统称为逻辑地址。</li>\n</ul>\n<p><strong>内存空间（物理空间）：加载入内存运行时的实际地址（个人理解）</strong></p>\n<ul>\n<li><p>内存由若干存储单元组成，每个存储单元有一个编号，这种编号可惟一标识一个存储单元，称为内存地址（或物理地址）。</p>\n</li>\n<li><p>内存地址的集合称为内存地址空间（或物理地址空间），简称内存空间（或物理空间）。</p>\n</li>\n<li><p>内存空间编号示例：</p>\n<p>​\t<code>一维线性空间，编址顺序为0，1，2，3，…… n-1，n的大小由实际组成存储器的存储单元个数决定。 比如，64K内存的空间编号为0，1，2，3，……65535。</code></p>\n<p>​\t<code>（64K=2^6/*2^10=2^16；空间地址为[0, 2^16-1]=[0, 65535]）</code></p>\n</li>\n</ul>\n<p><strong>空间的关系</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6b299368188b402a9735692016b1a873.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/80f8314e7247447dbd0ad34854ee5bba.png\"></p>\n<h3 id=\"地址映射\"><a href=\"#地址映射\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h3><ul>\n<li>将逻辑地址转换为运行时机器直接寻址的物理地址。<ul>\n<li>当程序装入内存时，操作系统要为该程序分配具体的内存空间。</li>\n<li>由于程序的逻辑地址与内存物理地址未必一致，CPU执行指令按物理地址进行的，要进行地址转换。</li>\n<li>重定位(relocation)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/f62576379e0143b993cdc497189351cd.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d4c5f6c1d2fe4fd5a37331507ec527ee.png\"></p>\n<hr>\n<h2 id=\"程序链接的方式\"><a href=\"#程序链接的方式\" class=\"headerlink\" title=\"程序链接的方式\"></a>程序链接的方式</h2><ul>\n<li>源程序经过编译后，可得到一组目标模块，再利用链接程序将目标模块链接形成装入模块：模块拼接</li>\n<li>根据链接时机不同，链接分为三种：<ul>\n<li>静态链接(Static Linking)</li>\n<li>动态链接(Dynamic Linking)<ul>\n<li>装入时动态链接(Load-time Dynamic Linking)</li>\n<li>运行时动态链接(Runtime Dynamic Linking)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"静态链接\"><a href=\"#静态链接\" class=\"headerlink\" title=\"静态链接\"></a>静态链接</h3><ul>\n<li>在(编译)链接阶段(程序运行之前)，将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。<ul>\n<li>相对地址的修改</li>\n<li>变换外部调用符号</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/b77c9ee6b5074078befcdbf7dce9f5e4.png\"></p>\n<p>个人理解：提前（静态）装入不需要额外的算力，装入后程序运行稳定</p>\n<h3 id=\"装入时动态链接\"><a href=\"#装入时动态链接\" class=\"headerlink\" title=\"装入时动态链接\"></a>装入时动态链接</h3><ul>\n<li>目标模块在装入内存时，采用边装入边链接的链接方式，装入后不再链接。<ul>\n<li>各目标模块分开存放，便于修改和更新。</li>\n<li>便于目标模块的共享<ul>\n<li>静态链接：每个装入模块都含有其目标模块的拷贝，无法实现对目标模块的共享。</li>\n<li>装入时动态链接：OS可将一个目标模块链接到多个装入模块上，实现多个应用程序对该模块的共享。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>个人理解：装入再装可以同时给多个装，达到共享、便于修改的目的</p>\n<h3 id=\"运行时动态链接\"><a href=\"#运行时动态链接\" class=\"headerlink\" title=\"运行时动态链接\"></a>运行时动态链接</h3><ul>\n<li><p>在程序执行中需要该目标模块时，由OS找到该模块，将其装入内存，并把它链接到调用者模块上。</p>\n</li>\n<li><p>执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。</p>\n<p>​\t<code>加快程序的装入</code></p>\n<p>​\t<code>节省内存空间</code></p>\n<p>​\t<code>共享</code></p>\n</li>\n</ul>\n<p>个人理解：运行再装可以灵活选自己需要的装入，节约内存，加快运行速度，还能共享模块</p>\n<hr>\n<h2 id=\"程序装入的方式\"><a href=\"#程序装入的方式\" class=\"headerlink\" title=\"程序装入的方式\"></a>程序装入的方式</h2><p>地址重定位：模块载入位置（可能伴随链接）</p>\n<h3 id=\"程序装入的两类三种方法\"><a href=\"#程序装入的两类三种方法\" class=\"headerlink\" title=\"程序装入的两类三种方法\"></a>程序装入的两类三种方法</h3><ul>\n<li><p>绝对装入</p>\n<p><code>编译时完成</code></p>\n</li>\n<li><p>可重定位装入</p>\n<p><code>加载时执行，静态地址重定位</code></p>\n<p><code>运行时执行，动态地址重定位</code></p>\n</li>\n</ul>\n<h3 id=\"绝对装入\"><a href=\"#绝对装入\" class=\"headerlink\" title=\"绝对装入\"></a>绝对装入</h3><ul>\n<li>固定地址重定位，编译时知道进程在内存中的驻留地址，生成绝对代码，即在可执行文件中记录内存地址，装入时直接定位在该内存地址。</li>\n<li>程序地址空间和内存地址空间一一对应</li>\n<li>如果开始地址发生变化，必须重新编译代码</li>\n<li>优点：装入过程简单</li>\n<li>缺点：不灵活，不适于多道程序系统</li>\n</ul>\n<h3 id=\"静态重定位\"><a href=\"#静态重定位\" class=\"headerlink\" title=\"静态重定位\"></a>静态重定位</h3><ul>\n<li><p>目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成物理内存地址。</p>\n</li>\n<li><p>当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换。</p>\n</li>\n<li><p>优点</p>\n<p>​\t<code>易实现，无需硬件支持</code></p>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><code>程序重定位后就不能移动，因而不能重新分配内存，不利于内存的有效利用。</code></li>\n<li><code>程序在存储空间中只能连续分配，不能分布在内存的不同区域。</code></li>\n<li><code>难于共享</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态重定位√\"><a href=\"#动态重定位√\" class=\"headerlink\" title=\"动态重定位√\"></a>动态重定位√</h3><ul>\n<li><p>程序装入内存时，不修改逻辑地址，在访问物理内存之前，再实时地将逻辑地址转换成物理地址。</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li><code>程序不必连续存放在内存中，可分散存储，可移动；</code></li>\n<li><code>便于共享；</code></li>\n<li><code>有利于紧缩、碎片问题的解决。</code></li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><code>需要硬件支持，实现存储管理的算法比较复杂。</code></li>\n<li><code>主流方式</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h3><p>绝对装入和静态重定位</p>\n<ul>\n<li>符号解析 + 地址重定位：紧耦合</li>\n</ul>\n<p>动态重定位</p>\n<ul>\n<li>符号解析→地址重定位：松耦合</li>\n<li>链接和装载动作的交织</li>\n</ul>\n<p> </p>\n<hr>\n<h1 id=\"存储器管理：连续分配\"><a href=\"#存储器管理：连续分配\" class=\"headerlink\" title=\"存储器管理：连续分配\"></a>存储器管理：连续分配</h1><p>存储器管理分为三大方式：连续分配、离散分配、虚拟存储器。</p>\n<hr>\n<h2 id=\"单一连续分配\"><a href=\"#单一连续分配\" class=\"headerlink\" title=\"单一连续分配\"></a>单一连续分配</h2><p>基本思想</p>\n<ul>\n<li>整个内存空间分成系统区和用户区，系统区给操作系统使用，用户区给用户使用。</li>\n<li>用户区分配给一个进程</li>\n</ul>\n<p>适用场合</p>\n<ul>\n<li>最简单，适用于单用户、单任务OS</li>\n</ul>\n<p>优点</p>\n<ul>\n<li>易于管理</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>对内存空间需求少的程序，造成内存浪费；</li>\n<li>程序全部装入，很少使用的程序部分也占用内存。</li>\n</ul>\n<hr>\n<h2 id=\"分区管理\"><a href=\"#分区管理\" class=\"headerlink\" title=\"分区管理\"></a>分区管理</h2><p>基本原理</p>\n<ul>\n<li>把内存分为一些大小相等或不等的分区；</li>\n<li>每个应用进程占用一个分区，操作系统占用一个分区。</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>适用于多道程序系统和分时系统</li>\n</ul>\n<p>问题</p>\n<ul>\n<li>内部碎片：占用分区之内未被利用的空间</li>\n<li>外部碎片：占用分区之间难以利用的空闲分区</li>\n<li>难以进行内存分区的共享。</li>\n</ul>\n<h3 id=\"固定分区分配\"><a href=\"#固定分区分配\" class=\"headerlink\" title=\"固定分区分配\"></a>固定分区分配</h3><ul>\n<li><p>把内存分为大小相等或不等的分区(partition)</p>\n</li>\n<li><p>分区的划分一般由系统管理员或操作系统决定，一旦划定，在整个执行过程中不变</p>\n</li>\n<li><p>特点</p>\n<p><code>适用于多道程序系统和分时系统</code></p>\n<p><code>支持多个程序并发执行</code></p>\n</li>\n<li><p>问题</p>\n<p><code>难以进行内存分区的共享</code></p>\n<p><code>碎片</code><br><img src=\"https://img-blog.csdnimg.cn/c61c050e8cef4dd5b47307eb380e3b13.png\"> 等大小分区和不等大小分区</p>\n</li>\n</ul>\n<h3 id=\"放置算法（分配算法）\"><a href=\"#放置算法（分配算法）\" class=\"headerlink\" title=\"[放置算法（分配算法）]\"></a>[放置算法（分配算法）]</h3><p>当一个进程装入或换入主存中时，如果存储器中有多个足够大的空闲分区，放置算法确定分配哪个自由块。</p>\n<ul>\n<li><p>等大小分区</p>\n<ul>\n<li><code>只要有一个可用分区，进程就可以装入该分区</code></li>\n<li><code>如果所有分区都被占满了，须换出一个进程</code></li>\n<li><code>一个程序可能太大而不能放到一个分区中</code></li>\n</ul>\n</li>\n<li><p>不等大小分区</p>\n<ul>\n<li><p>方法1：每个分区一个调度队列，将每个进程指定到适应它的最小分区。</p>\n<ul>\n<li>内部碎片最小</li>\n<li>缺点：一段时间没有大尺寸程序到来，<strong>小程序排队，大空间闲置。</strong></li>\n</ul>\n</li>\n<li><p>方法2：所有进程一个队列。</p>\n<ul>\n<li>当需要把一个进程装入主存时，选择可以保存该进程的最小的可用分区。</li>\n<li>如果所有分区都已被占据，须进行交换。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>比单一连续分配方法，内存利用率提高了</li>\n<li>可以支持多道程序</li>\n<li>实现简单</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>分区的数目在系统生成时确定，限制了系统中活跃进程的数目</li>\n<li>小作业的内部碎片可能比较大</li>\n<li>作业须预先能够估计要占用的内存空间</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/812baaf2205548e6bfb550e79a1164eb.png\"></p>\n<h3 id=\"动态分区分配\"><a href=\"#动态分区分配\" class=\"headerlink\" title=\"动态分区分配\"></a>动态分区分配</h3><p>在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。</p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>没有内部碎片</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>外部碎片</li>\n</ul>\n</li>\n<li><p>分区分配算法</p>\n<ul>\n<li>寻找空闲分区，需大等于程序的要求。</li>\n<li>若大于要求，则将该分区进行分割，分别标记为“占用”和 “空闲”。</li>\n</ul>\n</li>\n<li><p>分区释放算法</p>\n<ul>\n<li>将相邻的空闲分区合并成一个空闲分区。</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现了主存共享，有助于多道程序设计；</li>\n<li>主存利用率比固定分区高；</li>\n<li>实现存储保护的措施比较简单。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>外部碎片→ 主存利用率低；</li>\n<li>一个作业执行前必须全部装入主存。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用分区分配算法\"><a href=\"#常用分区分配算法\" class=\"headerlink\" title=\"常用分区分配算法\"></a>常用分区分配算法</h3><ul>\n<li>最先适配算法  </li>\n<li>循环最先适配算法  </li>\n<li>最佳适配算法  </li>\n<li>最坏适配算法</li>\n</ul>\n<h3 id=\"最先适配算法\"><a href=\"#最先适配算法\" class=\"headerlink\" title=\"[最先适配算法]\"></a>[最先适配算法]</h3><ul>\n<li><p>算法思想</p>\n<ul>\n<li>按分区地址排序，从头查找，找到符合要求的第一个分区。</li>\n</ul>\n</li>\n<li><p>算法实质</p>\n<ul>\n<li>尽可能利用存储区低地址空闲区，尽量在高地址部分保存较大空闲区，以便一旦有分配大空闲区要求时，容易得到满足。</li>\n<li><strong>空闲区按地址顺序组织</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/0fdc4bd971d84f6992d14835a5f5c31c.png\"></p>\n<ul>\n<li><p>优点</p>\n<p><code>分配简单，合并相邻空闲区也比较容易</code></p>\n</li>\n<li><p>缺点</p>\n<p><code>查找总是从表首开始，前面空闲区被分割的很小时，满足分配要求的可能性较小，**查找次数较多**。  </code></p>\n</li>\n<li><p>解决方法</p>\n<p><code>对最先适配法稍加改进 → 循环最先适配法。 </code></p>\n</li>\n</ul>\n<h3 id=\"循环最先适配算法\"><a href=\"#循环最先适配算法\" class=\"headerlink\" title=\"[循环最先适配算法]\"></a>[循环最先适配算法]</h3><ul>\n<li><p>算法思想</p>\n<p><code>按分区先后次序，**从上次分配的分区起查找**（到最后分区时再回到开头），找到符合要求的第一个分区</code></p>\n</li>\n<li><p>特点</p>\n<p>​\t<code>算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。</code></p>\n<p>​\t<code>空闲区按顺序组织</code></p>\n</li>\n</ul>\n<h3 id=\"最佳适配算法\"><a href=\"#最佳适配算法\" class=\"headerlink\" title=\"[最佳适配算法]\"></a>[最佳适配算法]</h3><ul>\n<li><p>算法思想</p>\n<p>​\t<code>在所有大等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。</code></p>\n</li>\n<li><p>算法实现</p>\n<p><code>空闲区从小到大顺序组织</code></p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/f5bd8a3b4aff4cdcbaaea93a266ed6f5.png\"></p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>较大的空闲分区可以被保留</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>空闲区按大小而不是按地址顺序排列，因此释放时，<strong>要在整个链表上搜索地址相邻的空闲区</strong>，合并后，插入到合适的位置。</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"最坏适配算法\"><a href=\"#最坏适配算法\" class=\"headerlink\" title=\"[最坏适配算法]\"></a>[最坏适配算法]</h3><ul>\n<li><p>算法思想</p>\n<ul>\n<li>分区时取所有空闲区中最大的一块，必要时拆分形成2个块，一个选用，一个形成新空闲块。</li>\n</ul>\n</li>\n<li><p>算法实现</p>\n<ul>\n<li><strong>空闲区按由大到小排序</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/afec45afddcc4c5e83e1bf0ad39f6c9e.png\"></p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>分配时，只需查找一次，就可成功，分配算法很快。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>最后剩余分区会越来越小，无法运行大程序</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"伙伴系统\"><a href=\"#伙伴系统\" class=\"headerlink\" title=\"[伙伴系统]\"></a>[伙伴系统]</h3><ul>\n<li>按照页面组织为块（2的k次幂个页面）</li>\n<li>申请时对半拆分，直到能够容纳申请量，空闲的放入新队列</li>\n<li>释放回收时合并：尺寸相同</li>\n<li>速度快，但利用率不高</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8aa86e4873454098665832798f2ecc.png\"></p>\n<h3 id=\"碎片问题：紧凑-x2F-动态重定位\"><a href=\"#碎片问题：紧凑-x2F-动态重定位\" class=\"headerlink\" title=\"[碎片问题：紧凑&#x2F;动态重定位]\"></a>[碎片问题：紧凑&#x2F;动态重定位]</h3><ul>\n<li><p>碎片问题</p>\n<ul>\n<li>经过一段时间分配、回收后，内存中存在很多很小的空闲块。</li>\n<li>每一个都很小，不足以满足分配要求；</li>\n<li>但其总和满足分配要求→存储资源浪费。</li>\n</ul>\n</li>\n<li><p>解决方法</p>\n<ul>\n<li><p>紧凑技术</p>\n<ul>\n<li>在内存移动程序，将所有小的空闲区合并为大空闲区域</li>\n<li>系统开销大</li>\n</ul>\n</li>\n<li><p>离散分配方式</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c9fb807f720d475eaea15fec2aec17fd.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/acdaad78fc9e4e2e998181507200996e.png\"></p>\n<h3 id=\"动态分区分配算法总结\"><a href=\"#动态分区分配算法总结\" class=\"headerlink\" title=\"动态分区分配算法总结\"></a>动态分区分配算法总结</h3><p><img src=\"https://img-blog.csdnimg.cn/da630c33ee714fd4920ea13b4ed5d4a0.png\"></p>\n<hr>\n<h2 id=\"覆盖\"><a href=\"#覆盖\" class=\"headerlink\" title=\"覆盖\"></a>覆盖</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>一个程序的几个代码段或数据段，按照时间先后占用公共的内存空间<ul>\n<li>将程序的必要部分代码和数据常驻内存；</li>\n<li>可选部分在独立模块中，平时存放在外存中（覆盖文件），需要时才装入到内存；</li>\n<li><strong>不存在调用关系的模块</strong>不必同时装入到内存，可相互覆盖。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p><img src=\"https://img-blog.csdnimg.cn/1eb5bec2f2244775b6b5a26802b348bf.png\"></p>\n<p>注：<strong>不存在调用关系的模块才可以相互覆盖！</strong></p>\n<p>覆盖不需要OS提供特殊的支持，但程序员必须适当地设计和编写覆盖结构。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>编程时必须划分程序模块和确定程序模块之间的覆盖关系 → 增加编程复杂度。</li>\n<li>从外存装入覆盖文件，<strong>以时间换空间</strong>。</li>\n</ul>\n<hr>\n<h2 id=\"交换-x2F-对换\"><a href=\"#交换-x2F-对换\" class=\"headerlink\" title=\"交换&#x2F;对换\"></a>交换&#x2F;对换</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>多个程序并发执行：</p>\n<p>将暂时不能执行的程序换出到外存中，从而获得空闲内存空间来装入新程序；</p>\n<p>或读入保存在外存中而目前到达就绪状态的进程到内存中。</p>\n<h3 id=\"交换粒度\"><a href=\"#交换粒度\" class=\"headerlink\" title=\"交换粒度\"></a>交换粒度</h3><ul>\n<li><p>整体交换</p>\n<ul>\n<li>也称为进程交换，交换是以整个进程为单位</li>\n</ul>\n</li>\n<li><p>部分交换</p>\n<ul>\n<li>也称为页面交换、分段交换，是分页、分段交换的基础，目的是为了支持虚拟存储系统</li>\n</ul>\n</li>\n<li><p>对换空间的管理</p>\n<ul>\n<li>对换区一般采用连续分配</li>\n<li>对换区比普通文件区侧重于对换速度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li><p>优点</p>\n<ul>\n<li>增加并发程序数量，并给用户提供适当的响应时间；</li>\n<li>编写程序时不影响程序结构</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>换入和换出的控制增加处理机开销</li>\n<li>时间换空间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换与覆盖的比较\"><a href=\"#交换与覆盖的比较\" class=\"headerlink\" title=\"交换与覆盖的比较\"></a>交换与覆盖的比较</h3><p>覆盖技术主要用在早期的操作系统中；</p>\n<p>交换技术被广泛用于分时系统中，导致了虚存技术的出现；</p>\n<p>覆盖发生在无调用关系程序段之间；</p>\n<p>交换技术对程序段之间的逻辑关系无要求；</p>\n<p>交换发生在进程或作业之间；</p>\n<p>覆盖发生在同一进程或作业内。</p>\n<hr>\n<h1 id=\"存储器管理：离散分配\"><a href=\"#存储器管理：离散分配\" class=\"headerlink\" title=\"存储器管理：离散分配\"></a>存储器管理：离散分配</h1><p>连续分配一次性分配所有，不灵活</p>\n<p>碎片问题：紧凑方式消耗系统开销</p>\n<p>离散分配 分页、分段、段页</p>\n<hr>\n<h2 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h2><h3 id=\"基本概念-2\"><a href=\"#基本概念-2\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>用户空间划分：用户程序按逻辑页划分成大小相等的部分，称为页（虚页） 从0开始编制页号，页内地址相对于0编址。</p>\n<p>逻辑空间划分由系统自动完成的，对用户透明。 一般页大小为2的整数次幂，因此，地址的高位部分为页号，低位部分为页内地址。</p>\n<h3 id=\"分页逻辑地址结构\"><a href=\"#分页逻辑地址结构\" class=\"headerlink\" title=\"[分页逻辑地址结构]\"></a>[分页逻辑地址结构]</h3><p>页内地址：长度由页大小决定；</p>\n<p>页号：除去页内地址所占的高位部分。</p>\n<p>例：<strong>逻辑地址为32位，页大小为4KB</strong>，则<strong>逻辑地址的低12位（2^12&#x3D;4KB），为页内地址w</strong>，而<strong>高20位为页号p</strong>，地址结构如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d86677987a924114a45e6bc317d50b34.png\"></p>\n<h3 id=\"基本页式存储管理\"><a href=\"#基本页式存储管理\" class=\"headerlink\" title=\"[基本页式存储管理]\"></a>[基本页式存储管理]</h3><ul>\n<li><p>内存空间划分</p>\n<ul>\n<li>按页的大小划分为<strong>大小相等的区域</strong>，称为内存块（物理页面，页框、实页）→ frame</li>\n<li><strong>从0开始</strong>编号</li>\n</ul>\n</li>\n<li><p>内存分配</p>\n<ul>\n<li><p>以页为单位进行分配</p>\n<ul>\n<li>内部碎片 → 最后一页的页内碎片</li>\n<li>外部碎片？</li>\n</ul>\n</li>\n<li><p><strong>逻辑上相邻的页，物理上不一定相邻；反之亦然</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"地址变换机构\"><a href=\"#地址变换机构\" class=\"headerlink\" title=\"[地址变换机构]\"></a>[地址变换机构]</h3><ul>\n<li><p>页表 page table</p>\n<ul>\n<li><strong>逻辑页号→物理块号的映射。</strong></li>\n</ul>\n</li>\n<li><p>基本地址变换机构</p>\n</li>\n<li><p>每个进程拥有一个页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。</p>\n</li>\n<li><p>页表在内存，属于进程的<strong>现场</strong>信息(内核)。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/18676f80a22e4d9fab2d0ab049f279d9.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6ffa2ffaec554e268b9cb33939321b37.png\">**⭐描述：将逻辑地址的页号取出和页表始址搭配找到页表中对应的块号，将块号取出和页内地址拼接成物理地址，如此循环，直到取出的逻辑地址页号大于页表长度，越界中断。 **</p>\n<h3 id=\"页式存储中的重定位\"><a href=\"#页式存储中的重定位\" class=\"headerlink\" title=\"页式存储中的重定位\"></a>页式存储中的重定位</h3><p><strong>例题：</strong></p>\n<p>一个系统，内存容量共256KB，页框大小为1KB，共256块，编号为0～255。 第0～4块为操作系统所使用； 现有2个用户作业，作业1和作业2，其逻辑地址空间分别占2KB和2.5KB； 进入系统后，按块的大小划分分别占2页和3页。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c0c64717d64ed88a3d02e06eeb25b0.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f27840411e684aed9c47696582270354.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/fad792404730440cbe4a848e0eae7482.png\"></p>\n<p>* </p>\n<h3 id=\"⭐重点计算方法：\"><a href=\"#⭐重点计算方法：\" class=\"headerlink\" title=\"⭐重点计算方法：\"></a>⭐重点计算方法：</h3><ul>\n<li>计算页号：逻辑地址&#x2F;页框大小；</li>\n<li>页号 → 物理块号</li>\n<li>页内偏移：逻辑地址%页框大小。 </li>\n<li>物理地址：物理块号&#x2F;*页框大小+页内偏移</li>\n</ul>\n<p> </p>\n<h3 id=\"具有快表的地址变换机构\"><a href=\"#具有快表的地址变换机构\" class=\"headerlink\" title=\"具有快表的地址变换机构\"></a>具有快表的地址变换机构</h3><p>页表访存：二次 访页表 操作数据 </p>\n<h3 id=\"快表\"><a href=\"#快表\" class=\"headerlink\" title=\"[快表]\"></a>[快表]</h3><ul>\n<li>局部性：Locallity</li>\n<li>高速缓冲存储器，存放当前作业的最常用的页号和与之相应的物理块号。</li>\n<li>快表或联想存储器<ul>\n<li>Translation Lookaside Buffer （后备&#x2F;后援缓冲）</li>\n<li>Associative Mapping（unordered）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/80e8489407364125b5fb9083e95f7687.png\"></p>\n<p>⭐<strong>描述：查找过的就放在快表里，拿到逻辑地址先找快表里，没有的话就输入快表再查页表，随后拼接页内地址即可</strong></p>\n<p>** **</p>\n<p><strong>练习：</strong></p>\n<p>有一页式系统，其页表存放在主存中： 对主存的一次存取需要1.5μs，问实现一次页面访问的存取时间是多少? 如果系统有快表，平均命中率为85%，当页表项在快表中时，其查找时间忽略，问此时的平均存取时间是多少?</p>\n<p>无快表主存存取访问时间：1.5&#x2F;*2&#x3D;3μs</p>\n<p>增加快表后的存取访问时间： 0.85&#x2F;*1.5+(1-0.85)&#x2F;*2&#x2F;*1.5&#x3D;1.725μs</p>\n<h3 id=\"计算页表存储空间\"><a href=\"#计算页表存储空间\" class=\"headerlink\" title=\"计算页表存储空间\"></a>计算页表存储空间</h3><p>页表也在内存，也需要按页存储</p>\n<p>例子：</p>\n<p>32位系统；页面大小：4K；页表项（页号记录）：4B；问：一个进程的页表需要多少存储空间？</p>\n<p><img src=\"https://img-blog.csdnimg.cn/075a981932c344739a23d8ab5a8b3d37.png\"></p>\n<p>64位系统；页表项：8B；问：当页面大小为4K和1M时，一个进程的页表需要多少存储空间？</p>\n<ul>\n<li>4K：264&#x2F;4K &#x2F;* 8B&#x3D;255B&#x3D;32P</li>\n<li>1M：264&#x2F;1M &#x2F;* 8B&#x3D;247B&#x3D;128T</li>\n</ul>\n<p> </p>\n<h3 id=\"两级和多级页表\"><a href=\"#两级和多级页表\" class=\"headerlink\" title=\"两级和多级页表\"></a>两级和多级页表</h3><p><strong>两级页表</strong></p>\n<ul>\n<li>逻辑地址结构：<ul>\n<li>32位地址空间；页面大小4K；页表项4B</li>\n<li>如何计算每一层的位数？每页表项数宽度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/a41deaa81d4e42c785905e93d0227578.png\"></p>\n<p>**二级页表查找过程 **</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a5e89cce6e634695bf78d346e75a978b.png\"></p>\n<p>注意：页号是用来索引页表的，页表里存储的都是内存块号。 </p>\n<p> </p>\n<p><strong>计算：</strong></p>\n<p>64位系统；页面大小：4KB；页表项：8B；计算：2级页表存储空间；3级页表存储空间；至少设置几级页表才合理？（一级页表在一页内存储）</p>\n<ul>\n<li>2级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第2级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第2级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第1级页表项数量：2^43 第1级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 页表空间：(2^43+2^34) &#x2F;* 4K&#x3D;(2^13+2^4) &#x2F;* 4T&#x3D;32832T≈32.8P</li>\n<li>3级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第3级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第3级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第2级页表项数量：2^43 第2级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 第1级页表项数量：2^34 第1级页表项所需页面数量：2^34&#x2F;2^9&#x3D;2^25个 页表空间：(2^43+2^34+2^25) &#x2F;* 4K&#x3D;(2^23+2^14+2^5) &#x2F;* 4G&#x3D;…</li>\n<li>几级页表: 每页页表项数量：2^9 每9位切一刀 1次访存→7次访存 ⌈(64−12)&#x2F;9⌉⇒⌈(位数−页内偏移)&#x2F;每级别页号位数⌉⇒⌈log_2页面总数&#x2F;log_2页内表项数⌉</li>\n</ul>\n<p> </p>\n<p>多级页表令总空间增加，但通过按需装载，节省了内存空间。</p>\n<p> </p>\n<p>评价：物理空间小，逻辑空间大。</p>\n<p>页表大小∝逻辑空间大小</p>\n<p>物理内存变化速度&lt;&lt;逻辑空间</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"[例题]\"></a>[例题]</h3><p>某24位存储系统采用页式管理，页表分为两级，存储在主存中。每个页面1KB，每个页表项占4B，某进程的页表内容如下图所示（图中数字全部为10进制）。请计算逻辑地址526245（十进制）对应的物理地址。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1a31553d068d42f08c8569ce53157772.png\"></p>\n<p>解答：</p>\n<p>每个进程的总页面数为224B&#x2F;1KB&#x3D;214个，每个页面可存储页表项1KB&#x2F;4B&#x3D;256&#x3D;28个，存储二级页表所需要的页面数为：214&#x2F;28&#x3D;26个&lt;28个，则一级页表可以在一个页面内存储完成。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5a83c0c8ea884ec095456a79bccb65aa.png\">526245对应的二进制表示（斜线表示上述逻辑切分）：10&#x2F;00 0000 01&#x2F;11 1010 0101</p>\n<p>按照上述划分方法得到：一级页号为2，二级页号1，页内地址0x03A5。  </p>\n<p>一级页表第2项查找到二级页表的物理块号：678</p>\n<p>在678物理块的第1项找到物理块号889（0x0379），形成物理地址块号</p>\n<p>与页内地址0x03A5拼接，形成完整的地址：</p>\n<p>1101 1110 01&#x2F;11 1010 0101→0xDE7A5（十进制：911269） </p>\n<h3 id=\"反置页表\"><a href=\"#反置页表\" class=\"headerlink\" title=\"反置页表\"></a>反置页表</h3><ul>\n<li><p>物理块→逻辑块</p>\n</li>\n<li><p>也称为页寄存器（Page Register）</p>\n</li>\n<li><p>每个内存块关联：</p>\n<ul>\n<li>使用位(Residence bit): 本页是否被占用</li>\n<li>使用者(Occupier): 占用此块的页号</li>\n<li>进程号</li>\n</ul>\n</li>\n<li><p>优点：存储开销小；页表大小与逻辑空间无关；全系统一张表</p>\n</li>\n<li><p>缺点：反向关联信息（页框号→页号），如何正向查询？</p>\n</li>\n</ul>\n<p> </p>\n<p>哈希算法：</p>\n<p>哈希运算：h(PID, 页号)→页框号</p>\n<p>查询过程 计算h(p, i)，并作为索引访问反置页表；</p>\n<p>获取反置页表项；</p>\n<p>如果匹配(pid, 页号)，命中；</p>\n<p>否则，不命中。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c2a4cca4188e4c5c870bdb8ef484ce9e.png\"></p>\n<h3 id=\"页式存储小结\"><a href=\"#页式存储小结\" class=\"headerlink\" title=\"页式存储小结\"></a>页式存储小结</h3><ul>\n<li><p>优点：</p>\n<ul>\n<li>解决了碎片问题</li>\n<li>便于管理</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>页表的开销大</li>\n<li>共享不便，保护不便：语义边界不清晰</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<hr>\n<h2 id=\"段式存储管理\"><a href=\"#段式存储管理\" class=\"headerlink\" title=\"段式存储管理\"></a>段式存储管理</h2><p>每个段可有其逻辑意义及功能，使得便于：编写程序、分段共享、分段保护、动态链接、动态增长。</p>\n<h3 id=\"基本概念-3\"><a href=\"#基本概念-3\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>用户空间划分</p>\n<ul>\n<li><p>按程序自身逻辑关系划分为若干段，如代码段、数据段。</p>\n<ul>\n<li>可针对不同类型段采取不同的保护</li>\n<li>以段为单位共享，包括通过动态链接进行代码共享</li>\n</ul>\n</li>\n<li><p>每个程序段都有一个段名，且有一个段号</p>\n</li>\n<li><p>段号从0开始，段内从0开始编址</p>\n</li>\n<li><p>段内地址是连续的</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/9fd6f7430ec2436caec086576be470d4.png\"></p>\n<p>内存空间划分</p>\n<ul>\n<li>内存空间被动态划分为若干个长度不等的区域，这些区域被称为物理段：(起始地址，长度)</li>\n</ul>\n<p>内存分配</p>\n<ul>\n<li>以段为单位分配内存，每一个段在内存中占据连续空间</li>\n<li>各段之间可以不连续存放</li>\n</ul>\n<p> </p>\n<p>进程段表</p>\n<ul>\n<li><p>段号，段的首址和长度之间的关系。</p>\n</li>\n<li><p>每一个程序设置一个段表，放在内存，属于进程的<strong>现场</strong>信息</p>\n</li>\n<li><p><img src=\"C:\\Users\\tao020704\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230217005244310.png\" alt=\"image-20230217005244310\"></p>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/d5e2a80200ce44a59220f01853a5f687.png\"></p>\n</li>\n</ul>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"[评价]\"></a>[评价]</h3><p>优点</p>\n<ul>\n<li>分段对程序员是可见的，是一种方便的组织程序和数据的手段，便于模块化程序设计</li>\n<li>便于保护和共享</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>进程全部装入内存</li>\n</ul>\n<h3 id=\"段式地址变换\"><a href=\"#段式地址变换\" class=\"headerlink\" title=\"段式地址变换\"></a>段式地址变换</h3><p><img src=\"https://img-blog.csdnimg.cn/826a4fcbf7684c5fae8ad454da24a8f2.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/5dd42e23c50245318a969be4f8a212fb.png\"></p>\n<p>分段系统**共享editor **</p>\n<h3 id=\"分配（类似动态分区）\"><a href=\"#分配（类似动态分区）\" class=\"headerlink\" title=\"分配（类似动态分区）\"></a>分配（类似动态分区）</h3><ul>\n<li><p>系统段表</p>\n<ul>\n<li>系统内所有占用段</li>\n</ul>\n</li>\n<li><p>空闲段表</p>\n<ul>\n<li>记录空闲段起始地址和长度，可以结合到系统段表中</li>\n</ul>\n</li>\n<li><p>内存分配算法</p>\n<ul>\n<li>首先适配；最佳适配；最坏适配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与分页的比较\"><a href=\"#与分页的比较\" class=\"headerlink\" title=\"与分页的比较\"></a>与分页的比较</h3><ul>\n<li>分页是出于系统管理的需要，分段是出于用户应用的需要。</li>\n<li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>\n<li>页大小是系统固定的，而段大小则通常不固定。</li>\n<li>逻辑地址表示： 分页是一维的：引用时是统一的地址； 分段是二维的，与程序逻辑一致：引用时段名+偏移；</li>\n<li>通常段比页大，因而段表比页表短，查找快，提高访问速度。</li>\n<li>段式管理碎片问题比页式管理严重</li>\n<li>与动态分区不同：一个程序可以占据多个段，段不要求连续。</li>\n</ul>\n<hr>\n<h2 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h2><p>分页优点：提高内存利用率</p>\n<p>分段优点：方便用户，易于共享，保护，动态链接</p>\n<p><strong>段页式系统：综合优点</strong></p>\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><ul>\n<li><p>用户程序按段式划分</p>\n</li>\n<li><p>内存页式存储管理方案</p>\n</li>\n<li><p>内存分配：以页为单位进行分配</p>\n<ul>\n<li>对用户而言，仍然是二维编址。</li>\n<li>对系统而言，则是三维编址</li>\n<li><img src=\"https://img-blog.csdnimg.cn/08f2fb7be1c14466a3e9c940a28a5665.png\"></li>\n</ul>\n</li>\n<li></li>\n</ul>\n<h3 id=\"地址映射-1\"><a href=\"#地址映射-1\" class=\"headerlink\" title=\"地址映射\"></a>地址映射</h3><ul>\n<li><img src=\"https://img-blog.csdnimg.cn/f2eac741236f43b9b6fa682101259cef.png\"></li>\n<li></li>\n</ul>\n<h3 id=\"地址变换\"><a href=\"#地址变换\" class=\"headerlink\" title=\"地址变换\"></a>地址变换</h3><ul>\n<li><img src=\"https://img-blog.csdnimg.cn/27a8d10c28ee48d5aa219c6caa3cfc27.png\"></li>\n</ul>\n<hr>\n<h2 id=\"地址变换实例\"><a href=\"#地址变换实例\" class=\"headerlink\" title=\"地址变换实例\"></a>地址变换实例</h2><p><img src=\"https://img-blog.csdnimg.cn/0c939f6f3eb743c8a76961be2f824d2c.png\"></p>\n<p>练习：<br>设一个地址空间有8个页，每个页面大小为1024个字节，映射到32块物理页面的主存上。试问：</p>\n<p>逻辑地址要用多少位表示？13</p>\n<p>物理地址要用多少位表示？15 </p>\n<p>答：</p>\n<p><a href=\"https://www.baidu.com/s?wd=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf\" title=\"逻辑地址\">逻辑地址</a>：8&#x2F;*1024&#x3D;2^3&#x2F;*2^10&#x3D;2^13（所以<a href=\"https://www.baidu.com/s?wd=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf\" title=\"逻辑地址\">逻辑地址</a>的后13位为“页内地址”，又叫“页内<a href=\"https://www.baidu.com/s?wd=%E5%81%8F%E7%A7%BB%E9%87%8F&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf\" title=\"偏移量\">偏移量</a>”，或“页内位移”及有效位）</p>\n<p>再算<a href=\"https://www.baidu.com/s?wd=%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf\" title=\"物理地址\">物理地址</a>：32&#x2F;*1024&#x3D;2^5&#x2F;*2^10&#x3D;2^15</p>\n<p>所以最后的就是逻辑有效位是13；物理有效位是15.</p>\n<hr>\n<h1 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h1><p>允许执行只有部分在内存中的程序</p>\n<p>程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作</p>\n<p>提高程序执行的并发性、CPU利用率</p>\n<hr>\n<h2 id=\"基本概念-4\"><a href=\"#基本概念-4\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p><strong>常规存储器的问题</strong></p>\n<ul>\n<li><p>常规存储</p>\n<ul>\n<li>一次性，驻留性</li>\n<li>覆盖和交换可以减轻这一限制</li>\n</ul>\n</li>\n<li><p>有时，并不需要将整个程序放入内存中</p>\n<ul>\n<li>程序中的异常分支</li>\n<li>数组通常分配了比实际所需要更多的内存</li>\n<li>程序的某些选项或特点可能很少使用</li>\n</ul>\n</li>\n</ul>\n<p><strong>虚拟存储器的目标</strong></p>\n<ul>\n<li>允许执行只有部分在内存中的程序</li>\n<li>程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作</li>\n<li>提高程序执行的并发性、CPU利用率</li>\n</ul>\n<h3 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h3><ul>\n<li><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。</p>\n</li>\n<li><p>时间局部性（Temporal Locality）</p>\n<ul>\n<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。</li>\n</ul>\n</li>\n<li><p>空间局部性（Spatial Locality）</p>\n<ul>\n<li>若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><ul>\n<li><p>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>\n</li>\n<li><p>逻辑容量由内存容量和外存容量之和所决定</p>\n<ul>\n<li>运行速度接近于内存速度</li>\n<li>成本接近于外存</li>\n</ul>\n</li>\n<li><p>原理</p>\n<ul>\n<li>在程序装入时，只需将当前需要执行的部分读入内存，就可让程序开始执行。</li>\n<li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入内存，然后继续执行程序。</li>\n<li>另一方面，操作系统将内存中暂时不用的页或段调出保存在外存上，腾出空间存放将要调入的页或段。</li>\n</ul>\n</li>\n<li><p><strong>虚拟内存大于物理内存</strong></p>\n</li>\n<li><p>实现方法</p>\n<ul>\n<li>虚拟页式——请求分页(Demand Page)</li>\n<li>虚拟段式——请求段式调度(Demand Segmentation)</li>\n<li>虚拟段页式</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"虚拟页式\"><a href=\"#虚拟页式\" class=\"headerlink\" title=\"虚拟页式\"></a>虚拟页式</h2><p>在简单页式存储管理的基础上，增加请求调页和页面置换功能。</p>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"请求分页\"><a href=\"#请求分页\" class=\"headerlink\" title=\"请求分页\"></a>请求分页</h3><p>页表：与简单分页相比，增加了如下位：</p>\n<p>P：表示该页是否在内存中</p>\n<p>A：访问位，是否被访问过</p>\n<p>M：修改位，从上次装入到现在是否已经改变</p>\n<p>外存地址</p>\n<p><img src=\"https://img-blog.csdnimg.cn/685f80837d7d4d78985b2a43e8417f83.png\"></p>\n<p>地址转换流程</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2c15996396164ecdacd5f500bf83592a.png\"></p>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"内存分配、置换策略\"><a href=\"#内存分配、置换策略\" class=\"headerlink\" title=\"内存分配、置换策略\"></a>内存分配、置换策略</h3><p>分配策略：固定分配，可变分配</p>\n<p>置换策略：全局置换，局部置换</p>\n<p>可组合出以下三种适用的策略：</p>\n<ul>\n<li>固定分配局部置换(Fixed Allocation, Local Replacement)</li>\n<li>可变分配全局置换(Variable Allocation, Global Replacement)</li>\n<li>可变分配局部置换(Variable Allocation, Local Replacement)</li>\n</ul>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"缺页中断处理\"><a href=\"#缺页中断处理\" class=\"headerlink\" title=\"缺页中断处理\"></a>缺页中断处理</h3><ul>\n<li><p>要访问的页不在内存，则产生缺页中断(page fault)。</p>\n</li>\n<li><p>操作系统接到此中断信号后，调用缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去</p>\n<ul>\n<li>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号</li>\n<li>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存</li>\n</ul>\n<p> </p>\n</li>\n<li><p>缺页中断在指令执行期间产生和处理，所缺的页面调入之后，重新执行被中断的指令。</p>\n</li>\n<li></li>\n</ul>\n<h3 id=\"系统颠簸-x2F-抖动\"><a href=\"#系统颠簸-x2F-抖动\" class=\"headerlink\" title=\"系统颠簸&#x2F;抖动\"></a>系统颠簸&#x2F;抖动</h3><ul>\n<li>页面被频繁地换入换出</li>\n<li>缺页率急剧增加，内存有效存取时间加长，系统吞吐量骤减；</li>\n<li>系统已基本不能完成什么任务。</li>\n<li>原因：CPU利用率太低→调度程序增加多道程序度→新进程启动运行→内存不足→缺页→I&#x2F;O忙碌，CPU空闲。</li>\n<li><img src=\"https://img-blog.csdnimg.cn/a841fbd22c1140c68ebdafac4f7d832e.png\"></li>\n<li>防止系统颠簸&#x2F;抖动<ul>\n<li>局部置换策略：如果一个进程出现抖动，它不能从另外的进程取帧。</li>\n<li>挂起某些进程：优先级低、缺页进程、最大的进程等</li>\n<li>利用工作集、缺页频率策略防止抖动</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"工作集\"><a href=\"#工作集\" class=\"headerlink\" title=\"工作集\"></a>工作集</h3><ul>\n<li><p>一个进程在某一段时间内访问页面的集合。（<strong>并非越大越好</strong>！）</p>\n</li>\n<li><p>如果页面正在使用，它就落在工作集中；</p>\n</li>\n<li><p>如果不再使用，它将不出现在相应的工作集中，所以，工作集是程序局部性的近似表示。</p>\n</li>\n<li><p>工作集：W(t, Δt)，(t-Δt, t] 内访问的页面集合。</p>\n</li>\n<li><p>虚拟时间t：页面访问点</p>\n</li>\n<li><p>时间窗口Δt</p>\n<p><code>太小，不能包含整个局部；</code></p>\n<p><code>太大，是进程执行所碰到的所有页的集合。</code></p>\n</li>\n<li><p>避免抖动方法</p>\n</li>\n<li><pre><code>* OS监视每个进程的工作集\n    新增页面分配内存。\n     淘汰不在工作集中的页面。\n* 若有足够多的额外内存块，就可装入另一个进程。\n* 如果所有工作集之和超过了可用内存，则OS选择挂起一个进程，把它的页换出，将其内存块分配给其它进程。\n* 工作集的估算不容易：Δ\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  \n\n----\n\n## 页面替换&#x2F;置换算法 \n\n### 最佳算法（OPT）\n\n选择替换下次访问距当前时间最长的那些页。\n\n**特点**\n\n* 缺页错误率最低，没有Belady现象；\n* 必须知道页面未来的访问顺序→不可能实现。\n* 仅作为一种标准，用于测试其他算法的性能。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;49d19dc276a64b7c98c7dc7db67718da.png)\n\n###\n\n### 先进先出算法(First in First Out，FIFO)\n\n替换驻留在主存中时间最长的页\n\n注意：驻留时间和访问时间无关\n\n实现：将分配给进程的页帧看作FIFO队列，按循环方式移动页：置换队列的首页，调入的新页加入队尾。\n\n问题：FIFO策略实现简单，但性能相对较差。\n\nBelady异常：有些情况下，缺页率可能会随着所分配帧数的增加而增加。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;8328e3d7516e45f3b2f875ae8db1cdc0.png)\n\n**练习：**\n\n页面请求序列：3 2 1 0 3 2 4 3 2 1 0 4 分别计算使用FIFO算法，分配3个Frame和4个Frame时产生page fault的次数。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;535d087a40d8476a84039c0d04a111f7.png)\n\n###\n\n### 最近最久未使用算法(LRU, Least Recently Used)\n\n替换主存中上次使用距离当前最远的页（最长时间没有使用的页）\n\n可以理解为向后看最优置换算法：根据局部性原理，这也是最近最不可能访问到的页。\n\n性能接近OPT，但历史不等于未来\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3b867617b8664ab2b6dc3d10621fd6f3.png)\n\n* 实现：\n  * 计数器：每个页添加逻辑时钟或计数器，访问页面时加1，定时减1（或寄存器移位）。在淘汰时，选择该值最小的页面。\n    * 比较开销\n\n  * 堆栈：页面被访问，该页就从堆栈中提到顶部，底部是目前最少使用的页。 \n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;5301e7250b004634b1606b06a121f676.png) \n\n###\n\n### Clock算法\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3f0c1f1398a045b88e9e7caffd730dad.png)\n\n \n\n### 改进Clock算法\n\n增加修改位M\n\n由(A, M)可以组合成四种页面：\n\n(A&#x3D;0, M&#x3D;0)：表示该页最近既未被访问，又未被修改， 是最佳淘汰页。\n\n(A&#x3D;0, M&#x3D;1)：表示该页最近未被访问，但已被修改，若替换要被写回。\n\n(A&#x3D;1, M&#x3D;0)：最近已被访问，但未被修改，该页有可能再被访问。\n\n(A&#x3D;1, M&#x3D;1)：最近已被访问且被修改，该页可能再被访问。\n\n**步骤：**\n\n从指针所指示的当前位置开始，扫描循环队列， 寻找(A&#x3D;0, M&#x3D;0)的第一类页面，将遇到的第一个页面作为淘汰页，如未找到，转第2步；\n\n同样扫描方法，寻找(A&#x3D;0, M&#x3D;1)的第二类页面，将遇到的第一个此类页面作为淘汰页。将所有扫描过的页面的访问位A置0。若未找到，转第1步。 \n\n### 其他置换算法\n\n* 最不经常使用算法LFU(Least Frequently Used)\n  * 访问频繁→访问记数大\n    * 例外：一个页在进程开始时使用得很多，但以后就不再使用\n\n  * 定期将次数寄存器右移一位，形成指数衰减\n  * 关注访问次数，LRU关注上次访问时间\n\n* 最常使用算法MFU(Most Frequently Used)\n  * 最小次数的页可能刚刚调进来，且还没有使用，不换出\n\n* 页面缓冲算法PBA(Page Buffering Algorithm)\n  * 维护一个free page pool\n  * 换出页可稍后换出，避免调入时换出写磁盘\n\n\n### 练习题\n\n### ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;67b6ee9cc3014221acc063325d8e3a28.png)\n\n----\n\n## 虚拟段式\n\n### 请求分段\n\n* 在简单段式存储管理的基础上，增加请求调段和段置换功能。\n* 段表添加若干项：\n\n* &#96;&#96;&#96;\n  * 存在位(present bit)\n  * 修改位(modified bit&#x2F;dirty bit)\n  * 访问&#x2F;使用位(use bit)\n  * 存取权限：如读R，写W，执行X\n  * 外存地址\n  </code></pre>\n\n![](https://img-blog.csdnimg.cn/d181f61270374258a323bc0fc7966233.png)\n</code></pre>\n</li>\n<li><p>动态地址变换和缺段中断：指令和操作数必定不会跨越在段边界上</p>\n</li>\n<li><p>程序运行时，先把当前需要的一段或者几段装入内存，其它段仅仅在调用时才装入。</p>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/6dbd88252e5547d89c05250c49bb771b.png\"></p>\n</li>\n</ul>\n<h3 id=\"地址变换过程\"><a href=\"#地址变换过程\" class=\"headerlink\" title=\"地址变换过程\"></a>地址变换过程</h3><p><img src=\"https://img-blog.csdnimg.cn/23b318f6541541769c0cb5ad7b2d92ce.png\"></p>\n<hr>\n<h2 id=\"虚拟段页式\"><a href=\"#虚拟段页式\" class=\"headerlink\" title=\"虚拟段页式\"></a>虚拟段页式</h2><ul>\n<li>虚拟段页式：虚拟页式和虚拟段式存储管理的结合，存储管理的分配单位是：段，页</li>\n<li>逻辑地址的组成：段号，页号，页内偏移地址，程序员可见的仍是段号和段内相对地址。</li>\n<li>地址变换：先查段表，再查该段的页表。缺段中断和缺页中断。</li>\n</ul>\n<h3 id=\"分段的共享与保护\"><a href=\"#分段的共享与保护\" class=\"headerlink\" title=\"分段的共享与保护\"></a>分段的共享与保护</h3><ul>\n<li><p>共享段表：整个系统一张</p>\n<ul>\n<li>共享进程计数，存取控制字段。</li>\n<li>段号：不同进程可以使用不同的段号共享段。</li>\n</ul>\n</li>\n<li><p><img src=\"C:\\Users\\tao020704\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230217005924521.png\" alt=\"image-20230217005924521\"></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>存储器管理部分告一段落，本章主要任务就是理解一些概念，重点在于熟练运用各种算法进行计算，例如<strong>重定位、地址变换、计算页表存储空间、页面置换算法</strong>等。 </p>\n<h1 id=\"第四部分-设备管理\"><a href=\"#第四部分-设备管理\" class=\"headerlink\" title=\"第四部分 \t设备管理\"></a>第四部分 \t设备管理</h1><p><strong>目录</strong></p>\n<p><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p><a href=\"#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86\">设备管理</a></p>\n<p>​\t\t<a href=\"#I/O%E7%B3%BB%E7%BB%9F\">I&#x2F;O系统</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7\">设备使用特性</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87\">数据传输速率</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%95%E4%BD%8D\">数据传输单位</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BE%E5%A4%87%E5%85%B1%E4%BA%AB%E5%B1%9E%E6%80%A7\">设备共享属性</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8\">设备控制器</a></p>\n<p>​\t\t\t\t<a href=\"#I/O%E9%80%9A%E9%81%93\">I&#x2F;O通道</a></p>\n<p>​\t\t<a href=\"#I/O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\">I&#x2F;O控制方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A8%8B%E5%BA%8FI/O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\">程序I&#x2F;O控制方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F\">中断方式</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88DMA%EF%BC%89%C2%A0\">直接存储器访问（DMA） </a></p>\n<p>​\t\t<a href=\"#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86\">缓冲管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8D%95%E7%BC%93%E5%86%B2Single%20Buffer\">单缓冲Single Buffer</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%8F%8C%E7%BC%93%E5%86%B2Double%20Buffer\">双缓冲Double Buffer</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2Circular%20Buffer\">循环缓冲Circular Buffer</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%BC%93%E5%86%B2%E6%B1%A0Buffer%20Pool\">缓冲池Buffer Pool</a></p>\n<p>​\t\t<a href=\"#I/O%E8%BD%AF%E4%BB%B6\">I&#x2F;O软件</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F\">中断的工作方式</a></p>\n<p>​\t\t<a href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D\">设备分配</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95\">设备分配算法</a></p>\n<p>​\t\t\t\t<a href=\"#SPOOLing%EF%BC%9A%E5%81%87%E8%84%B1%E6%9C%BA%E6%93%8D%E4%BD%9C\">SPOOLing：假脱机操作</a></p>\n<p><a href=\"#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%9A%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%AE%9E%E4%BE%8B%C2%A0\">设备管理：调度与实例 </a></p>\n<p>​\t\t<a href=\"#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8\">磁盘存储器</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84\">磁盘结构</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\">地址转换</a></p>\n<p>​\t\t<a href=\"#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F\">连接方式</a></p>\n<p>​\t\t\t\t<a href=\"#DAS%EF%BC%9A%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD\">DAS：磁盘挂载</a></p>\n<p>​\t\t\t\t<a href=\"#NAS%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8C%82%E8%BD%BD\">NAS：网络挂载</a></p>\n<p>​\t\t\t\t<a href=\"#SAN%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91\">SAN：存储区域网</a></p>\n<p>​\t\t<a href=\"#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE\">磁盘访问</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F\">访问模式</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\">访问时间</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4\">寻道时间</a></p>\n<p>​\t\t\t\t<a href=\"#%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4\">传输时间</a></p>\n<p>​\t\t\t\t<a href=\"#(%E6%97%8B%E8%BD%AC)%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4\">(旋转)延迟时间</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%80%BB%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\">总访问时间</a></p>\n<p>​\t\t<a href=\"#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6\">磁盘调度</a></p>\n<p>​\t\t\t\t<a href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89\">先来先服务（FCFS）</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89\">最短寻道时间优先（SSTF）</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88SCAN,%20CSCAN%EF%BC%89\">扫描算法（SCAN, CSCAN）</a></p>\n<p>​\t\t\t\t<a href=\"#Look%20&%20C-Look%E7%AE%97%E6%B3%95\">Look &amp; C-Look算法</a></p>\n<p>​\t\t\t\t<a href=\"#%E2%AD%90%E7%BB%83%E4%B9%A0%E9%A2%98\">⭐练习题</a></p>\n<p>​\t\t\t\t<a href=\"#%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95\">改进方法</a></p>\n<p>​\t\t<a href=\"#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86\">磁盘管理</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98\">磁盘缓存</a></p>\n<p>​\t\t\t\t<a href=\"#%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD\">读写性能</a></p>\n<p>​\t\t\t\t<a href=\"#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86\">磁盘管理</a></p>\n<p>​\t\t\t\t<a href=\"#RAID\">RAID</a></p>\n<hr>\n<h1 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>\n<ul>\n<li><strong>CM1****：</strong>操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>\n<li><strong>CM2****：</strong>进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>\n<li><strong>CM3****：</strong>内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>\n<li><strong>CM4****：</strong>设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>\n<li><strong>CM5****：</strong>文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>\n</ul>\n<p>本节要点在CM4，大致内容如下：</p>\n<p>第四章 设备管理（8 学时，多媒体课件结合板书面授）CM4</p>\n<p>1、主要内容<br>I&#x2F;O 系统的基本概念和设备分配中的数据结构，I&#x2F;O 控制方式，通道的分类，缓冲管理，磁盘存储管理的调度策略；设备的独立性，虚拟设备，磁盘冗余阵列。<br>2、应达到的要求</p>\n<p>记忆：磁盘冗余阵列、闪存技术。<br>理解：I&#x2F;O 系统的组成，设备的独立性。</p>\n<p>分析: I&#x2F;O 控制方式、缓冲管理、设备分配、设备处理、虚拟设备、磁盘的调度算法。</p>\n<hr>\n<h1 id=\"设备管理\"><a href=\"#设备管理\" class=\"headerlink\" title=\"设备管理\"></a>设备管理</h1><p>I&#x2F;O系统 I&#x2F;O控制方式 缓冲管理 I&#x2F;O软件 设备分配 磁盘存储器的管理</p>\n<hr>\n<h2 id=\"I-x2F-O系统\"><a href=\"#I-x2F-O系统\" class=\"headerlink\" title=\"I&#x2F;O系统\"></a>I&#x2F;O系统</h2><h3 id=\"基本概念-5\"><a href=\"#基本概念-5\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>从OS观点看，重要的评价、分类指标：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">设备使用特性\n数据传输速率\n数据传输单位\n设备共享属性</code></pre>\n\n\n\n<h3 id=\"设备使用特性\"><a href=\"#设备使用特性\" class=\"headerlink\" title=\"设备使用特性\"></a>设备使用特性</h3><ul>\n<li><p>存储设备：外存或后备存储器、辅助存储器，计算机系统用以存储信息的主要设备。</p>\n<ul>\n<li>存取速度较内存慢，但容量比内存大得多，相对价格也便宜。</li>\n</ul>\n</li>\n<li><p>输入&#x2F;输出设备，具体可分为输入设备、输出设备和交互式设备。</p>\n<ul>\n<li>输入设备：用来接收外部信息，如键盘、鼠标、扫描仪、视频摄像、各类传感器等。</li>\n<li>输出设备：用于将计算机加工处理后的信息送向外部的设备，如打印机、绘图仪、显示器、数字视频显示设备、音响输出设备等。</li>\n<li>交互式设备：集成上述两类设备（耳机+耳麦，触屏）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据传输速率\"><a href=\"#数据传输速率\" class=\"headerlink\" title=\"数据传输速率\"></a>数据传输速率</h3><p>低速设备：传输速率仅为几个字节&#x2F;s至数百个字节&#x2F;s，键盘、鼠标器、语音的输入和输出等设备。</p>\n<p>中速设备：传输速率在数KB&#x2F;s至数百KB&#x2F;s 行式打印机、 激光打印机等。</p>\n<p>高速设备：传输速率在数十MB&#x2F;s 磁带、磁盘、光盘等。</p>\n<h3 id=\"数据传输单位\"><a href=\"#数据传输单位\" class=\"headerlink\" title=\"数据传输单位\"></a>数据传输单位</h3><ul>\n<li><p>块设备(Block Device)：信息的存取以数据块为单位</p>\n<ul>\n<li>典型的块设备是磁盘，每个盘块的大小为512 B～4 KB。</li>\n<li>传输速率较高，x MB&#x2F;s； 可寻址，支持随机读&#x2F;写；</li>\n<li>常采用DMA方式。</li>\n</ul>\n</li>\n<li><p>字符设备(Character Device)：数据访问基本单位是字符</p>\n<ul>\n<li>字符设备的种类繁多，如交互式终端、打印机等。</li>\n<li>传输速率较低，通常为几个字节至数千字节；</li>\n<li>不可寻址，即输入&#x2F;输出时不能指定数据的输入源地址及输出的目标地址</li>\n<li>常采用中断驱动方式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设备共享属性\"><a href=\"#设备共享属性\" class=\"headerlink\" title=\"设备共享属性\"></a>设备共享属性</h3><ul>\n<li><p>独占设备</p>\n<ul>\n<li>严格独占使用，顺序共享（不存在交叉使用）</li>\n<li>例：打印机</li>\n</ul>\n</li>\n<li><p>共享设备</p>\n<ul>\n<li>并发共享，对每一时刻而言，只允许一个进程访问</li>\n<li>例：磁盘</li>\n</ul>\n</li>\n<li><p>虚拟设备</p>\n<ul>\n<li>通过虚拟技术将一台独占设备模拟为共享设备，供若干个进程同时使用。</li>\n<li>例：SPOOLing</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<h3 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h3><p><strong>设备与控制器接口</strong></p>\n<p>设备并不是直接与CPU进行通信，而是与设备控制器通信。在该接口中有三种类型的信号，各对应一条信号线。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/73cd7de7b6404816948c77c2008720a6.png\"></p>\n<p>**设备控制器的组成 **</p>\n<p><img src=\"https://img-blog.csdnimg.cn/cda97850891c443f8e94c7305affb828.png\"></p>\n<ul>\n<li><p><strong>设备控制器与处理机（CPU）的接口</strong></p>\n<ul>\n<li>实现CPU与设备控制器之间的通信<ul>\n<li>数据线、地址线和控制线</li>\n<li>数据线通常与两类寄存器相连接<ul>\n<li>数据寄存器；</li>\n<li>控制&#x2F;状态寄存器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>设备控制器与设备的接口</strong></p>\n<ul>\n<li>一个设备控制器可连接一个或多个设备<ul>\n<li>多个设备接口，一个接口连接一台设备</li>\n<li>数据、控制和状态三种类型的信号</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>I&#x2F;O逻辑</strong></p>\n<ul>\n<li><p>I&#x2F;O逻辑用于实现对设备的控制。</p>\n<ul>\n<li>通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送I&#x2F;O命令；</li>\n</ul>\n</li>\n<li><p>每当CPU要启动一个设备时</p>\n<ul>\n<li>将启动命令发送给控制器； 同时通过地址线把地址发送给控制器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e50f4333574a468aa620f902d0a24f5d.png\"></p>\n<h3 id=\"I-x2F-O通道\"><a href=\"#I-x2F-O通道\" class=\"headerlink\" title=\"I&#x2F;O通道\"></a>I&#x2F;O通道</h3><ul>\n<li><p>将CPU从设备控制器中解脱出来</p>\n</li>\n<li><p>一种特殊的处理机，具有执行I&#x2F;O指令的能力，通过执行通道程序来控制I&#x2F;O操作。</p>\n</li>\n<li><p>与一般的处理机不同</p>\n<ul>\n<li>指令类型单一。由于通道硬件比较简单，其所能执行的命令主要局限于与I&#x2F;O操作有关的指令；</li>\n<li>通道没有自己的内存。通道所执行的通道程序放在主机内存中。</li>\n</ul>\n<p> </p>\n</li>\n<li><p>通道类型</p>\n<ul>\n<li>字节多路通道<ul>\n<li>按字节交叉方式工作的通道。</li>\n<li>通常含有许多<strong>非分配型</strong>子通道，其数量可从几十到数百个，每一个子通道连接一台I&#x2F;O设备，并控制该设备的I&#x2F;O操作。</li>\n<li>子通道<strong>按时间片轮转方式</strong>共享主通道。</li>\n<li>若扫描每个子通道的速率足够快，而连接到<strong>子通道上的设备的速率不太高</strong>时，便不致丢失信息。 </li>\n<li><strong>实例：</strong>子通道A，B，C，D，E，…，N，分别通过控制器各与一台设备相连。 假定这些设备的速率相近，且同时向主机传送数据。 设备A所传送的数据流为A1A2A3…；设备B所传送的数据流为B1B2B3… 这些数据流合成后(通过主通道)送往主机的数据流为A1B1C1D1 …A2B2C2D2 … A3B3C3D3 …</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/9ad46b5fd21047838fc6e8d4993f9cdc.png\"></p>\n<ul>\n<li><p>数组选择通道</p>\n<ul>\n<li>字节多路通道不适于连接高速设备→按数组方式进行数据传送的数组选择通道。</li>\n<li>连接<strong>多台高速</strong>设备，但只含有一个<strong>分配型</strong>子通道</li>\n<li>在一段时间内只能执行一道通道程序，控制一台设备进行数据传送→当某台设备占用了该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其它设备使用该通道，直至该设备传送完毕释放该通道。</li>\n<li>通道利用率低。</li>\n</ul>\n</li>\n<li><p>数组多路通道</p>\n<ul>\n<li>数组多路通道：数组选择通道传输速率高和字节多路通道能使各子通道分时并行操作的<strong>优点相结合而形成</strong>。</li>\n<li>含有<strong>多个非分配型</strong>子通道</li>\n<li>被广泛地用于连接<strong>多台高、中速</strong>的外围设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>I&#x2F;O通道的瓶颈</p>\n<ul>\n<li>通道价格昂贵→通道数量较少→I&#x2F;O的瓶颈→系统吞吐量下降</li>\n</ul>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/0f4e535465824b6b849471da14c1feb7.png\"></p>\n<ul>\n<li><p>解决方法：</p>\n<ul>\n<li><p>增加通道</p>\n</li>\n<li><p>增加设备到主机间的通路而不增加通道：把一个设备连接到多个控制器上，一个控制器连接到多个通道上</p>\n</li>\n<li><p><img src=\"https://img-blog.csdnimg.cn/a8dad536a5fc4f79a60f7f36963afae9.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总线系统</p>\n<ul>\n<li>计算机系统中的各部件都是通过总线来连接的 （时钟频率、带宽、传输速率……）</li>\n<li><img src=\"https://img-blog.csdnimg.cn/14f4169dc2cb46199e9416b2d44cee8f.png\"></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"I-x2F-O控制方式\"><a href=\"#I-x2F-O控制方式\" class=\"headerlink\" title=\"I&#x2F;O控制方式\"></a>I&#x2F;O控制方式</h2><p><img src=\"https://img-blog.csdnimg.cn/10f7279d228442a59127d88c7dfff08c.png\"></p>\n<h3 id=\"程序I-x2F-O控制方式\"><a href=\"#程序I-x2F-O控制方式\" class=\"headerlink\" title=\"程序I&#x2F;O控制方式\"></a>程序I&#x2F;O控制方式</h3><p>早期的计算机系统中，无中断机构，处理机对I&#x2F;O设备的控制采取程序I&#x2F;O(Programmed I&#x2F;O)方式，或称为<strong>“忙—等待”方式</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6cb9cc998d064fad82cf1f4c3bf64935.png\"></p>\n<h3 id=\"中断方式\"><a href=\"#中断方式\" class=\"headerlink\" title=\"中断方式\"></a>中断方式</h3><ul>\n<li>现代计算机系统广泛采用中断驱动(Interrupt Driven)方式</li>\n<li>CPU→设备控制器发出I&#x2F;O命令，立即返回继续执行原来的任务。</li>\n<li>设备控制器按照该命令的要求控制指定设备。此时，CPU与I&#x2F;O设备并行操作。</li>\n<li>一旦设备操作完成，控制器便通过控制线<strong>向CPU发送中断信号</strong>；</li>\n<li>CPU向控制器发送取走数据的信号，然后再通过控制器及数据线将数据写入内存指定单元中。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e731375d1bae4e33b34a73449e97d907.png\"></p>\n<h3 id=\"直接存储器访问（DMA）\"><a href=\"#直接存储器访问（DMA）\" class=\"headerlink\" title=\"直接存储器访问（DMA）\"></a>直接存储器访问（DMA）</h3><p><strong>中断方式对块设备不适用</strong></p>\n<ul>\n<li>例：从磁盘中读1 KB数据，需中断CPU 1K次→减少CPU对I&#x2F;O的干预→直接存储器访问方式</li>\n<li>数据传输的基本单位是数据块；</li>\n<li>所传送的<strong>数据是从设备直接送入内存的，或者相反</strong>；</li>\n<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/318a3b3082414ce9b46021e823918b52.png\"></p>\n<p><strong>DMA控制器</strong> </p>\n<ul>\n<li><p>组成</p>\n<ul>\n<li>主机与DMA控制器的接口</li>\n<li>DMA控制器与块设备的接口</li>\n<li>I&#x2F;O控制逻辑</li>\n</ul>\n</li>\n<li><p>关键寄存器</p>\n<ul>\n<li>命令&#x2F;状态寄存器(CR)：接收从CPU发来的I&#x2F;O命令，或有关控制信息，或设备的状态。</li>\n<li>内存地址寄存器(MAR)：数据在内存的起始地址；输入、输出分别为源、目标地址</li>\n<li>数据寄存器(DR)：暂存从设备到内存，或从内存到设备的数据。</li>\n<li>数据计数器(DC)：存放本次CPU要读或写的字节数。</li>\n</ul>\n</li>\n</ul>\n<p><strong>DMA过程</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/3fce6337fc994837b13b4f0191b48336.png\"></p>\n<p> </p>\n<h2 id=\"缓冲管理\"><a href=\"#缓冲管理\" class=\"headerlink\" title=\"缓冲管理\"></a>缓冲管理</h2><p>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾。</p>\n<p>减少对CPU的中断频率。</p>\n<p>提高CPU和I&#x2F;O设备之间的并行性。</p>\n<p><strong>缓冲类型：</strong></p>\n<ul>\n<li>单缓冲Single Buffer</li>\n<li>双缓冲Double Buffer</li>\n<li>循环缓冲Circular Buffer</li>\n<li>缓冲池Buffer Pool</li>\n</ul>\n<h3 id=\"单缓冲Single-Buffer\"><a href=\"#单缓冲Single-Buffer\" class=\"headerlink\" title=\"单缓冲Single Buffer\"></a>单缓冲Single Buffer</h3><p>一个缓冲区 max(T, C) + M</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fd810b38a71246ddaad26aad65d27024.png\"></p>\n<h3 id=\"双缓冲Double-Buffer\"><a href=\"#双缓冲Double-Buffer\" class=\"headerlink\" title=\"双缓冲Double Buffer\"></a>双缓冲Double Buffer</h3><p>缓冲对换(Buffer Swapping) max(C, T)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/aba9f4246a8d49d5948e73759442848a.png\"></p>\n<h3 id=\"循环缓冲Circular-Buffer\"><a href=\"#循环缓冲Circular-Buffer\" class=\"headerlink\" title=\"循环缓冲Circular Buffer\"></a>循环缓冲Circular Buffer</h3><p>多个缓冲区；进程同步</p>\n<p><img src=\"https://img-blog.csdnimg.cn/833b3dfe2de34550b6cbc466032584a6.png\"></p>\n<h3 id=\"缓冲池Buffer-Pool\"><a href=\"#缓冲池Buffer-Pool\" class=\"headerlink\" title=\"缓冲池Buffer Pool\"></a>缓冲池Buffer Pool</h3><ul>\n<li>既可用于输入又可用于输出的公用缓冲池<ul>\n<li><p>空(闲)缓冲区</p>\n<ul>\n<li>空缓冲队列emq</li>\n</ul>\n</li>\n<li><p>输入数据缓冲区</p>\n<ul>\n<li>输入队列：inq</li>\n</ul>\n</li>\n<li><p>输出数据缓冲区</p>\n<ul>\n<li>输出队列：outq</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"I-x2F-O软件\"><a href=\"#I-x2F-O软件\" class=\"headerlink\" title=\"I&#x2F;O软件\"></a>I&#x2F;O软件</h2><ul>\n<li><p>效率</p>\n<ul>\n<li>解决外部设备与CPU速度不匹配</li>\n<li>提高主机和外设的并行工作能力</li>\n</ul>\n</li>\n<li><p>通用性</p>\n<ul>\n<li>降低用户管理、操作设备的复杂性</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/1239e41c06dc405b879092448843e8b2.png\"></p>\n<p>* </p>\n<h3 id=\"中断的工作方式\"><a href=\"#中断的工作方式\" class=\"headerlink\" title=\"中断的工作方式\"></a>中断的工作方式</h3><p> </p>\n<ul>\n<li><p><img src=\"https://img-blog.csdnimg.cn/062a39b4640b4eb48e6886fc1cbaddf6.png\"> </p>\n</li>\n<li><p>设备驱动程序</p>\n</li>\n<li><pre><code>* I/O进程与设备控制器之间的通信程序，常以进程的形式存在。\n     检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。\n    接收上层软件发来的抽象I/O要求，转换为具体指令后，发送给设备控制器；\n         例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。\n    将由设备控制器发来的信号传送给上层软件。\n</code></pre>\n</li>\n<li><p>设备独立性（设备无关性）</p>\n<ul>\n<li><p>应用程序独立于具体使用的物理设备。</p>\n</li>\n<li><p>应用程序：逻辑设备</p>\n</li>\n<li><p>系统执行：物理设备</p>\n</li>\n<li><p>映射关系</p>\n<p><code>设备灵活分配，I/O重定向</code></p>\n</li>\n<li><p>设备独立性软件</p>\n<ul>\n<li><p>执行所有设备的公有操作</p>\n<ul>\n<li>设备的分配与回收；</li>\n<li>将逻辑设备名映射为物理设备名；</li>\n<li>提供独立于设备的数据逻辑组织方式；</li>\n<li>对设备进行保护，禁止用户直接访问设备；</li>\n<li>缓冲管理；</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li><p>向用户层提供统一接口</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑设备表</p>\n<ul>\n<li>LUT，Logical Unit Table</li>\n<li>系统共享一张表或用户各一张表</li>\n<li><img src=\"https://img-blog.csdnimg.cn/0f1f3a28a19f49a69613838c87f327d0.png\"></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"设备分配\"><a href=\"#设备分配\" class=\"headerlink\" title=\"设备分配\"></a>设备分配</h2><ul>\n<li><p>设备固有属性</p>\n<p><code>独占，共享，虚拟</code></p>\n</li>\n<li><p>分配算法</p>\n</li>\n<li><p>分配的安全性</p>\n</li>\n</ul>\n<h3 id=\"设备分配算法\"><a href=\"#设备分配算法\" class=\"headerlink\" title=\"设备分配算法\"></a>设备分配算法</h3><ul>\n<li><p>先来先服务</p>\n<p><code>当有多个进程对同一设备提出I/O请求时，根据诸进程对某设备提出请求的先后次序进行分配。</code></p>\n</li>\n<li><p>优先级高者优先</p>\n<p><code>在进程调度中优先权高的进程优先获得处理机。如果对这种高优先权进程所提出的I/O请求也赋予高优先权，有助于这种进程尽快完成。</code></p>\n</li>\n</ul>\n<h3 id=\"SPOOLing：假脱机操作\"><a href=\"#SPOOLing：假脱机操作\" class=\"headerlink\" title=\"SPOOLing：假脱机操作\"></a>SPOOLing：假脱机操作</h3><p><strong>简介</strong></p>\n<ul>\n<li>为缓和CPU与I&#x2F;O设备速度矛盾而引入了脱机输入、脱机输出技术。</li>\n<li>一道程序模拟脱机输入时的外围控制机功能，把低速I&#x2F;O设备上的数据传送到高速磁盘上；</li>\n<li>一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。</li>\n<li>在联机情况下实现的同时外围操作称为：SPOOLing (Simultaneous Peripheral Operating On Line)→假脱机操作。</li>\n</ul>\n<p> </p>\n<p><strong>组成</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/93be2630d3d04ae2862fbb0293b58087.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/1241fa2dd60b4f72bd56d1636770a426.png\"></p>\n<ul>\n<li><p>输入井和输出井</p>\n<ul>\n<li>磁盘上的两个存储空间。</li>\n<li>输入井：模拟脱机输入时的磁盘，用于暂存I&#x2F;O设备输入的数据；</li>\n<li>输出井：模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</li>\n</ul>\n</li>\n<li><p>输入缓冲区和输出缓冲区。</p>\n<ul>\n<li>输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。</li>\n<li>输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。</li>\n</ul>\n<p> </p>\n</li>\n<li><p>输入进程SPi和输出进程SPo。</p>\n<ul>\n<li>SPi：模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区送到输入井，当CPU需要输入数据时，直接从输入井读入内存；</li>\n<li>SPo：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<p><strong>特点</strong></p>\n<ul>\n<li><p>提高I&#x2F;O速度</p>\n<ul>\n<li>将对低速I&#x2F;O设备的操作→对输入&#x2F;输出井中数据的存取，缓和了CPU与低速I&#x2F;O设备之间速度不匹配的矛盾。</li>\n</ul>\n</li>\n<li><p>将独占设备改造为共享设备</p>\n<ul>\n<li>并未给任何进程分配设备，只是在输入井或输出井中为进程分配一个存储区。</li>\n</ul>\n</li>\n<li><p>实现了虚拟设备功能</p>\n<ul>\n<li>宏观上，虽然是多个进程在同时使用一台独占设备，对于每一个进程而言，都认为自己独占了一个设备。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"设备管理：调度与实例\"><a href=\"#设备管理：调度与实例\" class=\"headerlink\" title=\"设备管理：调度与实例\"></a>设备管理：调度与实例</h1><h2 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h2><h3 id=\"基本概念-6\"><a href=\"#基本概念-6\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>包括一或多个物理盘片(platter)，每个磁盘片分一个或两个存储面(surface)</p>\n<p>每个磁盘面被组织成若干个同心环，这种环称为磁道(track)</p>\n<p>每条磁道逻辑上划分成若干个扇区(sectors)</p>\n<p>不同盘面相同的磁道成为柱面(cylinder)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c64f0f4a9ef24de89c968fe9ca136d5e.png\"></p>\n<h3 id=\"磁盘结构\"><a href=\"#磁盘结构\" class=\"headerlink\" title=\"磁盘结构\"></a>磁盘结构</h3><ul>\n<li>磁盘驱动器采用线性逻辑块编址</li>\n<li>逻辑块是最小传输单位（512B）</li>\n<li>线性逻辑块号一一映射到扇区<ul>\n<li>扇区0：最外层柱面第一个磁道的第一个扇区</li>\n<li>排序规则：按同磁道→同柱面其它磁道→其它柱面的顺序对扇区排序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"地址转换\"><a href=\"#地址转换\" class=\"headerlink\" title=\"地址转换\"></a>地址转换</h3><p>操作系统逻辑块：b 磁盘三维坐标：(柱面i，磁头j，扇区k)</p>\n<p>若：s扇区&#x2F;磁道，t磁道&#x2F;柱面，则：</p>\n<p>b&#x3D;(s×t×i) + (s×j) + k&#x3D;s×(t×i+j) + k</p>\n<p>i&#x3D;b&#x2F;(s×t) j&#x3D;(b mod (s×t))&#x2F;s</p>\n<p>k&#x3D;(b mod (s×t)) mod s&#x3D;?</p>\n<hr>\n<h2 id=\"连接方式\"><a href=\"#连接方式\" class=\"headerlink\" title=\"连接方式\"></a>连接方式</h2><p><img src=\"https://img-blog.csdnimg.cn/139419cb0ccc450d9f729398a34ce338.png\"></p>\n<h3 id=\"DAS：磁盘挂载\"><a href=\"#DAS：磁盘挂载\" class=\"headerlink\" title=\"DAS：磁盘挂载\"></a>DAS：磁盘挂载</h3><ul>\n<li><p>本地挂载→I&#x2F;O总线</p>\n<ul>\n<li>IDE, ATA, SATA, USB, Fibre Channel, SCSI</li>\n</ul>\n</li>\n<li><p>主机控制器(Host Controller)→Bus→磁盘控制器(Disk Controller)</p>\n</li>\n<li><p>IDE(Integrated Drive Electronics)：4</p>\n</li>\n<li><p>SCSI(Small Computer System Interface)：16</p>\n</li>\n<li><p>FC (Fiber Channel): 126</p>\n</li>\n</ul>\n<h3 id=\"NAS：网络挂载\"><a href=\"#NAS：网络挂载\" class=\"headerlink\" title=\"NAS：网络挂载\"></a>NAS：网络挂载</h3><ul>\n<li><p>Network-Attached Storage</p>\n</li>\n<li><p>主机通过网络挂载存储设备</p>\n<ul>\n<li>NFS，CIFS</li>\n</ul>\n</li>\n<li><p>主机和存储设备之间通过RPC(remote procedure calls)通信</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/757b0c309e364428b493c41fc3a3cfa2.png\"></p>\n<h3 id=\"SAN：存储区域网\"><a href=\"#SAN：存储区域网\" class=\"headerlink\" title=\"SAN：存储区域网\"></a>SAN：存储区域网</h3><ul>\n<li><p>Storage Area Network</p>\n<ul>\n<li>分离server-client通信与server-storage数据</li>\n</ul>\n</li>\n<li><p>大规模数据存储</p>\n</li>\n<li><p>多台主机连接到多个存储阵列</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c0ecd18eef514518933d4b7643a23268.png\"></p>\n<hr>\n<h2 id=\"磁盘访问\"><a href=\"#磁盘访问\" class=\"headerlink\" title=\"磁盘访问\"></a>磁盘访问</h2><h3 id=\"访问模式\"><a href=\"#访问模式\" class=\"headerlink\" title=\"访问模式\"></a>访问模式</h3><ul>\n<li><p>直接（随机）存取：存取磁盘上任一物理块，不依赖于该物理块所处的位置</p>\n<ul>\n<li>固定头磁盘：每个磁道设置一个磁头，变换磁道时不需要磁头的机械移动，速度快但成本高</li>\n<li>移动头磁盘：一个盘面只有一个磁头，变换磁道时需要移动磁头，速度慢但成本低</li>\n</ul>\n</li>\n<li><p>顺序存取：只有在前面的物理块被访问过之后，才能存取后续的物理块的内容。</p>\n<ul>\n<li>磁带</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"访问时间\"><a href=\"#访问时间\" class=\"headerlink\" title=\"访问时间\"></a>访问时间</h3><h3 id=\"寻道时间\"><a href=\"#寻道时间\" class=\"headerlink\" title=\"寻道时间\"></a>寻道时间</h3><ul>\n<li>磁头移动到指定柱面&#x2F;磁道上所经历的时间。是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和：<img src=\"https://latex.codecogs.com/gif.latex?T_%7Bs%7D=s&plus;mn\" alt=\"T_{s}=s+mn\">。 m：常数，与磁盘驱动器的速度有关。 一般磁盘，m&#x3D;0.2；高速磁盘，m≤0.1；s≈2 ms；一般温盘，Ts≈5～30 ms。</li>\n</ul>\n<h3 id=\"传输时间\"><a href=\"#传输时间\" class=\"headerlink\" title=\"传输时间\"></a>传输时间</h3><ul>\n<li>磁头进行读写数据所经历的时间。 Tt与每次所读&#x2F;写的字节数b和旋转速度有关: r：磁盘转速；N为一条磁道上的字节数</li>\n<li><img src=\"https://latex.codecogs.com/gif.latex?T_%7Bt%7D=%5Cfrac%7Bb%7D%7BrN%7D\" alt=\"T_{t}=\\frac{b}{rN}\"></li>\n</ul>\n<h3 id=\"旋转-延迟时间\"><a href=\"#旋转-延迟时间\" class=\"headerlink\" title=\"(旋转)延迟时间\"></a>(旋转)延迟时间</h3><ul>\n<li>指定扇区移动到磁头下所经历的时间。 不同的磁盘类型中，旋转速度差别很大。（软盘为300 rpm，硬盘一般为5400～7200 rpm）如硬盘旋转速度为15 000 rpm，每转需4 ms，平均旋转延迟时间Tr为： 2 ms</li>\n<li>**[(60&#x2F;<em>1000)&#x2F;15000]&#x2F;2&#x3D;2</em>*</li>\n</ul>\n<h3 id=\"总访问时间\"><a href=\"#总访问时间\" class=\"headerlink\" title=\"总访问时间\"></a><strong>总访问时间</strong></h3><ul>\n<li>寻道时间和旋转延迟与所读&#x2F;写数据量无关，却占据了大部分访问时间。</li>\n<li>寻道时间和旋转延迟时间平均20ms，磁盘传输速率为10 MB&#x2F;s，如果要传输10 KB的数据 ，访问时间为21 ms。</li>\n<li>当传输100 KB数据时，访问时间也只是30 ms ；数据量增大10倍，访问时间只增加约50%。</li>\n<li>启发：**数据连续存储，有利于提高传输效率。 **</li>\n</ul>\n<h2 id=\"磁盘调度\"><a href=\"#磁盘调度\" class=\"headerlink\" title=\"磁盘调度\"></a>磁盘调度</h2><p><strong>先来先服务（FCFS）</strong></p>\n<p><strong>最短寻道时间优先（SSTF）</strong></p>\n<p><strong>扫描算法（SCAN, CSCAN）</strong></p>\n<p><strong>Look &amp; C-Look算法</strong></p>\n<p><strong>其它</strong></p>\n<h3 id=\"先来先服务（FCFS）\"><a href=\"#先来先服务（FCFS）\" class=\"headerlink\" title=\"先来先服务（FCFS）\"></a>先来先服务（FCFS）</h3><p>根据进程请求访问磁盘的先后次序进行调度。</p>\n<p>优点：公平、简单</p>\n<p>缺点：未对寻道进行优化，平均寻道时间可能较长</p>\n<h3 id=\"最短寻道时间优先（SSTF）\"><a href=\"#最短寻道时间优先（SSTF）\" class=\"headerlink\" title=\"最短寻道时间优先（SSTF）\"></a>最短寻道时间优先（SSTF）</h3><p>SSTF，Shortest Seek Time First</p>\n<p>优先调度与当前磁头所在的磁道距离最近的请求</p>\n<p>问题：磁道黏着（距离远的请求饥饿）</p>\n<h3 id=\"扫描算法（SCAN-CSCAN）\"><a href=\"#扫描算法（SCAN-CSCAN）\" class=\"headerlink\" title=\"扫描算法（SCAN, CSCAN）\"></a>扫描算法（SCAN, CSCAN）</h3><p><strong>SCAN</strong></p>\n<p>按照同一方向执行SSFT，直到尽头，结束后反向执行</p>\n<p>似曾相识？→ 电梯调度算法Elevator algorithm</p>\n<p><img src=\"https://img-blog.csdnimg.cn/25ebdda6b12046d489bfa00441724a86.png\"></p>\n<p><strong>CSCAN</strong></p>\n<p>SCAN的问题：单向扫描过程中刚越过的磁道来了请求，一个来回才能处理。</p>\n<p>CSCAN: Circular SCAN 单向扫描，迅速返回，再次同一单向扫描。</p>\n<p>将磁道视为环形结构 请求延迟将从：2T→T + Smax</p>\n<p>（T：单向扫描所有磁道的寻道时间 Smax：磁头从最内和最外层迅速切换的时间）</p>\n<h3 id=\"Look-amp-C-Look算法\"><a href=\"#Look-amp-C-Look算法\" class=\"headerlink\" title=\"Look &amp; C-Look算法\"></a>Look &amp; C-Look算法</h3><p>类似SCAN和CSCAN</p>\n<p>在朝一个给定方向移动前先look是否有请求</p>\n<p>磁头只移动到最远的请求为止，接着马上回头。</p>\n<h3 id=\"⭐练习题\"><a href=\"#⭐练习题\" class=\"headerlink\" title=\"⭐练习题\"></a>⭐练习题</h3><p>一磁盘有200个磁道，请求序列： 98, 183, 37, 122, 14, 124, 65, 67。读写头起始位置：53， 给出FCFS，SSTF，SCAN&#x2F;Look（磁头→0），CSCAN&#x2F;CLOOK（磁头→max）的寻道序列。</p>\n<p><strong>FCFS</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2249ebdd19484e669a6a477563a0f29e.png\"></p>\n<p><strong>SSTF</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/bd09907a471446ec8e19105e168a683a.png\"></p>\n<p><strong>SCAN&#x2F;Look（磁头→0）</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a718dfff0bdf4aaf8c56cb8be80c88b8.png\"></p>\n<p><strong>CSCAN&#x2F;CLOOK（磁头→max）</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d2e1078eaea543fd91f05d31ae802958.png\"></p>\n<p><strong>CLOOK</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/23f5ab4c1fc84cee9fb0393997069086.png\"></p>\n<h3 id=\"改进方法\"><a href=\"#改进方法\" class=\"headerlink\" title=\"改进方法\"></a>改进方法</h3><ul>\n<li><p>上述方法只考虑空间信息，可能导致磁头黏着</p>\n<ul>\n<li>如：几个进程高频访问固定磁道</li>\n</ul>\n</li>\n<li><p>考虑时间信息</p>\n<ul>\n<li>N-step-SCAN</li>\n<li>FSCAN</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><h3 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h3><p>利用内存中的存储空间来暂存从磁盘中一系列盘块的信息。</p>\n<p>逻辑上属于磁盘，物理上驻留在内存中的盘块。</p>\n<h3 id=\"读写性能\"><a href=\"#读写性能\" class=\"headerlink\" title=\"读写性能\"></a>读写性能</h3><p><img src=\"https://img-blog.csdnimg.cn/05ad7047490c49b8aaee92a00efad137.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4f48a3960cf2453b836a4d9f967fce3c.png\"> </p>\n<h3 id=\"磁盘管理-1\"><a href=\"#磁盘管理-1\" class=\"headerlink\" title=\"磁盘管理\"></a><strong>磁盘管理</strong></h3><ul>\n<li><p>低级&#x2F;物理格式化(Low-level formatting, or physical formatting): 将磁盘划分为扇区，以便磁盘控制器(disk controller)可以读写磁盘</p>\n</li>\n<li><p>操作系统需在磁盘上记录数据结构才能存储数据</p>\n<ul>\n<li>分区(Partition)：按照柱面划分</li>\n<li>逻辑格式化：建立文件系统</li>\n</ul>\n</li>\n<li><p>引导块启动系统</p>\n</li>\n</ul>\n<h3 id=\"RAID\"><a href=\"#RAID\" class=\"headerlink\" title=\"RAID\"></a>RAID</h3><p>RAID 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;嵌套</p>\n<p>**评价 **</p>\n<p>Redundant Array of Independent&#x2F;Inexpensive Disk</p>\n<p>独立&#x2F;廉价冗余磁盘冗余阵列</p>\n<p>不同配置，不同编号</p>\n<p>优点：可靠性高（n个9）、磁盘I&#x2F;O速度高、性价比高 </p>\n<p><img src=\"https://img-blog.csdnimg.cn/51c8521a1ac3455b84140e07748f4e8a.png\"></p>\n<p><strong>RAID 0</strong></p>\n<p>条带化：并行交叉存取→提高磁盘I&#x2F;O速度</p>\n<p>无冗余、校验功能→可靠性一般 </p>\n<p><img src=\"https://img-blog.csdnimg.cn/6986c63ddde94e10b3301ed6486019de.png\"></p>\n<p><strong>RAID 1</strong></p>\n<p>镜像冗余 无校验</p>\n<p>写性能差 存储开销大 可靠性高</p>\n<p><img src=\"https://img-blog.csdnimg.cn/183cb9228ab949ba86829408adf8deab.png\"></p>\n<p><strong>RAID 2</strong></p>\n<p>具有专用汉明码奇偶校验的位级条带化</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a1dbf318b7242f895720694ac326b54.png\"></p>\n<p><strong>RAID 3</strong></p>\n<p>用一个校验盘（奇偶校验）<br><img src=\"https://img-blog.csdnimg.cn/e8446f8594e1441198f9b91ec202d962.png\"></p>\n<p><strong>RAID 4</strong></p>\n<p>和RADI3相比较，RAID4基于大的块校验</p>\n<p>校验位于同一盘→瓶颈</p>\n<p><img src=\"https://img-blog.csdnimg.cn/cf9dc7b6d594477189400cd339230414.png\"></p>\n<p><strong>RAID 5</strong></p>\n<p>校验结果螺旋分布</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7f0b6584a9f34384acbf610c61b68da3.png\"></p>\n<p><strong>嵌套RAID</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b40ec6313fcd4c8993d9d180cfbc4252.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c0165a77f82f41acbcd38a5213ec6d9d.png\"></p>\n","feature":true,"text":"第三部分 存储器管理目录 前言 存储器管理 ​ 概述 ​ 存储管理 ​ 存储系统的结构 ​ 程序的诞生 ​ 空间分类 ​ 地址映射 ​ 程序链接的方式 ​ 静态链接 ​ 装入时动态链接 ​ 运行时动态链接 ​ 程序装入的方式 ​ 程序装入的两类三种方法 ​ 绝对装入 ​ 静态重定...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"复习笔记","slug":"复习笔记","count":5,"path":"api/categories/复习笔记.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第三部分   存储器管理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">存储器管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">存储管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">存储系统的结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%9E%E7%94%9F\"><span class=\"toc-text\">程序的诞生</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B4%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">空间分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">地址映射</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">程序链接的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">静态链接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">装入时动态链接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">运行时动态链接</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">程序装入的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%A4%E7%B1%BB%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">程序装入的两类三种方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5\"><span class=\"toc-text\">绝对装入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">静态重定位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%88%9A\"><span class=\"toc-text\">动态重定位√</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%82%B9\"><span class=\"toc-text\">关键点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D\"><span class=\"toc-text\">存储器管理：连续分配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D\"><span class=\"toc-text\">单一连续分配</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">分区管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\"><span class=\"toc-text\">固定分区分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">[放置算法（分配算法）]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D\"><span class=\"toc-text\">动态分区分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">常用分区分配算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">[最先适配算法]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">[循环最先适配算法]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">[最佳适配算法]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%9D%8F%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">[最坏适配算法]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">[伙伴系统]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%EF%BC%9A%E7%B4%A7%E5%87%91-x2F-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">[碎片问题：紧凑&#x2F;动态重定位]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">动态分区分配算法总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96\"><span class=\"toc-text\">覆盖</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">实例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2-x2F-%E5%AF%B9%E6%8D%A2\"><span class=\"toc-text\">交换&#x2F;对换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E7%B2%92%E5%BA%A6\"><span class=\"toc-text\">交换粒度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%A6%86%E7%9B%96%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">交换与覆盖的比较</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A6%BB%E6%95%A3%E5%88%86%E9%85%8D\"><span class=\"toc-text\">存储器管理：离散分配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">页式存储管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">[分页逻辑地址结构]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">[基本页式存储管理]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">[地址变换机构]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">页式存储中的重定位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%AD%90%E9%87%8D%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">⭐重点计算方法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">具有快表的地址变换机构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E8%A1%A8\"><span class=\"toc-text\">[快表]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">计算页表存储空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8\"><span class=\"toc-text\">两级和多级页表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">[例题]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8\"><span class=\"toc-text\">反置页表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">页式存储小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段式存储管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%84%E4%BB%B7\"><span class=\"toc-text\">[评价]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">段式地址变换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%EF%BC%88%E7%B1%BB%E4%BC%BC%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%EF%BC%89\"><span class=\"toc-text\">分配（类似动态分区）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">与分页的比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段页式存储管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">基本思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-1\"><span class=\"toc-text\">地址映射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">地址变换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">地址变换实例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">虚拟存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4\"><span class=\"toc-text\">基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">局部性原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">虚拟内存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F\"><span class=\"toc-text\">虚拟页式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-1\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">请求分页</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-2\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">内存分配、置换策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-3\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86\"><span class=\"toc-text\">缺页中断处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8-x2F-%E6%8A%96%E5%8A%A8\"><span class=\"toc-text\">系统颠簸&#x2F;抖动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E9%9B%86\"><span class=\"toc-text\">工作集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">地址变换过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%AE%B5%E9%A1%B5%E5%BC%8F\"><span class=\"toc-text\">虚拟段页式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">分段的共享与保护</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第四部分 \t设备管理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80-1\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">设备管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#I-x2F-O%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">I&#x2F;O系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">设备使用特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87\"><span class=\"toc-text\">数据传输速率</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">数据传输单位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%85%B1%E4%BA%AB%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">设备共享属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">设备控制器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#I-x2F-O%E9%80%9A%E9%81%93\"><span class=\"toc-text\">I&#x2F;O通道</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">I&#x2F;O控制方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8FI-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">程序I&#x2F;O控制方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">中断方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88DMA%EF%BC%89\"><span class=\"toc-text\">直接存储器访问（DMA）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">缓冲管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E7%BC%93%E5%86%B2Single-Buffer\"><span class=\"toc-text\">单缓冲Single Buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E7%BC%93%E5%86%B2Double-Buffer\"><span class=\"toc-text\">双缓冲Double Buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2Circular-Buffer\"><span class=\"toc-text\">循环缓冲Circular Buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E6%B1%A0Buffer-Pool\"><span class=\"toc-text\">缓冲池Buffer Pool</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#I-x2F-O%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">I&#x2F;O软件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">中断的工作方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D\"><span class=\"toc-text\">设备分配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">设备分配算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SPOOLing%EF%BC%9A%E5%81%87%E8%84%B1%E6%9C%BA%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">SPOOLing：假脱机操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%9A%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">设备管理：调度与实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">磁盘存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">磁盘结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">地址转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">连接方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DAS%EF%BC%9A%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD\"><span class=\"toc-text\">DAS：磁盘挂载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NAS%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8C%82%E8%BD%BD\"><span class=\"toc-text\">NAS：网络挂载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SAN%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91\"><span class=\"toc-text\">SAN：存储区域网</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">磁盘访问</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">访问模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">访问时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">寻道时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">传输时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%8B%E8%BD%AC-%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">(旋转)延迟时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">总访问时间</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">磁盘调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89\"><span class=\"toc-text\">先来先服务（FCFS）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89\"><span class=\"toc-text\">最短寻道时间优先（SSTF）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88SCAN-CSCAN%EF%BC%89\"><span class=\"toc-text\">扫描算法（SCAN, CSCAN）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Look-amp-C-Look%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Look &amp; C-Look算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%AD%90%E7%BB%83%E4%B9%A0%E9%A2%98\"><span class=\"toc-text\">⭐练习题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">改进方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">磁盘管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">磁盘缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">读写性能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-1\"><span class=\"toc-text\">磁盘管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RAID\"><span class=\"toc-text\">RAID</span></a></li></ol></li></ol></li></ol>","author":{"name":"涛","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic_source/44/ff/3d/44ff3d6bd2819d524facfcc33205d4cd.jpg","link":"/","description":"一位Computer Science的学生","socials":{"github":"https://github.com/Blizzard-cyber","twitter":"","stackoverflow":"https://stackoverflow.com/users/17709435/blizzard","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wan-meng-ci-yi-xi","csdn":"https://blog.csdn.net/qq_55751352?spm=1010.2135.3001.5343","juejin":"https://juejin.cn/user/1289054417332301","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"计算机操作系统复习笔记（一）","uid":"36aa3041fb4e01bf3bb1e7de215967c2","slug":"OSreview1","date":"2023-03-16T14:27:01.000Z","updated":"2023-03-16T14:31:14.945Z","comments":true,"path":"api/articles/OSreview1.json","keywords":null,"cover":"https://picx.zhimg.com/v2-ab4d2e1f84d9a3d9cd65d7894164bcea_1440w.jpg?source=172ae18b","text":"第一部分 操作系统概述目录 前言 操作系统概述 ​ 操作系统的目标与功能 ​ 操作系统的定义 ​ 目标 ​ 功能 ​ 操作系统的历史 ​ 单用户系统 ​ 简单批处理系统 ​ 多道批处理系统 ​ 分时系统 ​ 个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → …… ​...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"复习笔记","slug":"复习笔记","count":5,"path":"api/categories/复习笔记.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}],"author":{"name":"涛","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic_source/44/ff/3d/44ff3d6bd2819d524facfcc33205d4cd.jpg","link":"/","description":"一位Computer Science的学生","socials":{"github":"https://github.com/Blizzard-cyber","twitter":"","stackoverflow":"https://stackoverflow.com/users/17709435/blizzard","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wan-meng-ci-yi-xi","csdn":"https://blog.csdn.net/qq_55751352?spm=1010.2135.3001.5343","juejin":"https://juejin.cn/user/1289054417332301","customs":{}}},"feature":true}}