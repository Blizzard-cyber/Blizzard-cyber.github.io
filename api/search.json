[{"id":"0a3e10a3d062b222add6594e3cd0bf1b","title":"计算机操作系统复习笔记（二）","content":"第三部分   存储器管理目录\n前言\n存储器管理\n​\t\t概述\n​\t\t\t\t存储管理\n​\t\t\t\t存储系统的结构\n​\t\t\t\t程序的诞生\n​\t\t\t\t空间分类\n​\t\t\t\t地址映射\n​\t\t程序链接的方式\n​\t\t\t\t静态链接\n​\t\t\t\t装入时动态链接\n​\t\t\t\t运行时动态链接\n​\t\t程序装入的方式\n​\t\t\t\t程序装入的两类三种方法\n​\t\t\t\t绝对装入\n​\t\t\t\t静态重定位\n​\t\t\t\t动态重定位√\n​\t\t\t\t关键点\n存储器管理：连续分配\n​\t\t单一连续分配\n​\t\t分区管理\n​\t\t\t\t固定分区分配\n​\t\t\t\t\t\t        [放置算法（分配算法）]\n​\t\t\t\t动态分区分配\n​\t\t\t\t常用分区分配算法\n​\t\t\t\t\t\t        [最先适配算法]  \n​\t\t\t\t\t\t        [循环最先适配算法]  \n​\t\t\t\t\t\t        [最佳适配算法]  \n​\t\t\t\t\t\t        [最坏适配算法]\n​\t\t\t\t\t\t        [伙伴系统]\n​\t\t\t\t\t\t        [碎片问题：紧凑&#x2F;动态重定位]\n​\t\t\t\t动态分区分配算法总结 \n​\t\t覆盖\n​\t\t\t\t基本概念\n​\t\t\t\t实例\n​\t\t\t\t缺点\n​\t\t交换&#x2F;对换\n​\t\t\t\t基本概念\n​\t\t\t\t交换粒度 \n​\t\t\t\t优缺点\n​\t\t\t\t交换与覆盖的比较\n存储器管理：离散分配\n​\t\t页式存储管理\n​\t\t\t\t基本概念\n​\t\t\t\t\t\t        [分页逻辑地址结构]\n​\t\t\t\t\t\t        [基本页式存储管理]\n​\t\t\t\t\t\t        [地址变换机构]\n​\t\t\t\t页式存储中的重定位\n​\t\t\t\t⭐重点计算方法：\n​\t\t\t\t具有快表的地址变换机构\n​\t\t\t\t\t\t        [快表]\n​\t\t\t\t计算页表存储空间\n​\t\t\t\t两级和多级页表\n​\t\t\t\t\t\t        [例题]\n​\t\t\t\t反置页表\n​\t\t\t\t页式存储小结\n​\t\t段式存储管理\n​\t\t\t\t基本概念\n​\t\t\t\t\t\t        [评价]\n​\t\t\t\t段式地址变换\n​\t\t\t\t分配（类似动态分区）\n​\t\t\t\t与分页的比较\n​\t\t段页式存储管理\n​\t\t\t\t基本思想\n​\t\t\t\t地址映射\n​\t\t\t\t地址变换\n​\t\t地址变换实例\n虚拟存储器 \n​\t\t基本概念\n​\t\t\t\t局部性原理\n​\t\t\t\t虚拟内存\n​\t\t虚拟页式\n​\t\t\t\t请求分页\n​\t\t\t\t内存分配、置换策略\n​\t\t\t\t缺页中断处理\n​\t\t\t\t系统颠簸&#x2F;抖动\n​\t\t\t\t工作集\n​\t\t页面替换&#x2F;置换算法 \n​\t\t\t\t最佳算法（OPT）\n​\t\t\t\t先进先出算法(First in First Out，FIFO)\n​\t\t\t\t最近最久未使用算法(LRU, Least Recently Used)\n​\t\t\t\tClock算法\n​\t\t\t\t改进Clock算法\n​\t\t\t\t其他置换算法\n​\t\t\t\t练习题\n​\t\t\t\t编辑\n​\t\t虚拟段式\n​\t\t\t\t请求分段\n​\t\t\t\t地址变换过程\n​\t\t虚拟段页式\n​\t\t\t\t分段的共享与保护 \n总结\n\n前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：\n\nCM1****：操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。\nCM2****：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。\nCM3****：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。\nCM4****：设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。\nCM5****：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。\n\n本节要点在CM3，大致内容如下：\n第三章 存储器管理（14 学时，多媒体课件结合板书面授）CM3\n1、主要内容操作系统存储管理的需求分析；现代计算机系统的多级存储体系；存储划分技术；分区、动态分区分配算法；伙伴系统；分页&#x2F;分段存储管理；段页式存储管理技术。对换技术。虚拟存储器的基本概念，请求分页存储管理，请求分段存储管理，虚拟存储的软件策略：驻留集管理、页面获取、页面放置、页面置换算法、负载控制。2、应达到的要求\n记忆：多级存储体系结构、程序的装入和链接。理解：存储器管理相关技术、虚拟存储器的基本概念。\n应用：重定位与地址转换、分区存储管理、动态分区分配算法、交换技术、分页存储管理、各种页面置换算法、分段存储管理。\n分析：段页式存储管理、虚拟存储管理技术。\n本节涉及到4个PPT，分四个大块叙述。\n\n存储器管理\n概述存储管理定义\n\n主要是指对内存储器的管理\n在多道程序环境之中，多个作业需共享内存资源，内存紧张的问题依然突出\n存储管理是操作系统的重要组成部分，能否合理有效地利用内存在很大程度上影响着整个计算机的性能。\n\n主要目的\n\n提高资源的利用率，尽量满足多个用户对内存的要求；\n方便用户使用内存，不必考虑作业具体放在哪块区域。\n\n应实现的主要功能\n\n分配和回收\n共享\n保护\n扩充\n\n存储系统的结构\n程序的诞生**从源代码 → 可以在内存中运行的程序 **\n\n编译\n​\t由编译程序（Compiler）将用户源代码编译成若个目标模块\n\n链接\n​\t由链接程序（Linker）将目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块\n\n装入\n​\t由装入程序（Loader）将装入模块装入内存。\n\n\n\n \nC语言的过程：预处理、编译、汇编、链接、加载\n空间分类名空间：代码里的变量名（个人理解）\n\n用汇编语言或高级语言编写程序时，用符号名来访问某一单元。\n程序中由符号名组成的程序空间称为符号名空间，简称名空间。\n\n逻辑空间：汇编时分配的地址（个人理解）\n\n源程序经过编译形成目标程序，每个目标程序都以0为基址顺序进行编址，原来用符号名访问的单元用具体的数据——单元号取代。\n这样生成的目标程序占据一定的地址空间，称为逻辑地址空间，简称逻辑空间。\n在逻辑空间中每条指令的地址和指令中要访问的操作数地址统称为逻辑地址。\n\n内存空间（物理空间）：加载入内存运行时的实际地址（个人理解）\n\n内存由若干存储单元组成，每个存储单元有一个编号，这种编号可惟一标识一个存储单元，称为内存地址（或物理地址）。\n\n内存地址的集合称为内存地址空间（或物理地址空间），简称内存空间（或物理空间）。\n\n内存空间编号示例：\n​\t一维线性空间，编址顺序为0，1，2，3，…… n-1，n的大小由实际组成存储器的存储单元个数决定。 比如，64K内存的空间编号为0，1，2，3，……65535。\n​\t（64K=2^6/*2^10=2^16；空间地址为[0, 2^16-1]=[0, 65535]）\n\n\n空间的关系\n\n\n地址映射\n将逻辑地址转换为运行时机器直接寻址的物理地址。\n当程序装入内存时，操作系统要为该程序分配具体的内存空间。\n由于程序的逻辑地址与内存物理地址未必一致，CPU执行指令按物理地址进行的，要进行地址转换。\n重定位(relocation)\n\n\n\n\n\n\n程序链接的方式\n源程序经过编译后，可得到一组目标模块，再利用链接程序将目标模块链接形成装入模块：模块拼接\n根据链接时机不同，链接分为三种：\n静态链接(Static Linking)\n动态链接(Dynamic Linking)\n装入时动态链接(Load-time Dynamic Linking)\n运行时动态链接(Runtime Dynamic Linking)\n\n\n\n\n\n静态链接\n在(编译)链接阶段(程序运行之前)，将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。\n相对地址的修改\n变换外部调用符号\n\n\n\n\n个人理解：提前（静态）装入不需要额外的算力，装入后程序运行稳定\n装入时动态链接\n目标模块在装入内存时，采用边装入边链接的链接方式，装入后不再链接。\n各目标模块分开存放，便于修改和更新。\n便于目标模块的共享\n静态链接：每个装入模块都含有其目标模块的拷贝，无法实现对目标模块的共享。\n装入时动态链接：OS可将一个目标模块链接到多个装入模块上，实现多个应用程序对该模块的共享。\n\n\n\n\n\n个人理解：装入再装可以同时给多个装，达到共享、便于修改的目的\n运行时动态链接\n在程序执行中需要该目标模块时，由OS找到该模块，将其装入内存，并把它链接到调用者模块上。\n\n执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。\n​\t加快程序的装入\n​\t节省内存空间\n​\t共享\n\n\n个人理解：运行再装可以灵活选自己需要的装入，节约内存，加快运行速度，还能共享模块\n\n程序装入的方式地址重定位：模块载入位置（可能伴随链接）\n程序装入的两类三种方法\n绝对装入\n编译时完成\n\n可重定位装入\n加载时执行，静态地址重定位\n运行时执行，动态地址重定位\n\n\n绝对装入\n固定地址重定位，编译时知道进程在内存中的驻留地址，生成绝对代码，即在可执行文件中记录内存地址，装入时直接定位在该内存地址。\n程序地址空间和内存地址空间一一对应\n如果开始地址发生变化，必须重新编译代码\n优点：装入过程简单\n缺点：不灵活，不适于多道程序系统\n\n静态重定位\n目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成物理内存地址。\n\n当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换。\n\n优点\n​\t易实现，无需硬件支持\n\n缺点\n\n程序重定位后就不能移动，因而不能重新分配内存，不利于内存的有效利用。\n程序在存储空间中只能连续分配，不能分布在内存的不同区域。\n难于共享\n\n\n\n动态重定位√\n程序装入内存时，不修改逻辑地址，在访问物理内存之前，再实时地将逻辑地址转换成物理地址。\n\n优点\n\n程序不必连续存放在内存中，可分散存储，可移动；\n便于共享；\n有利于紧缩、碎片问题的解决。\n\n\n缺点\n\n需要硬件支持，实现存储管理的算法比较复杂。\n主流方式\n\n\n\n关键点绝对装入和静态重定位\n\n符号解析 + 地址重定位：紧耦合\n\n动态重定位\n\n符号解析→地址重定位：松耦合\n链接和装载动作的交织\n\n \n\n存储器管理：连续分配存储器管理分为三大方式：连续分配、离散分配、虚拟存储器。\n\n单一连续分配基本思想\n\n整个内存空间分成系统区和用户区，系统区给操作系统使用，用户区给用户使用。\n用户区分配给一个进程\n\n适用场合\n\n最简单，适用于单用户、单任务OS\n\n优点\n\n易于管理\n\n缺点\n\n对内存空间需求少的程序，造成内存浪费；\n程序全部装入，很少使用的程序部分也占用内存。\n\n\n分区管理基本原理\n\n把内存分为一些大小相等或不等的分区；\n每个应用进程占用一个分区，操作系统占用一个分区。\n\n特点\n\n适用于多道程序系统和分时系统\n\n问题\n\n内部碎片：占用分区之内未被利用的空间\n外部碎片：占用分区之间难以利用的空闲分区\n难以进行内存分区的共享。\n\n固定分区分配\n把内存分为大小相等或不等的分区(partition)\n\n分区的划分一般由系统管理员或操作系统决定，一旦划定，在整个执行过程中不变\n\n特点\n适用于多道程序系统和分时系统\n支持多个程序并发执行\n\n问题\n难以进行内存分区的共享\n碎片 等大小分区和不等大小分区\n\n\n[放置算法（分配算法）]当一个进程装入或换入主存中时，如果存储器中有多个足够大的空闲分区，放置算法确定分配哪个自由块。\n\n等大小分区\n\n只要有一个可用分区，进程就可以装入该分区\n如果所有分区都被占满了，须换出一个进程\n一个程序可能太大而不能放到一个分区中\n\n\n不等大小分区\n\n方法1：每个分区一个调度队列，将每个进程指定到适应它的最小分区。\n\n内部碎片最小\n缺点：一段时间没有大尺寸程序到来，小程序排队，大空间闲置。\n\n\n方法2：所有进程一个队列。\n\n当需要把一个进程装入主存时，选择可以保存该进程的最小的可用分区。\n如果所有分区都已被占据，须进行交换。\n\n\n\n\n优点：\n\n比单一连续分配方法，内存利用率提高了\n可以支持多道程序\n实现简单\n\n\n缺点：\n\n分区的数目在系统生成时确定，限制了系统中活跃进程的数目\n小作业的内部碎片可能比较大\n作业须预先能够估计要占用的内存空间\n\n\n\n\n动态分区分配在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。\n\n优点\n\n没有内部碎片\n\n\n缺点\n\n外部碎片\n\n\n分区分配算法\n\n寻找空闲分区，需大等于程序的要求。\n若大于要求，则将该分区进行分割，分别标记为“占用”和 “空闲”。\n\n\n分区释放算法\n\n将相邻的空闲分区合并成一个空闲分区。\n\n\n优点\n\n实现了主存共享，有助于多道程序设计；\n主存利用率比固定分区高；\n实现存储保护的措施比较简单。\n\n\n缺点\n\n外部碎片→ 主存利用率低；\n一个作业执行前必须全部装入主存。\n\n\n\n常用分区分配算法\n最先适配算法  \n循环最先适配算法  \n最佳适配算法  \n最坏适配算法\n\n[最先适配算法]\n算法思想\n\n按分区地址排序，从头查找，找到符合要求的第一个分区。\n\n\n算法实质\n\n尽可能利用存储区低地址空闲区，尽量在高地址部分保存较大空闲区，以便一旦有分配大空闲区要求时，容易得到满足。\n空闲区按地址顺序组织\n\n\n\n\n\n优点\n分配简单，合并相邻空闲区也比较容易\n\n缺点\n查找总是从表首开始，前面空闲区被分割的很小时，满足分配要求的可能性较小，**查找次数较多**。  \n\n解决方法\n对最先适配法稍加改进 → 循环最先适配法。 \n\n\n[循环最先适配算法]\n算法思想\n按分区先后次序，**从上次分配的分区起查找**（到最后分区时再回到开头），找到符合要求的第一个分区\n\n特点\n​\t算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。\n​\t空闲区按顺序组织\n\n\n[最佳适配算法]\n算法思想\n​\t在所有大等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。\n\n算法实现\n空闲区从小到大顺序组织\n\n\n\n\n优点\n\n较大的空闲分区可以被保留\n\n\n缺点\n\n空闲区按大小而不是按地址顺序排列，因此释放时，要在整个链表上搜索地址相邻的空闲区，合并后，插入到合适的位置。\n\n\n\n \n[最坏适配算法]\n算法思想\n\n分区时取所有空闲区中最大的一块，必要时拆分形成2个块，一个选用，一个形成新空闲块。\n\n\n算法实现\n\n空闲区按由大到小排序\n\n\n\n\n\n优点\n\n分配时，只需查找一次，就可成功，分配算法很快。\n\n\n缺点\n\n最后剩余分区会越来越小，无法运行大程序\n\n\n\n \n[伙伴系统]\n按照页面组织为块（2的k次幂个页面）\n申请时对半拆分，直到能够容纳申请量，空闲的放入新队列\n释放回收时合并：尺寸相同\n速度快，但利用率不高\n\n\n[碎片问题：紧凑&#x2F;动态重定位]\n碎片问题\n\n经过一段时间分配、回收后，内存中存在很多很小的空闲块。\n每一个都很小，不足以满足分配要求；\n但其总和满足分配要求→存储资源浪费。\n\n\n解决方法\n\n紧凑技术\n\n在内存移动程序，将所有小的空闲区合并为大空闲区域\n系统开销大\n\n\n离散分配方式\n\n\n\n\n\n\n动态分区分配算法总结\n\n覆盖基本概念\n一个程序的几个代码段或数据段，按照时间先后占用公共的内存空间\n将程序的必要部分代码和数据常驻内存；\n可选部分在独立模块中，平时存放在外存中（覆盖文件），需要时才装入到内存；\n不存在调用关系的模块不必同时装入到内存，可相互覆盖。\n\n\n\n实例\n注：不存在调用关系的模块才可以相互覆盖！\n覆盖不需要OS提供特殊的支持，但程序员必须适当地设计和编写覆盖结构。\n缺点\n编程时必须划分程序模块和确定程序模块之间的覆盖关系 → 增加编程复杂度。\n从外存装入覆盖文件，以时间换空间。\n\n\n交换&#x2F;对换基本概念多个程序并发执行：\n将暂时不能执行的程序换出到外存中，从而获得空闲内存空间来装入新程序；\n或读入保存在外存中而目前到达就绪状态的进程到内存中。\n交换粒度\n整体交换\n\n也称为进程交换，交换是以整个进程为单位\n\n\n部分交换\n\n也称为页面交换、分段交换，是分页、分段交换的基础，目的是为了支持虚拟存储系统\n\n\n对换空间的管理\n\n对换区一般采用连续分配\n对换区比普通文件区侧重于对换速度\n\n\n\n优缺点\n优点\n\n增加并发程序数量，并给用户提供适当的响应时间；\n编写程序时不影响程序结构\n\n\n缺点\n\n换入和换出的控制增加处理机开销\n时间换空间\n\n\n\n交换与覆盖的比较覆盖技术主要用在早期的操作系统中；\n交换技术被广泛用于分时系统中，导致了虚存技术的出现；\n覆盖发生在无调用关系程序段之间；\n交换技术对程序段之间的逻辑关系无要求；\n交换发生在进程或作业之间；\n覆盖发生在同一进程或作业内。\n\n存储器管理：离散分配连续分配一次性分配所有，不灵活\n碎片问题：紧凑方式消耗系统开销\n离散分配 分页、分段、段页\n\n页式存储管理基本概念用户空间划分：用户程序按逻辑页划分成大小相等的部分，称为页（虚页） 从0开始编制页号，页内地址相对于0编址。\n逻辑空间划分由系统自动完成的，对用户透明。 一般页大小为2的整数次幂，因此，地址的高位部分为页号，低位部分为页内地址。\n[分页逻辑地址结构]页内地址：长度由页大小决定；\n页号：除去页内地址所占的高位部分。\n例：逻辑地址为32位，页大小为4KB，则逻辑地址的低12位（2^12&#x3D;4KB），为页内地址w，而高20位为页号p，地址结构如下：\n\n[基本页式存储管理]\n内存空间划分\n\n按页的大小划分为大小相等的区域，称为内存块（物理页面，页框、实页）→ frame\n从0开始编号\n\n\n内存分配\n\n以页为单位进行分配\n\n内部碎片 → 最后一页的页内碎片\n外部碎片？\n\n\n逻辑上相邻的页，物理上不一定相邻；反之亦然。\n\n\n\n\n[地址变换机构]\n页表 page table\n\n逻辑页号→物理块号的映射。\n\n\n基本地址变换机构\n\n每个进程拥有一个页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。\n\n页表在内存，属于进程的现场信息(内核)。\n\n\n\n**⭐描述：将逻辑地址的页号取出和页表始址搭配找到页表中对应的块号，将块号取出和页内地址拼接成物理地址，如此循环，直到取出的逻辑地址页号大于页表长度，越界中断。 **\n页式存储中的重定位例题：\n一个系统，内存容量共256KB，页框大小为1KB，共256块，编号为0～255。 第0～4块为操作系统所使用； 现有2个用户作业，作业1和作业2，其逻辑地址空间分别占2KB和2.5KB； 进入系统后，按块的大小划分分别占2页和3页。\n\n\n\n* \n⭐重点计算方法：\n计算页号：逻辑地址&#x2F;页框大小；\n页号 → 物理块号\n页内偏移：逻辑地址%页框大小。 \n物理地址：物理块号&#x2F;*页框大小+页内偏移\n\n \n具有快表的地址变换机构页表访存：二次 访页表 操作数据 \n[快表]\n局部性：Locallity\n高速缓冲存储器，存放当前作业的最常用的页号和与之相应的物理块号。\n快表或联想存储器\nTranslation Lookaside Buffer （后备&#x2F;后援缓冲）\nAssociative Mapping（unordered）\n\n\n\n\n⭐描述：查找过的就放在快表里，拿到逻辑地址先找快表里，没有的话就输入快表再查页表，随后拼接页内地址即可\n** **\n练习：\n有一页式系统，其页表存放在主存中： 对主存的一次存取需要1.5μs，问实现一次页面访问的存取时间是多少? 如果系统有快表，平均命中率为85%，当页表项在快表中时，其查找时间忽略，问此时的平均存取时间是多少?\n无快表主存存取访问时间：1.5&#x2F;*2&#x3D;3μs\n增加快表后的存取访问时间： 0.85&#x2F;*1.5+(1-0.85)&#x2F;*2&#x2F;*1.5&#x3D;1.725μs\n计算页表存储空间页表也在内存，也需要按页存储\n例子：\n32位系统；页面大小：4K；页表项（页号记录）：4B；问：一个进程的页表需要多少存储空间？\n\n64位系统；页表项：8B；问：当页面大小为4K和1M时，一个进程的页表需要多少存储空间？\n\n4K：264&#x2F;4K &#x2F;* 8B&#x3D;255B&#x3D;32P\n1M：264&#x2F;1M &#x2F;* 8B&#x3D;247B&#x3D;128T\n\n \n两级和多级页表两级页表\n\n逻辑地址结构：\n32位地址空间；页面大小4K；页表项4B\n如何计算每一层的位数？每页表项数宽度\n\n\n\n\n**二级页表查找过程 **\n\n注意：页号是用来索引页表的，页表里存储的都是内存块号。 \n \n计算：\n64位系统；页面大小：4KB；页表项：8B；计算：2级页表存储空间；3级页表存储空间；至少设置几级页表才合理？（一级页表在一页内存储）\n\n2级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第2级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第2级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第1级页表项数量：2^43 第1级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 页表空间：(2^43+2^34) &#x2F;* 4K&#x3D;(2^13+2^4) &#x2F;* 4T&#x3D;32832T≈32.8P\n3级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第3级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第3级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第2级页表项数量：2^43 第2级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 第1级页表项数量：2^34 第1级页表项所需页面数量：2^34&#x2F;2^9&#x3D;2^25个 页表空间：(2^43+2^34+2^25) &#x2F;* 4K&#x3D;(2^23+2^14+2^5) &#x2F;* 4G&#x3D;…\n几级页表: 每页页表项数量：2^9 每9位切一刀 1次访存→7次访存 ⌈(64−12)&#x2F;9⌉⇒⌈(位数−页内偏移)&#x2F;每级别页号位数⌉⇒⌈log_2页面总数&#x2F;log_2页内表项数⌉\n\n \n多级页表令总空间增加，但通过按需装载，节省了内存空间。\n \n评价：物理空间小，逻辑空间大。\n页表大小∝逻辑空间大小\n物理内存变化速度&lt;&lt;逻辑空间\n[例题]某24位存储系统采用页式管理，页表分为两级，存储在主存中。每个页面1KB，每个页表项占4B，某进程的页表内容如下图所示（图中数字全部为10进制）。请计算逻辑地址526245（十进制）对应的物理地址。\n\n解答：\n每个进程的总页面数为224B&#x2F;1KB&#x3D;214个，每个页面可存储页表项1KB&#x2F;4B&#x3D;256&#x3D;28个，存储二级页表所需要的页面数为：214&#x2F;28&#x3D;26个&lt;28个，则一级页表可以在一个页面内存储完成。\n526245对应的二进制表示（斜线表示上述逻辑切分）：10&#x2F;00 0000 01&#x2F;11 1010 0101\n按照上述划分方法得到：一级页号为2，二级页号1，页内地址0x03A5。  \n一级页表第2项查找到二级页表的物理块号：678\n在678物理块的第1项找到物理块号889（0x0379），形成物理地址块号\n与页内地址0x03A5拼接，形成完整的地址：\n1101 1110 01&#x2F;11 1010 0101→0xDE7A5（十进制：911269） \n反置页表\n物理块→逻辑块\n\n也称为页寄存器（Page Register）\n\n每个内存块关联：\n\n使用位(Residence bit): 本页是否被占用\n使用者(Occupier): 占用此块的页号\n进程号\n\n\n优点：存储开销小；页表大小与逻辑空间无关；全系统一张表\n\n缺点：反向关联信息（页框号→页号），如何正向查询？\n\n\n \n哈希算法：\n哈希运算：h(PID, 页号)→页框号\n查询过程 计算h(p, i)，并作为索引访问反置页表；\n获取反置页表项；\n如果匹配(pid, 页号)，命中；\n否则，不命中。\n\n页式存储小结\n优点：\n\n解决了碎片问题\n便于管理\n\n\n缺点：\n\n页表的开销大\n共享不便，保护不便：语义边界不清晰\n\n\n\n \n\n段式存储管理每个段可有其逻辑意义及功能，使得便于：编写程序、分段共享、分段保护、动态链接、动态增长。\n基本概念用户空间划分\n\n按程序自身逻辑关系划分为若干段，如代码段、数据段。\n\n可针对不同类型段采取不同的保护\n以段为单位共享，包括通过动态链接进行代码共享\n\n\n每个程序段都有一个段名，且有一个段号\n\n段号从0开始，段内从0开始编址\n\n段内地址是连续的\n\n\n\n内存空间划分\n\n内存空间被动态划分为若干个长度不等的区域，这些区域被称为物理段：(起始地址，长度)\n\n内存分配\n\n以段为单位分配内存，每一个段在内存中占据连续空间\n各段之间可以不连续存放\n\n \n进程段表\n\n段号，段的首址和长度之间的关系。\n\n每一个程序设置一个段表，放在内存，属于进程的现场信息\n\n\n\n\n\n\n[评价]优点\n\n分段对程序员是可见的，是一种方便的组织程序和数据的手段，便于模块化程序设计\n便于保护和共享\n\n缺点\n\n进程全部装入内存\n\n段式地址变换\n\n分段系统**共享editor **\n分配（类似动态分区）\n系统段表\n\n系统内所有占用段\n\n\n空闲段表\n\n记录空闲段起始地址和长度，可以结合到系统段表中\n\n\n内存分配算法\n\n首先适配；最佳适配；最坏适配\n\n\n\n与分页的比较\n分页是出于系统管理的需要，分段是出于用户应用的需要。\n一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n页大小是系统固定的，而段大小则通常不固定。\n逻辑地址表示： 分页是一维的：引用时是统一的地址； 分段是二维的，与程序逻辑一致：引用时段名+偏移；\n通常段比页大，因而段表比页表短，查找快，提高访问速度。\n段式管理碎片问题比页式管理严重\n与动态分区不同：一个程序可以占据多个段，段不要求连续。\n\n\n段页式存储管理分页优点：提高内存利用率\n分段优点：方便用户，易于共享，保护，动态链接\n段页式系统：综合优点\n基本思想\n用户程序按段式划分\n\n内存页式存储管理方案\n\n内存分配：以页为单位进行分配\n\n对用户而言，仍然是二维编址。\n对系统而言，则是三维编址\n\n\n\n\n\n地址映射\n\n\n\n地址变换\n\n\n\n地址变换实例\n练习：设一个地址空间有8个页，每个页面大小为1024个字节，映射到32块物理页面的主存上。试问：\n逻辑地址要用多少位表示？13\n物理地址要用多少位表示？15 \n答：\n逻辑地址：8&#x2F;*1024&#x3D;2^3&#x2F;*2^10&#x3D;2^13（所以逻辑地址的后13位为“页内地址”，又叫“页内偏移量”，或“页内位移”及有效位）\n再算物理地址：32&#x2F;*1024&#x3D;2^5&#x2F;*2^10&#x3D;2^15\n所以最后的就是逻辑有效位是13；物理有效位是15.\n\n虚拟存储器允许执行只有部分在内存中的程序\n程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作\n提高程序执行的并发性、CPU利用率\n\n基本概念常规存储器的问题\n\n常规存储\n\n一次性，驻留性\n覆盖和交换可以减轻这一限制\n\n\n有时，并不需要将整个程序放入内存中\n\n程序中的异常分支\n数组通常分配了比实际所需要更多的内存\n程序的某些选项或特点可能很少使用\n\n\n\n虚拟存储器的目标\n\n允许执行只有部分在内存中的程序\n程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作\n提高程序执行的并发性、CPU利用率\n\n局部性原理\n程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。\n\n时间局部性（Temporal Locality）\n\n如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。\n\n\n空间局部性（Spatial Locality）\n\n若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。\n\n\n\n虚拟内存\n具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。\n\n逻辑容量由内存容量和外存容量之和所决定\n\n运行速度接近于内存速度\n成本接近于外存\n\n\n原理\n\n在程序装入时，只需将当前需要执行的部分读入内存，就可让程序开始执行。\n在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入内存，然后继续执行程序。\n另一方面，操作系统将内存中暂时不用的页或段调出保存在外存上，腾出空间存放将要调入的页或段。\n\n\n虚拟内存大于物理内存\n\n实现方法\n\n虚拟页式——请求分页(Demand Page)\n虚拟段式——请求段式调度(Demand Segmentation)\n虚拟段页式\n\n\n\n\n虚拟页式在简单页式存储管理的基础上，增加请求调页和页面置换功能。\n请求分页页表：与简单分页相比，增加了如下位：\nP：表示该页是否在内存中\nA：访问位，是否被访问过\nM：修改位，从上次装入到现在是否已经改变\n外存地址\n\n地址转换流程\n\n内存分配、置换策略分配策略：固定分配，可变分配\n置换策略：全局置换，局部置换\n可组合出以下三种适用的策略：\n\n固定分配局部置换(Fixed Allocation, Local Replacement)\n可变分配全局置换(Variable Allocation, Global Replacement)\n可变分配局部置换(Variable Allocation, Local Replacement)\n\n缺页中断处理\n要访问的页不在内存，则产生缺页中断(page fault)。\n\n操作系统接到此中断信号后，调用缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去\n\n如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号\n若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存\n\n \n\n缺页中断在指令执行期间产生和处理，所缺的页面调入之后，重新执行被中断的指令。\n\n\n\n系统颠簸&#x2F;抖动\n页面被频繁地换入换出\n缺页率急剧增加，内存有效存取时间加长，系统吞吐量骤减；\n系统已基本不能完成什么任务。\n原因：CPU利用率太低→调度程序增加多道程序度→新进程启动运行→内存不足→缺页→I&#x2F;O忙碌，CPU空闲。\n\n防止系统颠簸&#x2F;抖动\n局部置换策略：如果一个进程出现抖动，它不能从另外的进程取帧。\n挂起某些进程：优先级低、缺页进程、最大的进程等\n利用工作集、缺页频率策略防止抖动\n\n\n\n \n工作集\n一个进程在某一段时间内访问页面的集合。（并非越大越好！）\n\n如果页面正在使用，它就落在工作集中；\n\n如果不再使用，它将不出现在相应的工作集中，所以，工作集是程序局部性的近似表示。\n\n工作集：W(t, Δt)，(t-Δt, t] 内访问的页面集合。\n\n虚拟时间t：页面访问点\n\n时间窗口Δt\n太小，不能包含整个局部；\n太大，是进程执行所碰到的所有页的集合。\n\n避免抖动方法\n\n* OS监视每个进程的工作集\n    新增页面分配内存。\n     淘汰不在工作集中的页面。\n* 若有足够多的额外内存块，就可装入另一个进程。\n* 如果所有工作集之和超过了可用内存，则OS选择挂起一个进程，把它的页换出，将其内存块分配给其它进程。\n* 工作集的估算不容易：Δ\n\n  \n\n----\n\n## 页面替换&#x2F;置换算法 \n\n### 最佳算法（OPT）\n\n选择替换下次访问距当前时间最长的那些页。\n\n**特点**\n\n* 缺页错误率最低，没有Belady现象；\n* 必须知道页面未来的访问顺序→不可能实现。\n* 仅作为一种标准，用于测试其他算法的性能。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;49d19dc276a64b7c98c7dc7db67718da.png)\n\n###\n\n### 先进先出算法(First in First Out，FIFO)\n\n替换驻留在主存中时间最长的页\n\n注意：驻留时间和访问时间无关\n\n实现：将分配给进程的页帧看作FIFO队列，按循环方式移动页：置换队列的首页，调入的新页加入队尾。\n\n问题：FIFO策略实现简单，但性能相对较差。\n\nBelady异常：有些情况下，缺页率可能会随着所分配帧数的增加而增加。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;8328e3d7516e45f3b2f875ae8db1cdc0.png)\n\n**练习：**\n\n页面请求序列：3 2 1 0 3 2 4 3 2 1 0 4 分别计算使用FIFO算法，分配3个Frame和4个Frame时产生page fault的次数。\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;535d087a40d8476a84039c0d04a111f7.png)\n\n###\n\n### 最近最久未使用算法(LRU, Least Recently Used)\n\n替换主存中上次使用距离当前最远的页（最长时间没有使用的页）\n\n可以理解为向后看最优置换算法：根据局部性原理，这也是最近最不可能访问到的页。\n\n性能接近OPT，但历史不等于未来\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3b867617b8664ab2b6dc3d10621fd6f3.png)\n\n* 实现：\n  * 计数器：每个页添加逻辑时钟或计数器，访问页面时加1，定时减1（或寄存器移位）。在淘汰时，选择该值最小的页面。\n    * 比较开销\n\n  * 堆栈：页面被访问，该页就从堆栈中提到顶部，底部是目前最少使用的页。 \n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;5301e7250b004634b1606b06a121f676.png) \n\n###\n\n### Clock算法\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3f0c1f1398a045b88e9e7caffd730dad.png)\n\n \n\n### 改进Clock算法\n\n增加修改位M\n\n由(A, M)可以组合成四种页面：\n\n(A&#x3D;0, M&#x3D;0)：表示该页最近既未被访问，又未被修改， 是最佳淘汰页。\n\n(A&#x3D;0, M&#x3D;1)：表示该页最近未被访问，但已被修改，若替换要被写回。\n\n(A&#x3D;1, M&#x3D;0)：最近已被访问，但未被修改，该页有可能再被访问。\n\n(A&#x3D;1, M&#x3D;1)：最近已被访问且被修改，该页可能再被访问。\n\n**步骤：**\n\n从指针所指示的当前位置开始，扫描循环队列， 寻找(A&#x3D;0, M&#x3D;0)的第一类页面，将遇到的第一个页面作为淘汰页，如未找到，转第2步；\n\n同样扫描方法，寻找(A&#x3D;0, M&#x3D;1)的第二类页面，将遇到的第一个此类页面作为淘汰页。将所有扫描过的页面的访问位A置0。若未找到，转第1步。 \n\n### 其他置换算法\n\n* 最不经常使用算法LFU(Least Frequently Used)\n  * 访问频繁→访问记数大\n    * 例外：一个页在进程开始时使用得很多，但以后就不再使用\n\n  * 定期将次数寄存器右移一位，形成指数衰减\n  * 关注访问次数，LRU关注上次访问时间\n\n* 最常使用算法MFU(Most Frequently Used)\n  * 最小次数的页可能刚刚调进来，且还没有使用，不换出\n\n* 页面缓冲算法PBA(Page Buffering Algorithm)\n  * 维护一个free page pool\n  * 换出页可稍后换出，避免调入时换出写磁盘\n\n\n### 练习题\n\n### ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;67b6ee9cc3014221acc063325d8e3a28.png)\n\n----\n\n## 虚拟段式\n\n### 请求分段\n\n* 在简单段式存储管理的基础上，增加请求调段和段置换功能。\n* 段表添加若干项：\n\n* &#96;&#96;&#96;\n  * 存在位(present bit)\n  * 修改位(modified bit&#x2F;dirty bit)\n  * 访问&#x2F;使用位(use bit)\n  * 存取权限：如读R，写W，执行X\n  * 外存地址\n  \n\n![](https://img-blog.csdnimg.cn/d181f61270374258a323bc0fc7966233.png)\n\n\n动态地址变换和缺段中断：指令和操作数必定不会跨越在段边界上\n\n程序运行时，先把当前需要的一段或者几段装入内存，其它段仅仅在调用时才装入。\n\n\n\n\n地址变换过程\n\n虚拟段页式\n虚拟段页式：虚拟页式和虚拟段式存储管理的结合，存储管理的分配单位是：段，页\n逻辑地址的组成：段号，页号，页内偏移地址，程序员可见的仍是段号和段内相对地址。\n地址变换：先查段表，再查该段的页表。缺段中断和缺页中断。\n\n分段的共享与保护\n共享段表：整个系统一张\n\n共享进程计数，存取控制字段。\n段号：不同进程可以使用不同的段号共享段。\n\n\n\n\n\n\n总结存储器管理部分告一段落，本章主要任务就是理解一些概念，重点在于熟练运用各种算法进行计算，例如重定位、地址变换、计算页表存储空间、页面置换算法等。 \n第四部分 \t设备管理目录\n前言\n设备管理\n​\t\tI&#x2F;O系统\n​\t\t\t\t基本概念\n​\t\t\t\t设备使用特性\n​\t\t\t\t数据传输速率\n​\t\t\t\t数据传输单位\n​\t\t\t\t设备共享属性\n​\t\t\t\t设备控制器\n​\t\t\t\tI&#x2F;O通道\n​\t\tI&#x2F;O控制方式\n​\t\t\t\t程序I&#x2F;O控制方式\n​\t\t\t\t中断方式\n​\t\t\t\t直接存储器访问（DMA） \n​\t\t缓冲管理\n​\t\t\t\t单缓冲Single Buffer\n​\t\t\t\t双缓冲Double Buffer\n​\t\t\t\t循环缓冲Circular Buffer\n​\t\t\t\t缓冲池Buffer Pool\n​\t\tI&#x2F;O软件\n​\t\t\t\t中断的工作方式\n​\t\t设备分配\n​\t\t\t\t设备分配算法\n​\t\t\t\tSPOOLing：假脱机操作\n设备管理：调度与实例 \n​\t\t磁盘存储器\n​\t\t\t\t基本概念\n​\t\t\t\t磁盘结构\n​\t\t\t\t地址转换\n​\t\t连接方式\n​\t\t\t\tDAS：磁盘挂载\n​\t\t\t\tNAS：网络挂载\n​\t\t\t\tSAN：存储区域网\n​\t\t磁盘访问\n​\t\t\t\t访问模式\n​\t\t\t\t访问时间\n​\t\t\t\t寻道时间\n​\t\t\t\t传输时间\n​\t\t\t\t(旋转)延迟时间\n​\t\t\t\t总访问时间\n​\t\t磁盘调度\n​\t\t\t\t先来先服务（FCFS）\n​\t\t\t\t最短寻道时间优先（SSTF）\n​\t\t\t\t扫描算法（SCAN, CSCAN）\n​\t\t\t\tLook &amp; C-Look算法\n​\t\t\t\t⭐练习题\n​\t\t\t\t改进方法\n​\t\t磁盘管理\n​\t\t\t\t磁盘缓存\n​\t\t\t\t读写性能\n​\t\t\t\t磁盘管理\n​\t\t\t\tRAID\n\n前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：\n\nCM1****：操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。\nCM2****：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。\nCM3****：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。\nCM4****：设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。\nCM5****：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。\n\n本节要点在CM4，大致内容如下：\n第四章 设备管理（8 学时，多媒体课件结合板书面授）CM4\n1、主要内容I&#x2F;O 系统的基本概念和设备分配中的数据结构，I&#x2F;O 控制方式，通道的分类，缓冲管理，磁盘存储管理的调度策略；设备的独立性，虚拟设备，磁盘冗余阵列。2、应达到的要求\n记忆：磁盘冗余阵列、闪存技术。理解：I&#x2F;O 系统的组成，设备的独立性。\n分析: I&#x2F;O 控制方式、缓冲管理、设备分配、设备处理、虚拟设备、磁盘的调度算法。\n\n设备管理I&#x2F;O系统 I&#x2F;O控制方式 缓冲管理 I&#x2F;O软件 设备分配 磁盘存储器的管理\n\nI&#x2F;O系统基本概念从OS观点看，重要的评价、分类指标：\n设备使用特性\n数据传输速率\n数据传输单位\n设备共享属性\n\n\n\n设备使用特性\n存储设备：外存或后备存储器、辅助存储器，计算机系统用以存储信息的主要设备。\n\n存取速度较内存慢，但容量比内存大得多，相对价格也便宜。\n\n\n输入&#x2F;输出设备，具体可分为输入设备、输出设备和交互式设备。\n\n输入设备：用来接收外部信息，如键盘、鼠标、扫描仪、视频摄像、各类传感器等。\n输出设备：用于将计算机加工处理后的信息送向外部的设备，如打印机、绘图仪、显示器、数字视频显示设备、音响输出设备等。\n交互式设备：集成上述两类设备（耳机+耳麦，触屏）\n\n\n\n数据传输速率低速设备：传输速率仅为几个字节&#x2F;s至数百个字节&#x2F;s，键盘、鼠标器、语音的输入和输出等设备。\n中速设备：传输速率在数KB&#x2F;s至数百KB&#x2F;s 行式打印机、 激光打印机等。\n高速设备：传输速率在数十MB&#x2F;s 磁带、磁盘、光盘等。\n数据传输单位\n块设备(Block Device)：信息的存取以数据块为单位\n\n典型的块设备是磁盘，每个盘块的大小为512 B～4 KB。\n传输速率较高，x MB&#x2F;s； 可寻址，支持随机读&#x2F;写；\n常采用DMA方式。\n\n\n字符设备(Character Device)：数据访问基本单位是字符\n\n字符设备的种类繁多，如交互式终端、打印机等。\n传输速率较低，通常为几个字节至数千字节；\n不可寻址，即输入&#x2F;输出时不能指定数据的输入源地址及输出的目标地址\n常采用中断驱动方式。\n\n\n\n设备共享属性\n独占设备\n\n严格独占使用，顺序共享（不存在交叉使用）\n例：打印机\n\n\n共享设备\n\n并发共享，对每一时刻而言，只允许一个进程访问\n例：磁盘\n\n\n虚拟设备\n\n通过虚拟技术将一台独占设备模拟为共享设备，供若干个进程同时使用。\n例：SPOOLing\n\n\n\n \n设备控制器设备与控制器接口\n设备并不是直接与CPU进行通信，而是与设备控制器通信。在该接口中有三种类型的信号，各对应一条信号线。\n\n**设备控制器的组成 **\n\n\n设备控制器与处理机（CPU）的接口\n\n实现CPU与设备控制器之间的通信\n数据线、地址线和控制线\n数据线通常与两类寄存器相连接\n数据寄存器；\n控制&#x2F;状态寄存器\n\n\n\n\n\n\n设备控制器与设备的接口\n\n一个设备控制器可连接一个或多个设备\n多个设备接口，一个接口连接一台设备\n数据、控制和状态三种类型的信号\n\n\n\n\nI&#x2F;O逻辑\n\nI&#x2F;O逻辑用于实现对设备的控制。\n\n通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送I&#x2F;O命令；\n\n\n每当CPU要启动一个设备时\n\n将启动命令发送给控制器； 同时通过地址线把地址发送给控制器\n\n\n\n\n\n\nI&#x2F;O通道\n将CPU从设备控制器中解脱出来\n\n一种特殊的处理机，具有执行I&#x2F;O指令的能力，通过执行通道程序来控制I&#x2F;O操作。\n\n与一般的处理机不同\n\n指令类型单一。由于通道硬件比较简单，其所能执行的命令主要局限于与I&#x2F;O操作有关的指令；\n通道没有自己的内存。通道所执行的通道程序放在主机内存中。\n\n \n\n通道类型\n\n字节多路通道\n按字节交叉方式工作的通道。\n通常含有许多非分配型子通道，其数量可从几十到数百个，每一个子通道连接一台I&#x2F;O设备，并控制该设备的I&#x2F;O操作。\n子通道按时间片轮转方式共享主通道。\n若扫描每个子通道的速率足够快，而连接到子通道上的设备的速率不太高时，便不致丢失信息。 \n实例：子通道A，B，C，D，E，…，N，分别通过控制器各与一台设备相连。 假定这些设备的速率相近，且同时向主机传送数据。 设备A所传送的数据流为A1A2A3…；设备B所传送的数据流为B1B2B3… 这些数据流合成后(通过主通道)送往主机的数据流为A1B1C1D1 …A2B2C2D2 … A3B3C3D3 …\n\n\n\n\n\n\n数组选择通道\n\n字节多路通道不适于连接高速设备→按数组方式进行数据传送的数组选择通道。\n连接多台高速设备，但只含有一个分配型子通道\n在一段时间内只能执行一道通道程序，控制一台设备进行数据传送→当某台设备占用了该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其它设备使用该通道，直至该设备传送完毕释放该通道。\n通道利用率低。\n\n\n数组多路通道\n\n数组多路通道：数组选择通道传输速率高和字节多路通道能使各子通道分时并行操作的优点相结合而形成。\n含有多个非分配型子通道\n被广泛地用于连接多台高、中速的外围设备。\n\n\n\n\nI&#x2F;O通道的瓶颈\n\n通道价格昂贵→通道数量较少→I&#x2F;O的瓶颈→系统吞吐量下降\n\n\n\n\n解决方法：\n\n增加通道\n\n增加设备到主机间的通路而不增加通道：把一个设备连接到多个控制器上，一个控制器连接到多个通道上\n\n\n\n\n\n\n\n总线系统\n\n计算机系统中的各部件都是通过总线来连接的 （时钟频率、带宽、传输速率……）\n\n\n\n\n\nI&#x2F;O控制方式\n程序I&#x2F;O控制方式早期的计算机系统中，无中断机构，处理机对I&#x2F;O设备的控制采取程序I&#x2F;O(Programmed I&#x2F;O)方式，或称为“忙—等待”方式\n\n中断方式\n现代计算机系统广泛采用中断驱动(Interrupt Driven)方式\nCPU→设备控制器发出I&#x2F;O命令，立即返回继续执行原来的任务。\n设备控制器按照该命令的要求控制指定设备。此时，CPU与I&#x2F;O设备并行操作。\n一旦设备操作完成，控制器便通过控制线向CPU发送中断信号；\nCPU向控制器发送取走数据的信号，然后再通过控制器及数据线将数据写入内存指定单元中。\n\n\n直接存储器访问（DMA）中断方式对块设备不适用\n\n例：从磁盘中读1 KB数据，需中断CPU 1K次→减少CPU对I&#x2F;O的干预→直接存储器访问方式\n数据传输的基本单位是数据块；\n所传送的数据是从设备直接送入内存的，或者相反；\n仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。\n\n\nDMA控制器 \n\n组成\n\n主机与DMA控制器的接口\nDMA控制器与块设备的接口\nI&#x2F;O控制逻辑\n\n\n关键寄存器\n\n命令&#x2F;状态寄存器(CR)：接收从CPU发来的I&#x2F;O命令，或有关控制信息，或设备的状态。\n内存地址寄存器(MAR)：数据在内存的起始地址；输入、输出分别为源、目标地址\n数据寄存器(DR)：暂存从设备到内存，或从内存到设备的数据。\n数据计数器(DC)：存放本次CPU要读或写的字节数。\n\n\n\nDMA过程\n\n \n缓冲管理缓和CPU与I&#x2F;O设备间速度不匹配的矛盾。\n减少对CPU的中断频率。\n提高CPU和I&#x2F;O设备之间的并行性。\n缓冲类型：\n\n单缓冲Single Buffer\n双缓冲Double Buffer\n循环缓冲Circular Buffer\n缓冲池Buffer Pool\n\n单缓冲Single Buffer一个缓冲区 max(T, C) + M\n\n双缓冲Double Buffer缓冲对换(Buffer Swapping) max(C, T)\n\n循环缓冲Circular Buffer多个缓冲区；进程同步\n\n缓冲池Buffer Pool\n既可用于输入又可用于输出的公用缓冲池\n空(闲)缓冲区\n\n空缓冲队列emq\n\n\n输入数据缓冲区\n\n输入队列：inq\n\n\n输出数据缓冲区\n\n输出队列：outq\n\n\n\n\n\nI&#x2F;O软件\n效率\n\n解决外部设备与CPU速度不匹配\n提高主机和外设的并行工作能力\n\n\n通用性\n\n降低用户管理、操作设备的复杂性\n\n\n\n\n* \n中断的工作方式 \n\n \n\n设备驱动程序\n\n* I/O进程与设备控制器之间的通信程序，常以进程的形式存在。\n     检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。\n    接收上层软件发来的抽象I/O要求，转换为具体指令后，发送给设备控制器；\n         例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。\n    将由设备控制器发来的信号传送给上层软件。\n\n\n设备独立性（设备无关性）\n\n应用程序独立于具体使用的物理设备。\n\n应用程序：逻辑设备\n\n系统执行：物理设备\n\n映射关系\n设备灵活分配，I/O重定向\n\n设备独立性软件\n\n执行所有设备的公有操作\n\n设备的分配与回收；\n将逻辑设备名映射为物理设备名；\n提供独立于设备的数据逻辑组织方式；\n对设备进行保护，禁止用户直接访问设备；\n缓冲管理；\n差错控制\n\n\n向用户层提供统一接口\n\n\n\n\n\n逻辑设备表\n\nLUT，Logical Unit Table\n系统共享一张表或用户各一张表\n\n\n\n\n\n设备分配\n设备固有属性\n独占，共享，虚拟\n\n分配算法\n\n分配的安全性\n\n\n设备分配算法\n先来先服务\n当有多个进程对同一设备提出I/O请求时，根据诸进程对某设备提出请求的先后次序进行分配。\n\n优先级高者优先\n在进程调度中优先权高的进程优先获得处理机。如果对这种高优先权进程所提出的I/O请求也赋予高优先权，有助于这种进程尽快完成。\n\n\nSPOOLing：假脱机操作简介\n\n为缓和CPU与I&#x2F;O设备速度矛盾而引入了脱机输入、脱机输出技术。\n一道程序模拟脱机输入时的外围控制机功能，把低速I&#x2F;O设备上的数据传送到高速磁盘上；\n一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。\n在联机情况下实现的同时外围操作称为：SPOOLing (Simultaneous Peripheral Operating On Line)→假脱机操作。\n\n \n组成\n\n\n\n输入井和输出井\n\n磁盘上的两个存储空间。\n输入井：模拟脱机输入时的磁盘，用于暂存I&#x2F;O设备输入的数据；\n输出井：模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。\n\n\n输入缓冲区和输出缓冲区。\n\n输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。\n输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。\n\n \n\n输入进程SPi和输出进程SPo。\n\nSPi：模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区送到输入井，当CPU需要输入数据时，直接从输入井读入内存；\nSPo：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。\n\n\n\n \n特点\n\n提高I&#x2F;O速度\n\n将对低速I&#x2F;O设备的操作→对输入&#x2F;输出井中数据的存取，缓和了CPU与低速I&#x2F;O设备之间速度不匹配的矛盾。\n\n\n将独占设备改造为共享设备\n\n并未给任何进程分配设备，只是在输入井或输出井中为进程分配一个存储区。\n\n\n实现了虚拟设备功能\n\n宏观上，虽然是多个进程在同时使用一台独占设备，对于每一个进程而言，都认为自己独占了一个设备。\n\n\n\n\n设备管理：调度与实例磁盘存储器基本概念包括一或多个物理盘片(platter)，每个磁盘片分一个或两个存储面(surface)\n每个磁盘面被组织成若干个同心环，这种环称为磁道(track)\n每条磁道逻辑上划分成若干个扇区(sectors)\n不同盘面相同的磁道成为柱面(cylinder)\n\n磁盘结构\n磁盘驱动器采用线性逻辑块编址\n逻辑块是最小传输单位（512B）\n线性逻辑块号一一映射到扇区\n扇区0：最外层柱面第一个磁道的第一个扇区\n排序规则：按同磁道→同柱面其它磁道→其它柱面的顺序对扇区排序\n\n\n\n地址转换操作系统逻辑块：b 磁盘三维坐标：(柱面i，磁头j，扇区k)\n若：s扇区&#x2F;磁道，t磁道&#x2F;柱面，则：\nb&#x3D;(s×t×i) + (s×j) + k&#x3D;s×(t×i+j) + k\ni&#x3D;b&#x2F;(s×t) j&#x3D;(b mod (s×t))&#x2F;s\nk&#x3D;(b mod (s×t)) mod s&#x3D;?\n\n连接方式\nDAS：磁盘挂载\n本地挂载→I&#x2F;O总线\n\nIDE, ATA, SATA, USB, Fibre Channel, SCSI\n\n\n主机控制器(Host Controller)→Bus→磁盘控制器(Disk Controller)\n\nIDE(Integrated Drive Electronics)：4\n\nSCSI(Small Computer System Interface)：16\n\nFC (Fiber Channel): 126\n\n\nNAS：网络挂载\nNetwork-Attached Storage\n\n主机通过网络挂载存储设备\n\nNFS，CIFS\n\n\n主机和存储设备之间通过RPC(remote procedure calls)通信\n\n\n\nSAN：存储区域网\nStorage Area Network\n\n分离server-client通信与server-storage数据\n\n\n大规模数据存储\n\n多台主机连接到多个存储阵列\n\n\n\n\n磁盘访问访问模式\n直接（随机）存取：存取磁盘上任一物理块，不依赖于该物理块所处的位置\n\n固定头磁盘：每个磁道设置一个磁头，变换磁道时不需要磁头的机械移动，速度快但成本高\n移动头磁盘：一个盘面只有一个磁头，变换磁道时需要移动磁头，速度慢但成本低\n\n\n顺序存取：只有在前面的物理块被访问过之后，才能存取后续的物理块的内容。\n\n磁带\n\n\n\n访问时间寻道时间\n磁头移动到指定柱面&#x2F;磁道上所经历的时间。是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和：。 m：常数，与磁盘驱动器的速度有关。 一般磁盘，m&#x3D;0.2；高速磁盘，m≤0.1；s≈2 ms；一般温盘，Ts≈5～30 ms。\n\n传输时间\n磁头进行读写数据所经历的时间。 Tt与每次所读&#x2F;写的字节数b和旋转速度有关: r：磁盘转速；N为一条磁道上的字节数\n\n\n(旋转)延迟时间\n指定扇区移动到磁头下所经历的时间。 不同的磁盘类型中，旋转速度差别很大。（软盘为300 rpm，硬盘一般为5400～7200 rpm）如硬盘旋转速度为15 000 rpm，每转需4 ms，平均旋转延迟时间Tr为： 2 ms\n**[(60&#x2F;1000)&#x2F;15000]&#x2F;2&#x3D;2*\n\n总访问时间\n寻道时间和旋转延迟与所读&#x2F;写数据量无关，却占据了大部分访问时间。\n寻道时间和旋转延迟时间平均20ms，磁盘传输速率为10 MB&#x2F;s，如果要传输10 KB的数据 ，访问时间为21 ms。\n当传输100 KB数据时，访问时间也只是30 ms ；数据量增大10倍，访问时间只增加约50%。\n启发：**数据连续存储，有利于提高传输效率。 **\n\n磁盘调度先来先服务（FCFS）\n最短寻道时间优先（SSTF）\n扫描算法（SCAN, CSCAN）\nLook &amp; C-Look算法\n其它\n先来先服务（FCFS）根据进程请求访问磁盘的先后次序进行调度。\n优点：公平、简单\n缺点：未对寻道进行优化，平均寻道时间可能较长\n最短寻道时间优先（SSTF）SSTF，Shortest Seek Time First\n优先调度与当前磁头所在的磁道距离最近的请求\n问题：磁道黏着（距离远的请求饥饿）\n扫描算法（SCAN, CSCAN）SCAN\n按照同一方向执行SSFT，直到尽头，结束后反向执行\n似曾相识？→ 电梯调度算法Elevator algorithm\n\nCSCAN\nSCAN的问题：单向扫描过程中刚越过的磁道来了请求，一个来回才能处理。\nCSCAN: Circular SCAN 单向扫描，迅速返回，再次同一单向扫描。\n将磁道视为环形结构 请求延迟将从：2T→T + Smax\n（T：单向扫描所有磁道的寻道时间 Smax：磁头从最内和最外层迅速切换的时间）\nLook &amp; C-Look算法类似SCAN和CSCAN\n在朝一个给定方向移动前先look是否有请求\n磁头只移动到最远的请求为止，接着马上回头。\n⭐练习题一磁盘有200个磁道，请求序列： 98, 183, 37, 122, 14, 124, 65, 67。读写头起始位置：53， 给出FCFS，SSTF，SCAN&#x2F;Look（磁头→0），CSCAN&#x2F;CLOOK（磁头→max）的寻道序列。\nFCFS\n\nSSTF\n\nSCAN&#x2F;Look（磁头→0）\n\nCSCAN&#x2F;CLOOK（磁头→max）\n\nCLOOK\n\n改进方法\n上述方法只考虑空间信息，可能导致磁头黏着\n\n如：几个进程高频访问固定磁道\n\n\n考虑时间信息\n\nN-step-SCAN\nFSCAN\n\n\n\n\n磁盘管理磁盘缓存利用内存中的存储空间来暂存从磁盘中一系列盘块的信息。\n逻辑上属于磁盘，物理上驻留在内存中的盘块。\n读写性能\n \n磁盘管理\n低级&#x2F;物理格式化(Low-level formatting, or physical formatting): 将磁盘划分为扇区，以便磁盘控制器(disk controller)可以读写磁盘\n\n操作系统需在磁盘上记录数据结构才能存储数据\n\n分区(Partition)：按照柱面划分\n逻辑格式化：建立文件系统\n\n\n引导块启动系统\n\n\nRAIDRAID 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;嵌套\n**评价 **\nRedundant Array of Independent&#x2F;Inexpensive Disk\n独立&#x2F;廉价冗余磁盘冗余阵列\n不同配置，不同编号\n优点：可靠性高（n个9）、磁盘I&#x2F;O速度高、性价比高 \n\nRAID 0\n条带化：并行交叉存取→提高磁盘I&#x2F;O速度\n无冗余、校验功能→可靠性一般 \n\nRAID 1\n镜像冗余 无校验\n写性能差 存储开销大 可靠性高\n\nRAID 2\n具有专用汉明码奇偶校验的位级条带化\n\nRAID 3\n用一个校验盘（奇偶校验）\nRAID 4\n和RADI3相比较，RAID4基于大的块校验\n校验位于同一盘→瓶颈\n\nRAID 5\n校验结果螺旋分布\n\n嵌套RAID\n\n\n","slug":"OSreview2","date":"2023-03-16T14:27:01.000Z","categories_index":"复习笔记","tags_index":"OS","author_index":"涛"},{"id":"36aa3041fb4e01bf3bb1e7de215967c2","title":"计算机操作系统复习笔记（一）","content":"第一部分   操作系统概述目录\n前言\n操作系统概述\n​\t\t操作系统的目标与功能\n​\t\t\t操作系统的定义\n​\t\t\t目标\n​\t\t\t功能\n​\t\t操作系统的历史\n​\t\t\t单用户系统\n​\t\t\t简单批处理系统\n​\t\t\t多道批处理系统\n​\t\t\t分时系统\n​\t\t\t个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……\n​\t\t\t实时系统\n​\t\t操作系统的基本特征\n​\t\t\t并发\n​\t\t\t共享\n​\t\t\t虚拟\n​\t\t\t不确定性\n​\t\t操作系统的体系结构\n​\t\t\t无结构操作系统\n​\t\t\t模块化系统结构\n​\t\t\t分层式系统结构\n​\t\t操作系统安全\n​\t\t\t内存\n​\t\t\t信息保护和安全\n\n前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：\n\nCM1：**操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。\nCM2：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。\nCM3：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。\nCM4：设备管理。I&#x2F;O系统结构、缓冲管理、磁盘结构和磁盘调度算法。\nCM5：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。\n\n本节要点在CM1，大致内容如下：\n第一章 计算机操作系统概论（6 学时，多媒体课件结合板书面授） CM1\n1、主要内容批处理技术、多道程序设计技术、操作系统的概念、操作系统的发展、操作系统的基本类型、 操作系统相关的基本概念和特点、操作系统的特征、理解操作系统的服务、操作系统的功能模块、 操作系统的体系结构、系统调用、命令接口、程序接口、虚拟机、客户机&#x2F;服务器等。\n2、应达到的要求记忆：操作系统的体系结构、操作系统的发展及主要类型。\n理解: 操作系统中的基本概念、操作系统的目标和作用、理解用户接口与系统调用的意义和类型。\n应用：批处理技术、多道程序设计技术。分析：操作系统的基本类型、特征、操作系统的功能模块。\n第六章 操作系统安全（2 学时，多媒体课件结合板书面授） CM1\n1、主要内容操作系统安全的概念、安全机制的实施：文件保护机制、身份认证、访问矩阵、访问矩阵的实现。2、应达到的要求\n记忆：安全系统的模型、设计、可信度验证。理解：操作系统安全的概念、安全机制的实施\n应用：文件保护、身份认证、访问矩阵、访问矩阵的实现。\n \n\n操作系统概述\n操作系统的目标与功能操作系统的定义操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。\n\n目标\n方便性：使计算机更易于使用\n有效性：使用计算机资源更加有效\n扩展性：可开发、测试引入新功能\n开放性：应用程序的可移植和互操作\n\n功能\n处理机管理：按照一定的算法把处理机分配给进程（线程），并对其进行有效的管理和控制。\n存储器管理：为多道程序提供运行环境，方便使用，提高存储器利用率以及能从逻辑上扩充内存。\n设备管理：完成用户提出的I&#x2F;O请求；为用户分配其所需的I&#x2F;O设备；提高CPU和I&#x2F;O设备的利用率；提高I&#x2F;O速度；方便用户使用I&#x2F;O设备。\n文件管理：对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。\n用户接口：OS提供给用户交互的命令集合\n\n\n操作系统的历史单用户系统处理机制：\n\n人工操作方式，所有资源用户独占\n脱机输入输出（与外围计算机进行I&#x2F;O）(→优化为简单批处理系统)\n\n简单批处理系统处理机制: 对一批作业进行自动处理，内存中只能存放一道作业，运行结束&#x2F;出错→自动调用另一道作业（自动续接）\n 主要特征: 自动性, 顺序性, 单道性\n 优点: 减少了人工操作, 解决了作业自动续接问题\n 缺点: 平均周转时间太长(处理器一次只能运行一道程序，在进行I&#x2F;O操作时会让处理器陷入等待，利用率仍较低), 没有交互能力(→优化为多道批处理系统)\n多道批处理系统在单道批处理上加以改进：\n\n内存中同时存放多个作业\n当一个作业需要等待I&#x2F;O或运行结束&#x2F;出错时，处理器可以切换到另一个作业(自动调度)\n多个程序可并发执行\n作业调度程序负责作业的调度\n\n主要特征: 多道性, 无序性, 调度性\n 优点: 提高了资源利用率和吞吐能力\n 缺点: 没有交互能力(→优化为分时系统)\n\n分时系统处理机制: 时钟中断: 时间片\n 产生原因:人机交互、共享主机、方便上机\n 主要特征: 多路性, 独立性, 及时性, 交互性\n[与多道批处理系统的比较]\n主要表现在用户交互层面, 用户可以在终端输入指令控制计算机, 而侧重点也有所不同: 多道批处理系统侧重于充分利用处理器, 而分时系统更注重作业效率\n个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → ……​\t\t了解即可, 略\n实时系统定义：\n系统能实时（及时） 相应外部事件的请求，在规定的时间内开始或完成该事件的处理，并控制所有实时任务协调一致的运行\n应用领域：\n航空航天、军事、工业控制、实时控制系统、实时信息系统\n特性:\n多路性、独立性、交互性、可靠性、及时性\n\n操作系统的基本特征\n并发（最重要的特征）\n共享\n虚拟\n不确定性\n\n并发并行性是指两个或多个事件在同一时刻发生。（单处理机系统）\n并发性是指两个或多个事件在同一时间间隔内发生。（多处理机系统）\n共享系统中的资源可供内存中多个并发执行的进程共同使用。\n\n互斥共享方式：\n\n临界资源是在一段时间内只允许一个进程访问的资源\n\n系统中的临界资源可以提供给多个进程使用，但一次仅允许一个进程使用\n\n同时访问方式：\n\n宏观上，资源共享指多个任务可以同时使用系统的软硬件资源\n\n微观上，资源共享指多个任务可以交替互斥的使用系统中的某个资源（例如磁盘）\n\n\n虚拟将物理实体抽象成逻辑产物。（时分[虚拟处理机&#x2F;虚拟设备]、空分[虚拟内存]…）\n不确定性同样的程序，同样的输入，输出结果可能不同。\n\n异步：进程使用异步方式执行，运行速度与结果不可预知。\n随机函数：random(); gettimeofday()……\n\n \n\n操作系统的体系结构操作系统的四代变革：\n\n第一代：无结构操作系统\n第二代：模块式结构\n第三代：层次式结构\n第四代：工程学+软件开发→软件工程学\n\n常见OS整体结构：\n\n无结构操作系统OS是众多过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构，既庞大又杂乱，因此也叫它整体系统结构。\n这样编织出的程序错误很多，调试与维护的成本很高，负担很大。\n模块化系统结构OS包含若干模块，每一模块实现一组基本概念及相关基本属性\n模块之间均可以引用任意其他各块的概念以及属性\n\n优点：\n\n提高了OS设计的正确性、可理解性和可维护性。\n\n增强了OS的可适应性。 加速了OS的开发过程。\n\n缺点：\n\n对模块的划分及对接口的规定要精确描述很困难。\n\n从功能观点来划分模块时，未能将共享资源和独占资源加以区别；\n\n\n分层式系统结构OS包含若干层，每一层实现一组基本概念及相关基本属性\n各层的实现只依赖其直接下层所提供的概念以及属性，并对其上各层隐藏其下各层的存在\n\n操作系统安全内存虚拟存储：\n\n以逻辑方式访问储存器，不考虑物理内存可用的空间数量\n满足多个作业同时驻留内存的需求\n换入换出机制\n分页机制：每个进程的大小可能不同，整体换入换出时大小不匹配\n每个作业部分驻留：硬件检测到缺页时，安排载入\n\n分页机制：\n\n进程由若干个固定大小的块组成，每一块大小相同\n虚地址由页号和内页偏移量组成\n进程中每一页均可置于内存中任何位置\n提供了虚地址和内存中实地址（物理地址）之间的动态映射机制\n\n信息保护和安全\n可用性：保护系统不被中断\n保密性：保证用户不能读取未授权访问的数据\n数据完整性：保护数据不被未授权修改\n认证：涉及用户身份的正确认证和消息或数据的合法\n\n第二部分\t进程与并发控制目录\n前言\n进程管理\n​\t\t进程基本知识\n​\t\t\t\t程序的顺序执行\n​\t\t\t\t前趋图\n​\t\t\t\t程序的并发执行\n​\t\t\t\t并发程序\n​\t\t\t\t进程的定义和特征 \n​\t\t\t\t进程的特征和状态\n​\t\t操作系统内核\n​\t\t\t\t定义\n​\t\t\t\t功能\n​\t\t原语\n​\t\t\t\t原子操作的实现 \n​\t\t操作系统控制结构\n​\t\t\t\t进程控制块PCB\n​\t\t\t\t进程组织（进程树）\n​\t\t\t\t进程的创建\n​\t\t\t\t进程控制函数（fork与exec为主）\n​\t\t\t\t进程的终止\n​\t\t\t\t进程切换\n​\t\t线程\n​\t\t\t\t与进程的区别和联系\n​\t\t\t\t线程的优势\n​\t\t\t\t线程的特点\n​\t\t\t\t线程的状态\n​\t\t\t\t线程的分类\n处理机调度\n​\t\t⭐单处理机调度（重点）\n​\t\t\t\t调度原则\n​\t\t\t\t调度算法：资源分配问题\n​\t\t\t\t先来先服务：FCFS\n​\t\t\t\t短作业优先：SPF&#x2F;SJF\n​\t\t\t\t时间片轮转调度：TSRR\n​\t\t\t\t最短剩余时间调度：SRT\n​\t\t\t\t基于优先权&#x2F;优先级的调度算法\n​\t\t\t\t高响应比优先算法：HRRN\n​\t\t\t\t多级队列调度算法\n​\t\t\t\t多级反馈队列调度：MFQ\n​\t\t\t\t总结\n​\t\t实时调度 \n​\t\t\t\t基本条件\n​\t\t\t\t系统处理能力下界\n​\t\t\t\t实时调度算法\n​\t\t多处理机调度\n​\t\t\t\t分类\n​\t\t\t\t进程分配方式\n​\t\t\t\t单队列多处理机调度\n​\t\t\t\t多队列多处理机调度\n​\t\t\t\t成组调度\n​\t\t\t\t专用处理机分配 \n进程并发控制：互斥与同步\n​\t\t进程&#x2F;线程的并发控制\n​\t\t基本概念\n​\t\t同步的解决策略\n​\t\t\t\t软件方法\n​\t\t\t\t硬件方法\n​\t\t\t\t信号量\n​\t\t\t\t管程\n⭐进程并发控制：信号量的应用（重点）\n​\t\t观察者问题\n​\t\t图书馆问题\n​\t\t公交车问题\n​\t\t⭐生产者&#x2F;消费者问题（重点）\n​\t\t\t\t例题：\n​\t\t\t\t启示\n​\t\t⭐读&#x2F;写者问题（重点）\n​\t\t\t\t读者优先\n​\t\t\t\t写者优先\n​\t\t\t\t公平优先\n​\t\t⭐理发师问题（重点）\n​\t\t⭐哲学家问题（重点）\n​\t\t重点知识点回顾\n​\t进程并发控制：练习题\n​\t\t\t\t问题1\n​\t\t\t\t问题2\n​\t\t\t\t问题3\n​\t\t\t\t问题4\n​\t\t\t\t问题5\n​\t\t\t\t问题6\n​\t\t\t\t问题7\n​\t\t\t\t问题8 \n​\t\t\t\t问题9\n​\t进程间通信\n​\t\t\t\t基本概念\n​\t\t\t\t消息传递\n​\t\t\t\t管道（Pipe）通信\n​\t死锁 \n​\t\t产生死锁的原因\n​\t\t\t\t系统模型\n​\t\t\t\t资源类型\n​\t\t\t\t资源分配图\n​\t\t\t\t\t\t实例\n​\t\t死锁的充要条件 \n​\t\t处理死锁的基本方法 \n​\t\t\t\t死锁预防\n​\t\t\t\t死锁避免\n​\t\t\t\t死锁检测\n​\t\t\t\t死锁解除\n​\t\t\t\t死锁忽略\n\n前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：\n\nCM1：操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。\nCM2：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。\nCM3：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。\nCM4：设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。\nCM5：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。\n\n本节要点在CM2，大致内容如下：\n第二章 进程与并发控制（20 学时，多媒体课件结合板书面授）CM2\n1、主要内容程序顺序执行、程序并发执行、进程的定义与特征、进程的基本状态、进程的挂起状态、进程控制块、进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活。临界资源、临界区、利用软件和硬件解决进程互斥问题、整型信号量机制、记录型信号量机制、信号量集机制、生产者－消费者问题、读者和写者问题、哲学家进餐问题、管程机制、进程通信的类型、直接通信和间接通信方式、消息传递系统中的几个问题、消息缓冲队列通信机制。调度的类型、调度队列模型、调度方式和各种调度算法、产生死锁的原因和必要条件、处理死锁的基本方法、死锁的预防和避免、死锁的检测与解除。进程调度算法。满足实时系统要求时，应选择适合实时系统中的调度算法。线程的概念、线程间的同步和通信、用户线程和内核支持线程的概念。2、应达到的要求\n记忆：进程的分配方式、管程机制。理解：进程的并发执行与控制；实时系统的类型及实时调度算法。线程的概念、线程间的同步和通信、用户线程和内核支持线程的概念。应用：程序的执行、进程的定义与特征、进程的基本状态、进程控制块、操作系统内核、进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活、线程与进程、进程调度算法。 临界资源、临界区、进程互斥问题、信号量的应用。分析：进程调度和死锁、处理死锁的基本方法。进程（线程）的调度算法、生产者&#x2F;消费者\n问题、读者和写者问题、哲学家进餐问题。\n\n进程管理\n进程基本知识程序的顺序执行程序执行有固定的时序\n特征：顺序性、封闭性、可再现性\n前趋图\n有向无循环图\n\n表示方式：\n\np1→p2\n\n→&#x3D;{(p1,p2)| p1 必须在p2开始前完成}\n\n节点表示：一条语句，一个程序段，一个进程\n\n\n\n程序的并发执行特征：间断性、失去封闭性（主要由共享资源引起）、不可再现性（并发程序可能对共享资源做不同的修改）\n例子：\nA在B之前，则N分别为 n+1, n+1, 0\nA在B之后，则N分别为 n, 0, 1\nA在B中间，则N分别为 n, n+1, 0 \n并发程序资源共享：系统中资源被多个程序使用\n独立性和制约性：独立的相对速度、起始时间，程序之间相互作用&#x2F;制约\n程序与程序的执行不再一一对应\n引入并发的目的：提高资源利用率和系统效率例子：\n\n\n**进程的定义和特征 **定义：一个具有独立功能的程序在一个数据集合上的一次动态执行的过程。\n多进程可以i提高对硬件资源的利用率，但会增加额外的时间空间开销，增加OS的复杂性。\n特征：动态性、独立性、并发性、异步性、结构化\n进程&#x3D;代码段+数据段+PCB（进程控制块）\n一个程序可以对应多个进程（进程：程序&#x3D;n：1）\n进程是资源申请和系统调度的基本单位 进程 程序 动态的 静态的 程序的执行 代码的集合 暂时的 永久的 状态变化过程 可以长久保存 真实地描述并发 不能真实地描述 可以创建其他进程 不可创建其他程序\n进程的特征和状态进程的三种基本状态：就绪、执行、等待&#x2F;阻塞\n进程状态图：\n\n\n操作系统内核定义一些与硬件紧密相关的模块、运行频率较高的模块、共用基本操作模块等常驻内存的且便于提高操作系统运行效能的软件，称为操作系统内核。\n功能\n进程管理：创建；撤销；调度；控制\n存储管理：分配&#x2F;回收空间；虚拟存储管理\nI&#x2F;O设备管理：设备、通道的分配&#x2F;回收；设备的管理；虚拟设备的实现\n中断处理：操作系统的重要活动都依赖于中断\n\n\n原语\n定义：由若干机器指令构成以完成一段特定功能，且在执行过程中不可分割。\n原子操作：一个操作中的所有动作，要么全做，要么不做（All-or-None）\n\n原子操作的实现\n单机系统（屏蔽中断）\n\n单条指令\n\n以屏蔽中断的方式来保证操作的原子性\n\n多核系统（内存栅障）\n\n一个CPU核执行原子操作时，其他CPU核必须不对指定的内存进行操作，避免数据竞争问题\n\n\n\n操作系统控制结构操作系统管理计算机资源常用：\n\n表格：（或数据结构）记载各资源信息\n代码：对资源管理、维护、更新等\n\n进程控制块PCBPCB：Process Control Block，是一个数据结构。\n\n是进程存在的唯一标志，且常驻内存\n\n\nPCB的组织方式\n\n链接方式\n\n把具有同一状态的PCB用其中的链接指针链接成一个队列\n\n\n\n\n索引方式\n\n系统根据所有进程的状态建立几张索引表\n\n\n\n进程组织（进程树）描述了进程的家族关系\n\n子进程可继承父进程的资源\n父进程的撤销会撤销全部子进程\n根进程：init，launched，pid&#x3D;1\n孤儿进程直接托管给根进程\n\n\n进程的创建创建场景：用户登录&#x2F;作业调度&#x2F;提供服务&#x2F;应用请求\n创建过程：申请空白PCB，分配资源，初始化PCB，插入就绪队列\n进程控制函数（fork与exec为主）大多数程序中，系统调用的fork和exec是结合在一起使用的：父进程生成一个子进程，再通过调用exec覆盖该子进程。fork()：创建新进程\n\n调用格式：pid &#x3D; fork()\n\n调用fork后，父子进程均在下一条语句上继续运行\n\n父子进程fork返回值不同\n\n失败返回-1\n\n在子进程中返回时，pid为0\n\n在父进程返回时，为其创建的子进程pid\n\n\nfork()：两个关键点 \n\n运行顺序：父子进程运行无关，运行顺序也不固定。（若要运行顺序一定，需要用到进程间通信）\n数据共享：除子进程标识符和PCB特性参数不同外，子进程是父进程的精确复制\n\n例子：\n\nexec()：执行一个文件的调用\n\n子进程可以通过exec()调用加载新的程序文件\n子进程可以拥有自己的可执行代码，用新进程覆盖调用进程 \n调用参数：文件+命令行参数。成功：不返回；失败：返回-1\nexec指的是一组函数，一共有6个，分别是\n\n\t#include &lt;unistd.h&gt;\n\nint execl(const char *path, const char *arg, ...);\n\nint execlp(const char *file, const char *arg, ...);\n\nint execle(const char *path, const char *arg, ..., char *const envp[]);\n\nint execv(const char *path, char *const argv[]);\n\nint execvp(const char *file, char *const argv[]);\n\nint execve(const char *path, char *const argv[], char *const envp[]);\n\n与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。\n只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。\n例子:\n\n进程的终止中止情况：正常结束&#x2F;异常结束&#x2F;外界干预\n\n正常结束：exit&#x2F;halt&#x2F;logoff\n异常结束：无可用存储器&#x2F;越界&#x2F;保护错误&#x2F;算术错误&#x2F;IO失败&#x2F;无效指令&#x2F;特权指令\n外界干预：kill进程&#x2F;父进程中止\n\n中止过程：\n\n检索PCB检查进程状态→执行态改为中止→检查有无子孙需要中止→归还资源给父进程或系统→从PCB队列中移除\n系统调用exit(int ret)，返回ret到父进程，释放所有资源，父进程通过wait()等待子进程结束。（wait(pid, status)，ret）\n\n例子：\n\n\tProcess A:\nvoid main()&#123;\n    printf(&quot;Hello World!&quot;);\n&#125;\n\nProcess B:\nvoid main()&#123;\n    if((child&#x3D;fork())&lt;0)&#123;\n        printf(&quot;Fork Failed!&quot;);\n    &#125;\n    else if(child&#x3D;&#x3D;0)&#123;\n        if(execv(A)&lt;0)&#123;\n            printf(&quot;Execv Failed!&quot;);\n        &#125;\n        else&#123;\n            printf(&quot;Bye!&quot;)\n        &#125;\n    &#125;\n&#125;\n\n进程切换\n阻塞&#x2F;唤醒，时间片\n保存现场&#x2F;恢复现场\n\n\n系统调用：会引起从用户态进入核心态\n\n线程与进程的区别和联系进程：线程&#x3D;1：n\n\n线程的优势\n减少并发执行时的时空开销（进程的开销较大）\n\n线程是系统独立调度的基本单位\n\n基本不用有系统资源，只有少量资源，共享其所属进程所拥有的全部资源\n\n\n【回顾】\n进程是拥有资源和独立运行的基本单位，线程是系统独立调度的基本单位！！！\n线程的特点\n单线程进程，包括进程控制块和用户地址空间，以及用户栈和内核栈。\n多线程环境中，有一个与进程相关联的进程控制块和用户地址空间，每个线程都有一个独立的栈和独立的控制块，包含寄存器值、优先级和其他与线程相关的状态信息。\n进程中的所有线程共享该进程的资源，驻留在同一块地址空间中，并且可以访问到相同的数据。\n线程阻塞不一定会引起进程阻塞。\n\n线程的状态\n执行状态、阻塞状态、就绪状态等\n\n阻塞：当线程需要等待一个事件时，它将阻塞，此时处理器执行另一个就绪线程\n\n线程切换时保存的线程信息：\n\n一个执行栈\n\n每个线程静态存储局部变量\n\n对存储器和其进程资源的访问\n\n派生：产生一个新进程时，同时为其派生一个线程，随后还可以派生另一个线程，新线程被放置在就绪队列中\n\n结束：线程完成时，其寄存器信息和栈都被释放\n\n\n线程的分类\n内核级线程：每个线程在内核看来都是一个进程\n用户级线程：内核无法感知，用户自己控制\n\n不同点：\n\n调度开销\n\n内核级线程切换类似于进程切换，开销较大\n\n用户级线程切换在同一用户级进程中，无需进入内核，更快\n\n执行时间\n\n用户级线程以进程为单位平均分配时间，对线程间并发不利（单CPU）\n\n内核级线程以线程为单位分配时间（多CPU）\n\n并发效率\n\n用户线程：线程阻塞导致进程阻塞（内核不知道线程的存在）\n\n内核线程：线程阻塞，其他进程&#x2F;线程仍可运行\n\n\n\n处理机调度分配处理机的任务由进程调度程序完成\n处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能（吞吐量、响应时间），在很大程度上取决于进程调度性能的好坏\n\n⭐单处理机调度（重点）调度原则\n面向用户的原则\n\n周转时间：作业提交到完成的时间\n\n平均周转时间：\n\n平均带权：  越接近1越好，越大越差\n\n：周转时间\n\n：实际运行时间 \n\n响应时间：（交互式作业）提交请求到首次响应的时间\n\n截止时间：开始&#x2F;完成截止时间\n\n优先级：需要抢占&#x2F;剥夺调度\n\n面向系统的原则\n\n吞吐量：单位时间完成作业数\n\n利用率\n\n公平性\n\n优先级\n\n\n调度算法：资源分配问题\n先来先服务：FCFS简单来说，它就是按顺序执行。\n \n评价\n\n非抢占调度\n对长进程有利，不利于短进程\n适合CPU繁忙型进程，不适合I&#x2F;O繁忙型进程（系统角度）\n不能直接用于分时系统\n往往与其它调度算法综合使用\n\n例子：\n**平均周转时间：((2-0)+(8-1)+(9-2)+(14-3))&#x2F;4 &#x3D; 6.75 **\n平均等待时间：(0+1+6+6)&#x2F;4 &#x3D; 3.25(注意区分，可能会出审题性错误)\n\n短作业优先：SPF&#x2F;SJF执行时间短的先执行\n评价\n\n有利于短进程，提高了平均周转时间\n长进程可能被饿死（starvation）\n需要知道或估计每个进程的处理时间。\n\n \n \n例子：\n \n**平均周转时间：(2+13+1+5)&#x2F;4 &#x3D; 5.25 **\n平均等待时间：(0+7+0+0)&#x2F;4 &#x3D; 1.75\n\n时间片轮转调度：TSRR \n每过固定时间就换下一个进程（按FSCS） \n专门为分时系统设计（FCFS的优化）\n​\t 时间片长度变化的影响\n\n&#96;&#96;&#96;\n过长：退化为FCFS，进程在一个时间片内执行完\n过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加\n  **评价**\n\n* &#96;&#96;&#96;\n  * 相对公平\n  * 偏向于CPU型的进程\n  * 中断开销 \n\n\n\n例子： \nq指的是时间片长度\n\n平均周转时间：(4+16+12+13+5)&#x2F;5 &#x3D; 10\n平均等待时间：(1+10+9+9+5)&#x2F;5 &#x3D; 6.8\n\n平均周转时间：(3+15+7+14+11)&#x2F;5 &#x3D; 10\n平均等待时间：(0+9+3+9+9)&#x2F;5 &#x3D; 6\n最短剩余时间调度：SRT对SJF加入剥夺机制：当新进程进入时，可能比当前运行的进程具有更短的剩余时间\n\n优点\n\n不偏爱长进程，也不像RR产生额外中断，减少了开销。\n\n周转时间方面，比SJF好，短作业可以立即被选择执行。\n\n问题\n\n需要知道或估计每个进程所需处理时间；\n\n若持续有短进程存在，长进程可能被饿死；\n\n记录过去的服务时间（以便计算剩余时间）→ 增加了开销。\n\n\n\n基于优先权&#x2F;优先级的调度算法就是先运行优先级高的\n优先级\n\n&#96;&#96;&#96;每个进程设有一个优先级，调度程序选择具有较高优先级的进程。\n静态优先级(static)\n\n\n优先数在进程创建时分配，生存期内不变。\n响应速度慢，开销小。\n适合批处理进程\n动态优先级(dynamic)\n\n进程创建时继承优先级，生存期内可以修改。\n响应速度快，开销大。\n* 问题\n\n  &#96;低优先级的进程可能会饿死（无穷阻塞）&#96;\n\n* 改进\n\n  &#96;一个进程的优先级随着它的时间或执行历史而变化——老化策略(aging)。&#96; \n\n  &#96;执行过程中不断调整其优先级 （如：优先级随执行时间增加而下降，随等待时间增加而升高。）&#96;\n\n  &#96;优点：长短兼顾&#96;\n\n### 高响应比优先算法：HRRN\n\n响应比R &#x3D; 周转时间&#x2F;服务时间 &#x3D; (w+s)&#x2F;s       \n\n(w: 等待时间 ；s: 服务时间)\n\n就是先运行响应比高的（**综合考虑等待时间和作业长度**）\n\n* 评价\n\n  &#96;FCFS和SJF的结合，克服了两种算法的缺点&#96;\n\n  &#96;公平，吞吐率大&#96;\n\n  &#96;需要估计服务时间，增加了计算，增加了开销&#96;\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;c58da37a0c02412889d722d2b8020988.png)\n\n### 多级队列调度算法\n\n将就绪队列分成多个独立队列，进程所属的队列固定。通过对各队列的区别对待，达到一个综合的调度目标。 \n\n \n\n* 策略\n\n  &#96;不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）&#96;\n\n  &#96;队列之间的区别：采用固定优先级、可抢占调度来实现 （如前台队列优先级高于后台队列优先级。 ）&#96;\n\n  &#96;只有优先级高的队列中没有进程时，才可以调度优先级低的队列中的进程 &#96;\n\n### 多级反馈队列调度：MFQ\n\n多级反馈队列算法是多级队列和动态优先级算法的综合和发展。\n\n按时间片、等待时间，使用动态优先级机制；调度基于剥夺原则。\n\n* 策略\n\n  &#96;不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）&#96;\n\n  &#96;多个就绪队列，进程所属队列可变，即进程可以在不同的就绪队列之间移动&#96;\n\n  &#96;多个就绪队列分别赋予不同的优先级&#96;\n\n  &#96;队列优先级逐级降低，而时间片长度逐级递增&#96;\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;a437cca9aa7d49b8aa8d02e0db7e611a.png)\n\n调度过程\n\n\n\n\n\n新进程进入后，先放入队列0的末尾，按RR顺序调度；\n若执行过程中阻塞，则离开队列，被唤醒后，放入同一优先级队列尾部；\n若在规定时间片未能执行完，则降低优先级投入队列1的末尾，同样按RR算法调度；如此下去，直到最后的队列； 1. 若只有1个进程，则不降级； 2. 可有效应对I&#x2F;O繁忙进程。\n最后队列按FCFS或者RR（但不再降级）调度直到完成；\n若在最后队列等待时间过长，提升优先级；\n仅当较高优先级的队列为空，才调度较低优先级的进程执行； 1. 当前进程一旦开始执行，时间片结束前不被抢占； 2. 若按优先级调度的进程为上一个被抢占的进程，则忽略之，调度下一个候选；\n\n \n\n\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3951b06c3ae2470dbef7aca37f42e95b.png)\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;7ca42f0c4b694272847487b5cc8ca218.png)\n\n### 总结\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;d521d900f4fe4bd29eeea6640c7d63e7.png)\n\n----\n\n## 实时调度 \n\n### 基本条件\n\n* 就绪时间：成为就绪状态的时间\n* 开始&#x2F;完成截止时间\n* 处理时间\n* 资源要求\n* 优先级\n\n### 系统处理能力下界\n\n假定系统中有m个周期性的实时任务，它们的处理时间为Ci，周期为Pi，则在单&#x2F;多处理机情况下，可调度的必要条件：\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;d8ef312a3d4f45d3b481ca28d7269161.png)![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;7e0f4bc0f76347aeabe145acd1e91d2d.png)\n\n### 实时调度算法\n\n* **基于时间片轮转调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;27b0c6fc983240ac92ccb54ea87719fa.png)\n\n  \n\n* **基于优先级的非抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fa38c8747d71449daf07bbb7a7b80dce.png)\n\n  \n\n* **基于抢占点的抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3155de64c2784a2b825a217426458dbf.png)\n\n  \n\n* **立即抢占调度**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;710daa2463a6499c9eb9fb945d038b7b.png)\n\n  \n\n* **最早截止时间优先（EDF）**\n\n* 可以是抢占式或非抢占式\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fbd29d111c37415fa16c2d3bde7894b8.png)\n\n  \n\n* **最低松弛度优先算法（LLF）**\n\n* 主要用于可抢占调度方式\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;b213d20babb54559847ee09ba309f2dc.png)\n\n* 例子：\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;1c44a37039a34ad79a3959222d315f86.png)\n\n* 速度单调调度\n\n  &#96;任务周期：周期性任务&#96;\n\n  &#96;任务速度：1&#x2F;任务周期&#96;\n\n  &#96;速度越快，优先级越高&#96;\n\n----\n\n## 多处理机调度\n\n### 分类\n\n* 紧密耦合\n\n  &#96;共享RAM和I&#x2F;O&#96;\n\n  &#96;高速总线和交叉开关连接&#96;\n\n* 松弛耦合\n\n  &#96;独立RAM和I&#x2F;O&#96;\n\n  &#96;通道和通信线路连接&#96;\n\n* 对称多处理器系统 SMP：Symmetric Multiprocessing\n\n* 非对称多处理器系统 AMP：Asymmetric Multiprocessing \n\n### 进程分配方式\n\n* SMP中进程分配方式\n\n  &#96;静态分配&#96;\n\n  &#96;动态分配：可防止系统中多个处理器忙闲不均&#96;\n\n* 非SMP中进程分配方式\n\n  &#96;进程调度在主处理器上执行&#96;\n\n  &#96;有潜在的不可靠性&#96;\n\n### 单队列多处理机调度\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;98b40bf1bde045cb84c1043a360e72bf.png)\n\n各个处理机自行在就绪队列中取任务（先纵向看，再横向看）。\n\n优点：简单，分布式调度，多个CPU利用率都好\n\n缺点：瓶颈问题（单队列→共享资源→锁） 低效性：cache affinity （下图为改进） \n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;cf606d6b50d143d9959518710e9ad35f.png)\n\n### 多队列多处理机调度\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;8300a984b1364ed3ae63d982266c5b60.png)每个CPU一个队列：没有SQMS的问题，但是可能负载不均衡，导致资源分配不合理。\n\n### 成组调度\n\n* 优点：\n\n  &#96;对相互合作的进（线）程组调度，可以减小切换，减小系统开销。&#96;\n\n  &#96;每次分配一组CPU，减少了调度频率。&#96;\n\n* 分配时间\n\n  &#96;面向程序&#96;\n\n  &#96;面向线程：使处理机利用率更高。 &#96;\n\n### 专用处理机分配 \n\n* &#96;特点：每个进（线）程专用处理机，使其切换小，提高效率。&#96;\n\n* 主要用于大型计算，实时系统\n\n  &#96;Sony PlayStation 3 (PPU&#x2F;SPU) → CELL&#96;\n\n  &#96;神威太湖之光：众核（4+256)&#96;\n\n----\n\n# 进程并发控制：互斥与同步\n\n----\n\n## 进程&#x2F;线程的并发控制\n\n进程&#x2F;线程是计算机中的独立个体：异步性（并发性）\n\n资源是计算机中的稀缺个体：独占性（不可复用性）\n\n进程&#x2F;线程协作完成任务（协作）\n\n并发控制：进程&#x2F;线程在推进时的相互制约关系\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3b53006c85164ed19de54578f2d034f1.png)\n\n并发执行进程能有效地共享资源和相互合作，并按一定顺序执行。\n\n----\n\n## 基本概念\n\n* 进程间的制约关系\n\n  ​\t&#96;间接制约：资源共享→互斥&#96;\n\n  ​\t&#96;直接制约：进程合作→同步&#96;\n\n* 临界资源（Critical  Resource）\n\n  ​\t&#96;一次仅允许一个进程访问的资源&#96;\n\n* 临界区（Critical  Section）\n\n  ​\t&#96;进程中访问临界资源的代码段&#96;\n\n* 忙等、饥饿、死锁\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;741684ccdbc54bea99b73f3a3d308433.png)&#96;\n\n* 活锁\n\n* &#96;两个或多个进程不断更改其状态以响应其他进程的更改而不执行任何有用工作的情况。&#96;\n\n  ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;bf55e6d2eccb4b428f31f4a17df3e136.png)\n\n* 同步原则\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;dfc4a47195a4411c8c0bc549f29cffd9.png)\n\n----\n\n## 同步的解决策略\n\n### 软件方法\n\n进程通过执行相应的程序指令，实现与其他进程的互斥与同步\n\n### 硬件方法\n\n* &#96;&#96;&#96;\n  * 屏蔽中断：确保互斥执行\n    * 缺点：\n  \t* 系统无法响应外部请求\n  \t* 无法接受异常，处理系统故障\n  \t* 无法切换进程→性能下降\n  \t* 不支持多处理机\n\n  * 机器指令\n\t* 原子性：all-or-nothing\n\t* 单处理器：一个周期内完成的指令\n\t* 多处理器：LOCK总线\n\t\t* Test &amp; Set\n\t\t\t* 测试某个变量的值，如果为0，则置1，并返回当前值\n\t\t* Exchange\n\t\t\t* 原子性地交换寄存器和内存的值\n\t* 优点：\n\n\t\t* 支持多处理机\n\t\t* 简单易证明\n\t\t* 支持多临界区\n\t* 缺点：\n\t\t* 忙等现象\n\t\t* 饥饿现象\n\t\t* 死锁现象\n\n信号量\n原理：\n多进程通过信号传递协调工作，根据信号指示停止执行（阻塞等待）或者向前推进（唤醒）。\n\n信号：信号量s\n+：资源数量\n-：排队数量\n\n原语：\nwait(s)：等待信号，并占有资源        ——&gt;P操作\nsignal(s)：释放资源，并激发信号     ——&gt;V操作\n\n分类\n\n&#96;&#96;&#96;\n\n整数型信号量（如下图）\n记录型信号量\nAND型信号量\n将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。\n只要有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给它\n\n\n原子操作\n要么全部分配到进程，要么全不分配\n\n\n在wait操作中，增加一个AND条件，故称为AND同步，或称为同时wait操作\n  * ![整数型信号量](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;be11aba3992e42a1ab5d3d80949c01ad.png)\n\n* 信号量正负的含义\n\n  &#96;s.value ≥ 0：是可以在不挂起的情况下执行等待的进程数。&#96;\n\n  &#96;s.value &lt; 0：s.value 的大小是 s.queue 中挂起的进程数。&#96;\n\n* 信号量集\n\n  * 采用信号量集来控制，可以分配多个资源\n  * swait(S1, t1, d1, …, Sn, tn, dn） ti：资源下限； di：需求量\n    * ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;1868ea2fd95341c2af44532ae8972dce.png) \n\n\n### 管程\n\n管程的组成\n\n* 局部于该管程的共享数据，这些数据表示了相应资源的状态；\n* 针对上述数据的一组过程；\n* 对局部于该管程的数据的初始化。\n\n管程的特点\n\n* 模块化（Modularization）\n\n  &#96;管程是一个基本程序单位，可以单独编译;&#96;\n\n* 抽象数据类型（Abstraction)\n\n  &#96;管程中不仅有数据，而且有对数据的操作;&#96;\n\n* 信息隐藏（Encapsulation）\n\n  &#96;管程外可以调用管程内部定义的函数，但函数具体实现外部不可见;&#96;\n\n  &#96;局部数据变量只能被管程的过程访问，任何外部过程都不能访问。&#96;\n\n管程的同步\n\n* &#96;&#96;&#96;\n  * 进程通过调用管程的一个过程进入管程；\n  * 在任何时候，只能有一个进程在管程中执行；调用管程的任何其他进程都被挂起，以等待管程变成可用。\n  * 条件变量提供同步支持（非默认锁）。条件变量包含在管程中，并且只有在管程中才能被访问：\n  \t* cwait(x)：调用进程的执行在条件x上挂起，管程现在可被另一进程使用。\n  \t* csignal(x)：恢复阻塞在x上的进程。\n\n\n\n\n\n\n⭐进程并发控制：信号量的应用（重点）展示一些信号量实例，也是重点考察的地方\n\n观察者问题观察者和报告者是两个并发执行的进程。 观察者不断观察并对通过的卡车计数； 报告者不停地将观察者的计数打印，并归零。 请用P、V原语进行正确描述。\n\n\n图书馆问题图书馆有N个座位，一张登记表，要求： 读者进入时需先登记，取得座位号； 出来时注销 用P、V原语描述读者的使用过程。\n\n\n公交车问题司机启动车辆的动作必须于售票员关车门的动作取得同步；售票员开车门的动作也必须与司机停车取得同步。\n\n\n\n⭐生产者&#x2F;消费者问题（重点）生产者&#x2F;消费者模型：\n生产者：满则等待，空则填充\n消费者：空则等待，有则获取\n不允许同时进入缓冲区\n无限缓冲：\n\n有限循环&#x2F;环形缓冲区：\n\n例题：有3个进程PA，PB和PC合作解决文件打印问题：\n​\tPA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录;\n​\tPB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；\n​\tPC将缓冲区2的内容打印出来，每执行一次打印一个记录。\n​\t缓冲区的大小等于一个记录大小。\n请用P，V操作来保证文件的正确打印。 \n\n信号量：\n​\t\tempty1，empty2：分别表示缓冲区1及缓冲区2是否为空，初值为1。\n​\t\tfull1，full2：分别表示缓冲区1及缓冲区2是否有记录可供处理，初值为0。\n​\t\tmutex1，mutex2：分别表示缓冲区1及缓冲区2的访问控制，初值为1。 \n\n启示\n资源数量：资源信号量\n资源访问：互斥信号量\n先申请资源，再申请访问权\n资源信号量P、V操作分布在不同进程\n互斥信号量P、V操作出现在同一进程\n\n \n\n⭐读&#x2F;写者问题（重点）三个角色：一个共享的数据区； Reader: 只读取这个数据区的进程； Writer: 只往数据区中写数据的进程；\n三个条件：多个Reader可同时读数据区； 一次只有一个Writer可以往数据区写； 数据区不允许同时读写。（“读－写” 互斥；“写－写” 互斥；“读－读” 允许）\n\n读者优先一旦有读者正在读数据，则允许随后的读者进入读数据；只有当全部读者退出，才允许写者进入写数据；导致写者饥饿\n信号量设置：\nwsem：互斥信号量，用于Writers间互斥，Writers和Readers互斥\n\nreadcount：统计同时读数据的Readers个数\n\nmutex：对变量readcount互斥算术操作\n\n\n\n\tint readcount&#x3D;0；\nsemaphore mutex &#x3D; 1, wsem&#x3D;1;\n \nvoid reader() &#123; \n while (1) &#123;\n  P(mutex);\n   readcount++;\n   if (readcount&#x3D;&#x3D;1) P(wsem); \n  V(mutex);\n  READ;\n  P(mutex);\n   readcount--;\n   if (readcount&#x3D;&#x3D;0) V(wsem);\n  V(mutex);\n  &#125;\n&#125;\n \nvoid writer() &#123;\n while (1) &#123;\n   P(wsem);\n    WRITE;\n   V(wsem);\n &#125;\n&#125;\n\n写者优先当至少有一个写者声明想写数据时，则不再允许新的读者进入读数据。例如：队列：（尾)WWRRW(头)，让三个W进程能优先于R进程写数据。解决了写者饥饿问题，但降低了并发程度，系统的并发性能较差。\n信号量设置:\nwsem：互斥信号量，用于Writers间互斥，Reader互斥Writers\n\nrsem：互斥信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据。第一个写者受rsem影响，一旦有第一个写者，后续写者不受rsem其影响。但是读者需要在rsem上排队。\n\nmwc：用于控制writecount互斥算术操作\n\nmrc：用于控制readcount互斥算术操作\n\nz:  对读者进行控制，防止在rsem上出现读进程的长队列，否则写进程不能跳过这个队列\n\n\n\n\tint readcount, writecount;\nsemaphore mrc&#x3D;l, mwc&#x3D;1, z&#x3D;1, wsem&#x3D;1, rsem&#x3D;l;\n\nvoid reader( ) &#123;\n  while (1) &#123;\n   P(z);\n    P(rsem);\n     P(mrc);\n      readcount++;\n      if (readcount &#x3D;&#x3D; 1) P(wsem);\n     V(mrc);\n    V(rsem)；\n   V(z);\n   READ;\n   P(mrc);\n    readcount--;\n    if (readcount &#x3D;&#x3D; 0) V(wsem);\n   V(mrc);\n   &#125;\n &#125;\n\nvoid writer( ) &#123;\n  while (1) &#123;\n    P(mwc);\n     writecount++;\n     if (writecount &#x3D;&#x3D; 1) P(rsem);\n    V(mwc);\n    P(wsem);\n     WRITE;\n    V(wsem);\n    P(mwc);\n     writecount--;\n     if (writecount &#x3D;&#x3D; 0) V(rsem);\n    V(mwc);\n  &#125;\n&#125;\n\n公平优先写过程中，若其它读者、写者到来，则按****到达顺序处理\n信号量设置：\nw：互斥信号量，用于Writers间互斥，Reader互斥Writers\n\nreadcount：统计同时读数据的Readers个数\n\nmrc：对变量readcount互斥算术操作\n\nr：互斥信号量，确定Writer 、Reader请求顺序\n\n​\t\t在读者优先中，wsem只对第一个读者起阻塞作用，后续读者不受其影响。为了保证按照到达顺序处理，故公平优先方式设置wrsem,读者／写者按到达顺序在wrsem上排队。\n\tint readcount &#x3D; 0;\nsemaphore mrc &#x3D; 1, r &#x3D; 1, w &#x3D; 1;\n\nREADER &#123;\n  P(r);\n    P(mrc);\n      readcount++;\n      if (readcount &#x3D;&#x3D; 1) P(w);\n    V(mrc);          \n  V(r);\n \n  Read();\n \n  P(mrc);\n     readcount--;\n     if (readcount &#x3D;&#x3D; 0) V(w);\n  V(mrc);  \n&#125; \n\nWRITER &#123;\n  P(r);\n  P(w);\n\n  Write();\n\n  V(w);  \n  V(r);\n&#125;\n\n\n⭐理发师问题（重点）角色和资源：一个理发师 一个理发椅 一排座位 随机到来的客户\n\n场景：理发师：有客干活，无客睡觉；客户：唤醒理发师，有位等待，无位离开 \n\n此问题无死锁，有饥饿（以排队方式解决饥饿问题）\n\n\n\t&#x2F;* # of customers waiting *&#x2F;\nsemaphore customers &#x3D; 0; \n&#x2F;* barber status *&#x2F;\nsemaphore barbers &#x3D; 0;          \n&#x2F;* mutual exclusion to access seats *&#x2F;\nsemaphore mutex &#x3D; 1;            \n&#x2F;* # of available seats. *&#x2F;\nint nas &#x3D; N;                \n\nvoid barber(void) &#123;\n  while (TRUE) &#123;\n    P(customers); \n    P(mutex);           \n    nas++;  \n    V(barbers);           \n    V(mutex);             \n    cut_hair();             \n  &#125;\n&#125;\n\nvoid customer(void) &#123;\n  P(mutex); \n  if (nas &gt; 0) &#123;\n    nas--; \n    V(customers);        \n    V(mutex); \n    P(barbers);\n    get_haircut(); \n  &#125; else &#123;\n    V(mutex); \n    leave_shop();\n  &#125;\n&#125;\n\n\n⭐哲学家问题（重点）哲学家就餐问题可以用来解释死锁和资源耗尽。\n描述：5个哲学家围坐一张餐桌；5只餐叉（筷子）间隔摆放；思考或进餐；进餐时必须同时拿到两边的餐叉；思考时将餐叉放回原处。\n\t#define  N  5\n#define  LEFT  (i-1+N)%N\n#define  RIGHT (i+1)%N\n#define  THINKING   0\n#define  HUNGRY     1\n#define  EATING     2\n\nint state[N] &#x3D; &#123;0, 0, 0, 0, 0&#125;;\nsemaphore mutex &#x3D; 1;\nsemaphore s[N]&#x3D;&#123;0,0,0,0,0&#125;;\n\nvoid philosopher(int i)&#123;\n  while (TRUE) &#123;\n    think();\n    take_forks(i);\n    eat();\n    put_forks(i);\n  &#125;\n&#125;\n\nvoid take_forks(int i)\n&#123;\n     P(mutex);\n     state[i] &#x3D; HUNGRY;\n     test(i);\n     V(mutex);\n     P(s[i]);\n&#125;\n\nvoid put_forks(i)\n&#123;\n     P(mutex);\n     state[i] &#x3D; THINKING;\n     test(LEFT);\n     test(RIGHT);\n     V(mutex);\n&#125;\n\n\nvoid test(int i) \n&#123;\n  if (state[i] &#x3D;&#x3D; HUNGRY &amp;&amp; \n      state[LEFT] !&#x3D; EATING &amp;&amp; \n      state[RIGHT] !&#x3D; EATING) &#123;\n    state[i] &#x3D; EATING;\n    V(s[i]);\n  &#125;\n&#125;\n\n\n重点知识点回顾\n\n进程并发控制：练习题问题1​\t桌子上有一只盘子，最多可以放入N（N&gt;0）个水果\n​\t爸爸随机向盘中放入苹果或桔子； 儿子只吃盘中的桔子； 女儿只吃盘中的苹果； 只有盘子中水果数目小于N时，爸爸才可以向盘子中放水果； 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果； 每次只能放入或取出一个水果，不允许多人同时使用盘子。\n​\t用P、V操作实现爸爸、儿子和女儿之间的同步与互斥活动。\n\tsemaphore mutex &#x3D; 1;                &#x2F;&#x2F;盘子操作互斥信号量\nsemaphore apple &#x3D; 0, orange &#x3D; 0;    &#x2F;&#x2F;苹果、桔子放入、取出的资源信号量\nsemaphore empty &#x3D; N;                &#x2F;&#x2F;盘子中可放入的水果数目\n\ndad()\n&#123;\n    while (true) &#123;\n       result&#x3D; prepare _fruit();    &#x2F;&#x2F;准备水果，result为水果类型\n       P(empty);                    &#x2F;&#x2F;盘子中可放入的水果数目减1\n       P(mutex);                    &#x2F;&#x2F;互斥访问盘子\n       put a fruit on the plate;    &#x2F;&#x2F;将一个水果放入盘子\n       V(mutex);                    &#x2F;&#x2F;恢复访问盘子\n       if (result &#x3D;&#x3D; fruit_apple)   &#x2F;&#x2F;准备的水果为苹果\n         V(apple);                  &#x2F;&#x2F;允许女儿取苹果\n       else                         &#x2F;&#x2F;准备的水果为桔子\n         V(orange);                 &#x2F;&#x2F;允许儿子取桔子\n    &#125;\n&#125;\n\nson() &#123;\n    while (true) &#123;\n         P(orange);                            &#x2F;&#x2F;互斥取桔子\n         P(mutex);                             &#x2F;&#x2F;互斥访问盘子\n         get an orage from plate();            &#x2F;&#x2F;取桔子\n         V(mutex);                             &#x2F;&#x2F;恢复访问盘子\n         V(empty);                             &#x2F;&#x2F;盘子中可放入的水果数目加1\n    &#125;\n&#125;\n\ndaughter() &#123;\n    while (true) &#123;\n         P(apple);                             &#x2F;&#x2F;互斥取水果\n         P(mutex);                             &#x2F;&#x2F;互斥访问盘子\n         get an apple from plate();            &#x2F;&#x2F;取苹果\n         V(mutex);                             &#x2F;&#x2F;恢复访问盘子\n         V(empty);                             &#x2F;&#x2F;盘子中可放入的水果数目加1\n    &#125;\n&#125;\n\n问题2桌子上有一只盘子，只能放一只水果\n爸爸负责向盘中放苹果，妈妈负责向盘中放桔子。 儿子只吃盘中的桔子，女儿只吃盘中的苹果。 只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果。 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果。 同一时刻只能有一个人操作盘子\n请用信号量机制实现爸爸、妈妈、儿子和女儿之间的同步与互斥活动。\n\tsemaphore plate &#x3D; 1;     &#x2F;&#x2F;盘子是否有空间\nsemaphore mutex &#x3D; 1;\nsemaphore apple &#x3D; 0, orange &#x3D; 0;  &#x2F;&#x2F;盘子中是否有苹果、桔子\n\ndad() &#123;\n    while (true) &#123;\n      prepare an apple;\n      P(plate);                               \n      P(mutex)\n      put the apple on the plate;  \n      V(mutex)\n      V(apple);                            \n    &#125;\n&#125;\n\nmom() &#123;\n  while (true) &#123;\n    prepare an orange;\n    P(plate); \n    P(mutex); \n    put the orange on the plate;  \n    V(mutex)\n    V(orange);                            \n  &#125;\n&#125;\n\nson()\n&#123;\n    while (true) &#123;\n      P(orange);\n      P(mutex);\n      get an orange; \n      V(mutex);\n      V(plate);                                       \n   &#125;\n&#125;\n\ndaughter()\n&#123;\n    while (true) &#123;\n      P(apple); \n      P(mutex);\n      get an apple;\n      V(mutex);\n      V(plate);\n    &#125;\n&#125;\n\n因为缓冲区大小就为1，所以可以省略mutex信号量。\n问题3桌子上有一只盘子 最多可以放入2个水果。\n爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果。 当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果。 不允多人同时使用盘子\n请用信号量机制实现爸爸、妈妈和女儿之间的同步与互斥活动。\n\tsemaphore apple &#x3D; 0, orange &#x3D; 0;    &#x2F;&#x2F;盘子中是否有苹果、桔子\nsemaphore empty_apple &#x3D; 1, empty_orange &#x3D; 1;    &#x2F;&#x2F;盘子是否可放入苹果、桔子\nsemaphore mutex &#x3D; 1;\n\ndad()&#123;\n    while (true) &#123;\n      prepare an apple;\n      P(empty_apple); \n      P(mutex);\n      put an apple on the plate;    \n      V(mutex);\n      V(apple);               \n    &#125;\n&#125;\n\nmom()&#123;\n    while (true) &#123;\n      prepare an orange;\n      P(empty_orange);  \n      P(mutex);\n      put an orange on the plate; \n      V(mutex);\n      V(orange);\n   &#125;\n&#125;\n\ndaughter() &#123;\n    while (true) &#123;\n         P(apple);\n         P(orange);\n         P(mutex);\n         get an apple  and an orange from plate; &#x2F;&#x2F;取水果\n         V(mutex);\n         V(empty_apple); \n         V(empty_orange); \n   &#125;\n&#125;\n\n这里的mutex不可以省略，缓冲区的大小不为1，资源信号量无法兼顾互斥信号量的工作。\n问题4女儿画画，爸爸、妈妈欣赏。\n女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画。\n请用信号量机制实现女儿、爸爸和妈妈之间的同步与互斥活动。\n\t&#x2F;&#x2F;爸爸、妈妈是否已看过女画的新画\nsemaphore empty_dad &#x3D; 1, empty_mom &#x3D; 1;\n&#x2F;&#x2F;是否存在可供爸爸、妈妈看的新画\nsemaphore full_dad &#x3D; 0, full_mom &#x3D; 0; \n\n\ndaughter()&#123;\n    while (true) &#123;\n         P(empty_dad);  &#x2F;&#x2F;爸爸是否看过\n         P(empty_mom);  &#x2F;&#x2F;妈妈是否看过\n         draw a new picture on the whiteboard; &#x2F;&#x2F;画一幅新画\n         V(full_dad); &#x2F;&#x2F;爸爸可以看了\n         V(full_mom); &#x2F;&#x2F;妈妈可以看了\n    &#125;\n&#125;\n\ndad() &#123;\n    while (true) &#123;\n         P(full_dad);    &#x2F;&#x2F;白板上是否存在没有看过的画\n         enjoy the picture on the whiteboard; &#x2F;&#x2F;看画\n         V(empty_dad); &#x2F;&#x2F;爸爸已看过新画\n    &#125;\n&#125;\n\nmom() &#123;\n    while (true) &#123;\n       P(full_mom);  &#x2F;&#x2F;白板上是否存在没有看过的画\n       enjoy the picture on the whiteboard; &#x2F;&#x2F;看画\n       V(empty_mom);  &#x2F;&#x2F;妈妈已看过新画\n    &#125;\n&#125;\n\n问题5有一座东西方向的独木桥，每次只能有一人通过，且不允许行人在桥上停留。东、西两端各有若干行人在等待过桥。请用P、V操作来实现东西两端行人过桥问题。\n\tsemaphore mutex &#x3D; 1; &#x2F;&#x2F;互斥信号量\n\nvoid east_west( )\n&#123;\n    while (true) &#123;\n         P(mutex); &#x2F;&#x2F;互斥其他人过桥\n         walk across the bridge from east to west;&#x2F;&#x2F;行人从东向西过桥\n         V(mutex); &#x2F;&#x2F;允许其他人过桥\n    &#125;\n&#125;\n\nvoid west_east( )\n&#123;\n    while (true) &#123;\n         P(mutex); &#x2F;&#x2F;互斥其他人过桥\n         walk across the bridge from west to east;&#x2F;&#x2F;行人从西向东过桥\n         V(mutex); &#x2F;&#x2F;允许其他人过桥\n    &#125;\n&#125;\n\n问题6有一座东西方向的独木桥\n同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待，直到对方全部通过。 桥上没有行人过桥时，任何一端的行人均可上桥。\n请用P、V操作来实现东西两端人过桥问题。      \n\tint countA&#x3D;0, countB&#x3D;0；\nsemaphore mutex&#x3D;1, muteA&#x3D;1, mutexB&#x3D;1;\n\nvoid east_west() &#123; \n    while (1) &#123;\n        P(mutexA);\n          countA++;\n          if (countA&#x3D;&#x3D;1) P(mutex); \n        V(mutexA);\n        walk across the bridge from east to west;\n        P(mutexA);\n          countA--;\n          if (countA&#x3D;&#x3D;0) V(mutex);\n        V(mutexA);\n    &#125;\n&#125;\n\nvoid west_east() &#123; \n    while (1) &#123;\n        P(mutexB);\n          countB++;\n          if (countB&#x3D;&#x3D;1) P(mutex); \n        V(mutexB);\n        walk across the bridge from west to east;\n        P(mutexB);\n          countB--;\n          if (countB&#x3D;&#x3D;0) V(mutex);\n        V(mutexB);\n    &#125;\n&#125;\n\n问题7有一座东西方向的独木桥， 同一方向的行人可连续过桥。\n当某一方向有行人过桥时，另一方向行人必须等待。 桥上没有行人时，任何一端的行人均可上桥。 出于安全考虑，独木桥的最大承重为4人，即同时位于桥上的行人数目不能超过4。\n请用P、V操作来实现东西两端人过桥问题。      \n\tint countA&#x3D;0, countB&#x3D;0；\nsemaphore mutex&#x3D;1, muteA&#x3D;1, mutexB&#x3D;1,count&#x3D;4;\n\nvoid east_west() &#123; \n    while (1) &#123;\n        P(mutexA);\n          countA++;\n          if (countA&#x3D;&#x3D;1) P(mutex); \n        V(mutexA);\n        P(count);\n          walk across the bridge from east to west;\n        V(count);\n        P(mutexA);\n          countA--;\n          if (countA&#x3D;&#x3D;0) V(mutex);\n        V(mutexA);\n    &#125;\n&#125;\n\nvoid west_east() &#123; \n    while (1) &#123;\n        P(mutexB);\n          countB++;\n          if (countB&#x3D;&#x3D;1) P(mutex); \n        V(mutexB);\n        P(count);\n          walk across the bridge from west to east;\n        V(count);\n        P(mutexB);\n          countB--;\n          if (countB&#x3D;&#x3D;0) V(mutex);\n        V(mutexB);\n    &#125;\n&#125;\n\n问题8某寺庙有小和尚和老和尚各若干人，水缸一只，由小和尚提水入缸给老和尚饮用。水缸可容水m桶，水取自同一口水井中。水井径窄，每次仅能容一只水桶取水，水桶总数为n个。若每次提水、取水仅为1桶，试用P, V操作描述小和尚和老和尚提水、取水的活动过程\n\tsemaphore mutex1&#x3D;1, mutex2&#x3D;1;\nsemaphore empty&#x3D;m, full&#x3D;0;\nsemaphore count&#x3D;n;\n\nprocess 小和尚(i) (i&#x3D;1，2，…)\n  begin\n   repeat\n     P(empty);         &#x2F;&#x2F;水缸满否?\n     P(count);         &#x2F;&#x2F;取得水桶\n     P(mutex1);        &#x2F;&#x2F;互斥从井中取水\n          从井中取水;\n     V(mutex1);\n     P(mutex2);        &#x2F;&#x2F;互斥使用水缸\n       倒水入缸;\n     V(mutex2);\n     V(count);         &#x2F;&#x2F;归还水桶\n     V(full);           &#x2F;&#x2F;多了一桶水\n  until false;\n end\n\nprocess 老和尚(取水)j(j&#x3D;1，2，…)\n   begin\n    repeat\n     P(full);           &#x2F;&#x2F;有水吗?\n     P(count);         &#x2F;&#x2F;申请水桶\n     P(mutex2);        &#x2F;&#x2F;互斥取水\n       从缸中取水;\n     V(mutex2);\n     V(count);         &#x2F;&#x2F;归还水桶\n     V(empty);        &#x2F;&#x2F;水缸中少了一桶水\n     until false;\n  end\n\n问题9N个生产者进程和M个消费者进程共享大小为K的缓冲区，遵循规则如下： 进程之间必须以互斥方式访问缓冲区； 对每1条放入缓冲区的数据，所有消费者都必须接收1次； 缓冲区满时，生产者必须阻塞； 缓冲区空时，消费者必须阻塞。 请用P、V操作实现其同步过程，须说明信号量含义。\n\n\n进程间通信Inter Process Communication: IPC 是指进程之间的信息交换\n\n基本概念进程通信分为两类：\n\n低级通信：以信号量作为通信工具，交换的信息量少。\n\n高级通信：操作系统所提供的一组通信命令，高效地传送大量数据。\n\n* 共享存储（Shared Memory）\n* 消息传递/消息队列（Message Passing/Message Queue）\n* 管道（Pipe）\n* 套接字（Socket）\n* 文件（File）\n* 信号（Signal）\n* 内存映射文件（Memory Mapped File）\n\n  \n\n共享存储：\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;678d37f3307048c5a88316e84047f47e.png)\n\n----\n\n## 消息传递\n\n* 数据交换以格式化的消息为单位；直接利用系统提供的一组通信命令（原语）进行通信。\n\n* &#96;&#96;&#96;\n  * 间接通信方式 （Indirect Communication）\n  \t* 中介：信箱。\n  \t* 发送进程发送给目标进程的消息存放信箱； 接收进程则从该信箱中，取出发送给自己的消息；\n  \t* 消息在信箱中安全地保存，只允许核准的用户读取。\n  \t* 系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。\n  * 直接通信方式（Direct Communication）\n  \t* 直接把消息发送给目标进程。\n\n\n\n跨节点的进程间通信\n套接字（socket） \n\n\n\n管道（Pipe）通信用于连接一个读进程和一个写进程以实现他们之间通信的共享文件，又名pipe文件。\n\n无名管道（unnamed pipe）\n​\t$ ls | grep x\n\n命名管道（named pipe）\n​\t$ mkfifo mypipe\n\n\n\n死锁多个进程在运行过程中因争夺资源而造成的一种僵局（Deadly- Embrace），当进程处于这种僵持状态时，若无外力作用，它们都将无法向前推进。\n\n产生死锁的原因\n资源不足导致的资源竞争：多个进程所共享的资源不足，引起它们对资源的竞争而产生死锁。\n并发执行的顺序不当：进程运行过程中，请求和释放资源的顺序不当，而导致进程死锁。\n\n\n系统模型\n资源（R1, R2, . . ., Rm）\n​\tCPU, memory, I/O devices\n\n资源Ri拥有的实例数 Wi（instance）\n\n进程使用资源的方式\n\n请求（request）\n占用/使用（use）\n释放（release）\n\n\n\n\n资源类型\n重用型资源（Reusable Resource）\n\n一次只能供一个进程使用，不会由于使用而耗尽\n例: CPU、 I/O通道、主存和辅存、 设备、文件、数据库、信号量等数据结构\n\n\n消费型资源（Consumable Resource）\n\n可以创建并且可以销毁的资源 数目没有限制，当一个进程得到一个可消费资源后，这个资源就不再存在了\n例: 中断、信号、 消息、 I/O缓冲区中的信息\n\n\n\n\n资源分配图RAG: Resource-Allocation Graph\n进程：P &#x3D; {P1, P2, …, Pn}\n资源：R &#x3D; {R1, R2, …, Rm}\n资源请求边（request）： Pi → Rj\n资源分配边（assignment ）：Rj → Pi \n\n实例 实例  死锁\n 带环但无死锁\n\n死锁的充要条件互斥条件\n进程对所分配到的资源进行排它性使用。如果此时还有其它进程申请该资源，则只能阻塞，直至占有该资源的进程释放。\n占有且等待（请求和保持条件）\n进程已经占有了至少一个资源，又提出了新的资源要求，而该资源已被其它进程占有，此时请求进程阻塞，且对已经获得的其它资源保持不放。 \n非抢占（非剥夺）条件\n进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。\n循环等待条件\n在发生死锁时，存在一个进程—资源的封闭的环形链。\n以上四条缺一不可。\n\n处理死锁的基本方法\n死锁预防通过限制申请资源的方法来破坏产生死锁的条件（四个方面）\n互斥条件\n由资源的固有特性所决定，不能被破坏。\n打破“占有和等待”\n进程开始运行前一次性地申请全部资源，启动后不再申请。\n优点: 简单、易于实现、安全\n缺点: 无法预知所需资源的全集；进程可能被阻塞很长时间，等待资源，发生饥饿；资源严重浪费（某个资源可能只用极短时间）\n打破“非抢占”\n资源拥有者拒绝其它请求后释放资源，或从被申请资源拥有者处抢占\n适用条件：资源的状态可保存和恢复，如CPU寄存器、内存空间；不适用于打印机、磁带机\n缺点：实现复杂，代价大，反复申请&#x2F;释放资源，周转时间长，系统吞吐量低；undo、redo\n打破“环路等待”\n系统把所有资源按类型进行线性排队；所有进程对资源的请求必须严格按资源序号递增的顺序提出，保证任何时刻的资源分配图不出现环路。即：如果一个进程已经分配了R类型的资源，它接下来请求的资源只能是排在R类型之后的资源。\n摒弃“环路等待” 方法的问题：资源变化：资源序号要稳定； 资源浪费： 只用第一个和最后一个资源； 使用顺序和申请顺序不一致； 程序设计：考虑申请顺序，编写困难\n死锁避免不需事先破坏产生死锁的条件\n在系统运行过程中，对进程发出的每一个资源申请进行检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配（阻塞），否则予以分配。\n防止系统进入不安全状态, 从而避免发生死锁。\n安全状态：存在安全序列的系统状态\n安全序列：一个进程序列{P1，…，Pn}是安全的：如果对于每一个进程Pi(1≤i≤n），它尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。\n安全状态时一定没有死锁（当前状态非死锁，并不保证未来）\n死锁一定是不安全状态，但不安全状态下不一定会死锁\n \n总结\n\n优点\n​\t比死锁预防限制少\n​\t无死锁检测方法中的资源剥夺，进程重启\n\n缺点\n​\t必须事先声明每个进程请求的最大资源\n​\t进程必须是无关的：没有任何同步要求的限制\n​\t进程数量保持不变，分配的资源数目必须是固定的\n​\t在占有资源时，进程不能退出\n​\t保守的分配方案（设置条件严格）\n\n\n银行家算法\n当用户申请资源时，系统判断如果把这些资源分出去，系统是否还处于安全状态。\n若是，就可以分配这些资源； 否则，暂时不分配，阻塞进程。 \n安全性算法\n\n设Work和Finish分别是长度为m和n的向量，按如下方式进行初始化:\n\nWork &#x3D; Available\n\nFinish[i] &#x3D; false for i &#x3D; 1,2, …, n.\n\n\n\n查找这样的i使其满足:\n\nFinish[i] &#x3D; false\n\nNeed[i] &lt;&#x3D; Work\n\n如果未找到，转第4步.\n\n\n\nWork &#x3D; Work + Allocation[i]; Finish[i] &#x3D; True；返回第2步\n\n如果对所有的i, Finish[i]&#x3D;&#x3D;True，那么处于安全状态，否则不安全状态。\n\n\n**资源分配算法 **\n\nRequesti为进程Pi的请求向量。如果Requesti [j] &#x3D; k 那么进程Pi 所需要的资源类型Rj的实例数量为k。当进程Pi做出资源请求时，执行：  \n​\t若Requesti &lt;=Needi 转1.2；否则，出错退出；\n​\t若Requesti &lt;=Available 转2； 否则 Pi阻塞；\n\n假定系统可以分配给进程Pi所请求的资源，并按如下方式修改状态:\n​\tAvailable = Available - Requesti;\n​\tAllocationi = Allocationi + Requesti;\n​\tNeedi = Needi – Requesti;\n\n系统执行安全性算法\n​\t如果处于安全状态，那么Pi可分配到其所需资源;\n​\t如果新状态不安全，那么进程Pi必须等待，并恢复到原先资源分配状态\n\n\n实例\n\n死锁检测如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能会出现死锁。因此，系统应该提供：用来检查系统状态是否出现死锁的检测算法、从死锁状态中恢复的方法。\n\n死锁检测\n\n没有任何预先限制措施\n资源分配时不检查系统是否会进入不安全状态，被请求的资源都被授予给进程\n系统可能出现死锁\n周期性检测是否出现死锁（执行检测算法）\n\n\n检测时机\n\n在每个资源请求时都进行\n定时检测\n系统资源利用率下降时检测死锁\n\n\n简化资源分配图\n\n简化规则：若已分配和申请能满足需求，则删除边，使其成为孤立点→运行完毕后资源释放；\n在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全简化的；反之的是不可完全简化的。\n死锁定理：死锁状态的充要条件：资源分配图不可完全简化\n\n\n死锁定理与不安全状态的关系\n\n死锁定理：当前请求（request）\n不安全状态：所有剩余请求（need）\n\n\n\n死锁解除\n撤销进程\n\n终止所有的死锁进程\n一次终止一个进程直到取消死锁循环→基于某种最小代价原则\n\n\n选择原则\n\n已消耗CPU时间最少\n到目前为止产生的输出量最少\n预计剩余的时间最长\n目前为止分配的资源总量最少\n优先级最低\n\n\n资源剥夺：逐步从进程中抢占资源给其它进程，直到死锁环被打破为止 。\n\n选择一个牺牲品：抢占哪些资源和哪个进程，确定抢占顺序以使代价最小。\n饥饿：确保资源不会总是从同一个进程中被抢占\n\n\n进程回退：把每个死锁进程备份到前面定义的某些检查点，并且重新启动所有进程－需要系统构造重新运行和重新启动机制\n\n\n死锁忽略通常实际中采用的方式…摆烂的成本最低。 \n","slug":"OSreview1","date":"2023-03-16T14:27:01.000Z","categories_index":"复习笔记","tags_index":"OS","author_index":"涛"},{"id":"7da07456a3be614155ce9d5c6f12f8ad","title":"计算机操作系统复习笔记（三）","content":"目录\n前言\n文件管理：基础\n​\t\t基本概念\n​\t\t\t\t文件\n​\t\t\t\t文件系统\n​\t\t\t\t文件系统的实现模型\n​\t\t\t\t文件的组成\n​\t\t\t\t文件名\n​\t\t\t\t文件分类\n​\t\t文件结构\n​\t\t\t\t逻辑结构\n​\t\t\t\t物理结构\n​\t\t\t\t练习题 \n文件管理：目录\n​\t\t文件控制块FCB\n​\t\t\t\tFCB：File Control Block\n​\t\t\t\tFCB信息\n​\t\t目录\n​\t\t\t\t基本概念\n​\t\t\t\t目录功能\n​\t\t\t\t目录基本操作\n​\t\t\t\t⭐FCB组织方法\n​\t\t\t\t⭐改进的FCB组织方法\n​\t\t\t\t目录的组织\n​\t\t\t\t路径\n​\t\t\t\t无环图目录\n​\t\t\t\t链接\n​\t\t\t\t通用图目录\n文件管理：磁盘管理\n​\t\t空闲分区表\n​\t\t\t\t概念\n​\t\t\t\t特点 \n​\t\t空闲分区链表\n​\t\t\t\t概念\n​\t\t\t\t特点\n​\t\t位示图\n​\t\t成组块链接法\n​\t\t\t\t分配方法\n​\t\t\t\t释放方法\n​\t\t\t\t例题\n​\t\t文件一致性：盘块\n​\t\t\t\t链接数一致性检查\n​\t\t文件执行\n​\t\t\t\t数据结构\n​\t\t\t\t文件共享\n​\t\t\t\t文件操作\n​\t\t\t\t执行过程\n​\t\t虚拟文件系统 VFS\n\n前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：\n\nCM1****：操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。\nCM2****：进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。\nCM3****：内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。\nCM4****：设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。\nCM5****：文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。\n\n本节是最后一部分，要点在CM5，大致内容如下：\n第五章 文件管理（6 学时，多媒体课件结合板书面授）CM5\n1、主要内容文件和文件系统的概念，文件逻辑结构（堆文件、顺序文件、索引顺序文件、索引文件、HASH 文件），外存分配方法（连续分配、链接分配、索引分配），目录管理（一级目录、二级目录、多 级目录），文件存储空间的管理技术（位示图、空闲链表、索引）。文件系统性能的改善、数据一致性控制。\n2、应达到的要求 记忆：文件系统性能的改善、数据一致性控制。理解：文件系统的基本概念、目录管理、文件共享、文件保护的方法。\n分析：文件逻辑结构、文件的物理结构、文件目录、外存空间的管理。\n一共3个PPT，就分三大块：文件管理：基础、文件管理：目录、文件管理：磁盘管理。\n\n文件管理：基础\n基本概念文件\n一种具有符号名的、相关联元素的有序集合。\n用户按照信息的逻辑功能将关联存储单元组织成文件。\n文件是信息在磁盘上存储的基本逻辑单位。\n文件名：对相关联元素的Naming\n\n文件系统\n概念：\n\n对文件实施管理、控制与操作的一组软件。\n用户或应用程序访问文件的唯一方式\n\n\n\n\n目标与功能：\n\n&#96;&#96;&#96;\n\n保证文件中的数据有效\n减少或消除丢失或破坏数据的可能性\n从系统角度优化总吞吐量，从用户角度优化响应时间\n为各种类型的存储设备提供I&#x2F;O支持，并提供统一接口\n统一管理文件的存储空间，实施存储空间的分配与回收\n实现文件的按名存取：文件名字空间  存储空间\n实现文件信息共享，提供文件保护和保密措施\n  \n\n* 用户观点\n\n  ​\t&#96;实现“按名存取”功能&#96;\n\n* 操作系统观点\n\n  ​\t&#96;文件目录怎样实现、管理存储空间、文件存储位置、磁盘实际运作方式(与设备管理的接口)&#96;\n### 文件系统的实现模型\n\n* 文件系统接口：命令、系统调用和图形窗口的文件系统访问功能。 \n* 逻辑功能层：根据接口层所发下的文件访问需求，通过相关的文件控制块、文件目录、文件分配表等，获取访问存储介质的物理参数。  \n* 物理驱动层 ：将逻辑功能层所发下的命令转化为相应的驱动程序的动作，完成对文件物理存储设备的处理。\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;d084291ee84c4a399eb0a09cebf1780d.png)\n### 文件的组成\n\n* 文件&#x3D;元数据+文件内容\n* 元数据：文件名、内部标识(如unix的inode)、拥有者、访问时间&#x2F;权限、文件大小 ……\n### 文件名\n\n* 格式：A.B\n* A: 文件名称   B: 文件类型&#x2F;文件格式&#x2F;**文件扩展名**\n### **文件分类**\n\n* 对不同文件进行管理，提高系统效率\n* 提高用户界面友好性\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;c77880259e9c4ea6bb7fce0fcc5636bc.png)\n* 设备文件：统一的抽象接口（了解即可）\n\n----\n\n## 文件结构\n\n### 逻辑结构\n\n从用户角度研究文件的组织形式，独立于物理存储结构\n\n* **无结构文件：流式文件**\n  * 构成文件的基本单位是字节，文件是有逻辑意义的、无结构的一串字节的集合。\n  * 自身不提供任何数据结构 提供很大的灵活性\n  * 用户自定义文件内容含义\n\n* **有结构文件：记录文件**\n  * 文件是由若干个记录组成，每个记录有一个键，可按键进行查找。\n  * 记录(record)、字段(field)、键(key)\n  * ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;dadd4096e48c4c6b949b0db33cd52df3.png)\n\n* **文件组织与访问**\n  * 原则：![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fd9409a76e624b0386ec4ee734a9dc65.png)\n    * 原则可能互相矛盾（如索引 vs. 空间）\n    * 优先级取决于使用文件的应用程序\n\n  * 堆文件：数据按到达时间顺序存放；每个记录长度、字段数量不确定；随机访问效率极低，对大多数应用都不可用；例：log（日志文件）\n  * 顺序文件：所有记录有序排列（主字段）；字段定义、记录长度固定；批处理，顺序访问最佳；查询或更新记录的交互式应用，性能差；（随机）访问大型顺序文件时性能差（包含某个key的记录）\n  * 索引顺序文件：是一个顺序文件；将顺序文件中的记录进行分组(block)；索引表仅记录每组中第一个记录的信息；组与组之间记录的关键字必须有序排列；搜索非key字段困难\n\n  * ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;6fda3691276d410bac628179f2a3277e.png)\n  * 索引文件：每个索引项指向一个记录，索引项按照记录中的某个关键字排序；记录大小不必相同，不必排序，存放在主文件中。 可以对不同的关键字域建立多个索引；主文件中增&#x2F;减&#x2F;变更记录时，索引文件须相应更新\n  * 直接，散列&#x2F;哈希文件：记录的存储位置由以关键字为参数的哈希函数计算得到。 记录大小一般相同；检索时给出记录的关键字值，通过哈希函数计算出该记录在文件中的位置；访问速度快， 一次只需访问一条记录时使用。例：目录、价格表、调度和名字列表等。\n\n* **有结构文件和无结构文件的区别：**\n\n* ![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;88ffb956056b4655a6adac9f1195106a.png)\n\n### 物理结构\n\n文件的逻辑地址和物理地址文件在物理介质上的存放方式\n\n![](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2ce52501063f493e9b424a529eddf847.png)\n\n* 文件访问方法\n\n  * 用户在使用文件时按何种次序存取文件\n    * 顺序存取：按照文件信息的逻辑顺序(记录的排列顺序)依次存取。\n    * 随机存取(直接存取）：按任意的次序对文件进行读写操作\n\n  * 与文件使用方式有关\n    * 源程序文件用顺序存取\n    * 数据库文件用随机存取\n\n  * 与存储介质的特性有关\n    * 磁带\n    * 磁盘\n\n* **⭐文件分配表**\n\n* &#96;&#96;&#96;\n  * 为了有效地管理文件存储器，通常把文件存储空间划分成若干个大小相等的物理块。\n  * 物理块是分配及传输信息的基本单位。\n  * 块的大小通常是扇区的倍数，如512B、1KB、2KB或者4KB。\n  * 文件分配表：描述文件所获得物理块的详细信息，不同的操作系统赋予了该结构不同的名字\n  \t* DOS：FAT &#x2F; Windows NTFS: MFT (master file table)\n  \t* UNIX类操作系统：inode\n  * 分配方式\n  \t* 静态分配：文件创建时申明需要的最大空间\n  \t\t* 预分配，实现简单，易于维护，但灵活性差\n  \t* 动态分配：文件存储空间按需分配\n  \t\t* 实现较复杂，需要维护较多的数据结构，实用性高\n\n\n\n连续结构（顺序）\n\n文件信息存放在若干连续的物理块中\n优点：简单；支持顺序存取和随机存取；顺序存取速度快：磁盘寻道次数（寻道时间）最少\n缺点：不利于文件尺寸的动态增长（插入、删除）；可能会导致磁盘碎片，降低外存空间的利用率（可以采用紧凑技术处理，从而改善）。\n\n链接结构\n\n文件信息存放在若干不连续的物理块中，各块之间通过指针连接。\n\n隐式链接\n\n每个物理块都设有一个指针字段，指向下一个物理块的位置。\n随机访问性能差\n\n\n显式链接\n\n用于链接文件各物理块的指针，显示地存放在一张内存链表中，该表在整个磁盘中仅一张。\n随机性能优于隐式链接\n\n\n\n\n优点：提高了磁盘空间利用率，不存在外部碎片问题；有利于文件插入和删除\n\n缺点：更多的寻道次数和寻道时间；随机访问性能差；可靠性问题，如指针出错\n\n改进方法：扩大文件块分配单位。若干个连续的数据块，称之为簇(Cluster)。\n\n簇（Cluster）\n一组连续的扇区→虚拟扇区\n分配单位 Cluster&#x3D;2^n Sectors\n\n\n\n\n\n索引结构文件信息存放在若干不连续物理块中，每个文件关联一个索引表，记录块号\n索引表就是磁盘块地址数组，第i个条目指向文件的第i块\n优点：支持随机存取（优于链接结构，找第i块更快）；满足了文件动态增长、插入删除要求；利用多级索引，可以支持大型文件的存取\n缺点：较多的寻道次数和寻道时间（对比页表）\n一个数据块容纳不了一个文件的所有分区时，需要若干个索引结点进行存储\n多级索引\n\n盘块大小：1 KB，每个盘块号：4B\n\n一个索引块中可存放1K/4B=256个盘块号\n两级索引时， 最多可包含的存放文件的盘块总数N = 256 × 256 = 64 K个盘块号。\n最大文件长度：64MB\n\n\n计算：盘块大小：4KB，盘块号：4B，一级、两级索引时最大文件分别为？\n\n4KB/4B=2^10;  1_file=2^10/*4KB=4MB; 2_file=2^10/*2^10/*4KB=4GB\n\n\n\n⭐综合&#x2F;混合模式\n将多种索引分配方式相结合而形成的一种分配方式。\n例如，系统既采用了直接地址，又采用了一级索引分配方式，或两级索引分配方式，甚至还采用了三级索引分配方式。\nUnix iNode\n13个索引项，每项2个字节 前10项为直接块\n\n第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。\n\n第12和第13项作为二次和三次间接寻址\n\n单个文件最大长度：（10+256+256&#x2F;*256）&#x2F;*block-storage\n\n\n\n练习题设文件索引节点中有7个地址项 4个直接地址索引 2个一级间接地址索引 1个二级间接地址索引 每个地址项大小为4B 磁盘索引块和磁盘数据块均为256B\n问：单个文件的最大长度是多少？\n答：每个索引块中的项目数为：256&#x2F;4&#x3D;64个\n4个直接地址索引块，可索引块数：4\n2个一级间接地址索引块，可索引块数：2×64&#x3D;128\n1个二级间接地址索引块，可索引块数：1×64×64&#x3D;4096\n*单个文件的最大长度为：（4+128+4096)&#x2F;256B&#x3D;1057KB\n假定UNIX磁盘块的大小为1KB，每个盘块号占4个字节，文件索引节点中的磁盘地址明细表如图所示，请将下列文件的字节偏移量转换为物理地址？\n1． 9000          2． 14000             3． 350000 \n\n答：字节偏移量为9000时\n逻辑块号为：9000&#x2F;1024＝8 块内偏移量为：9000 % 1024＝808 逻辑块号小于10→该块为直接块。逻辑块号8对应的物理盘块号为367，该块中的第808字节即为文件的第9000字节。 \n字节偏移量为14000时\n逻辑块号为：14000&#x2F;1024＝13 块内偏移量为：14000 % 1024＝688 逻辑块号9&lt;13&lt;266→该块为一次间接块。 一次间接的盘块号为428，从一次间接块中读出盘块号表，查得逻辑块号13的物理块号为952，该块中的第688字节即为文件的第14000字节。\n字节偏移量为350000时\n逻辑块号为：350000&#x2F;1024＝341 块内偏移量为：350000 %1024＝816 因逻辑块号265&lt;341&lt;65802(256&#x2F;*256+256+10)→该块为二次间接块。 由图可知，二次间接块的盘块号为9156。一个一次间接块中可容纳256个块号，341-10-256＝75 75&#x2F;256&#x3D;0，故字节偏移量350000在二次间接块的第0个一次间接块的第75个表项中，其盘块号为333，该块中的第816字节即为文件的第350000字节。\n\n文件管理：目录文件控制块FCBFCB：File Control Block描述和控制文件的数据结构 与文件一一对应\n文件存在的标志\n文件控制块的组成——与操作系统相关\nFCB信息文件名：用户利用该名字进行存取。\n文件物理位置：在外存的存储位置（设备名、起始盘块号、占用的盘块等）\n使用信息：创建时间：create time ；最后一次读访问的时间：access time ；最后一次写访问的时间：modify time\n\n目录基本概念文件目录：一组文件的集合\n目录：文件元数据（控制块）的集合\n目录文件：目录项构成的文件\n递归效果：目录也用FCB表示\n**目录即文件 **\n目录文件具有固定格式 由系统进行管理，用户不能直接访问目录文件\n目录功能\n按名存取\n\n提高检索速度\n\n合理地组织目录结构，可以加快对目录的检索速度，从而提高对文件的存取速度。\n\n\n文件共享\n\n允许共享文件，节省存储空间，方便用户。\n\n\n允许文件重名\n\n方便用户按照自己的习惯来命名和使用文件。\n\n\n\n目录基本操作\n罗列文件\n\n搜索文件\n\n通过查找目录结构，实现特定文件的按名查找\n\n\n创建文件\n\n建立新文件，将相应控制块加到目录中去\n\n\n删除文件\n\n当一个文件不再需要时，从目录中删除\n\n\n重命名文件\n\n\n⭐FCB组织方法计算: 一个FCB有48字节，假设物理块512字节，某目录有128个文件。 计算查找一个文件平均访盘次数。\n\n每块存储的FCB数量：512&#x2F;48&#x3D;10\n128个文件的目录文件需要磁盘块：128&#x2F;10&#x3D;13\n平均访盘次数：(1+13)&#x2F;2&#x3D;7**(最少一次找到，最多13次，取均值)**\n\n⭐改进的FCB组织方法采用目录项分解法，把FCB分成两部分\n\n一个FCB有48字节，符号目录项占 8字节（文件名6字节，文件号2字节），假设物理块512字节，某目录有128个文件。 采用改进的FCB组织方法，查找一个文件平均访盘次数。\n每块存储的符号目录项：512&#x2F;8&#x3D;64\n每块存储的基本目录项：512&#x2F;42&#x3D;12\n128个文件，符号文件、基本文件分别需要：128&#x2F;64&#x3D;2, 128&#x2F;12&#x3D;11\n平均访盘次数：(1+2)&#x2F;2+1&#x3D;2.5**(最少一次查找符号目录，最多两次，取均值，再加上一次精准查找的基本目录项)**\n目录的组织\n组织文件目录是文件系统的主要内容之一\n\n有效性：快速定位一个文件\n\n命名：用户使用方便\n\n两个用户对不同的文件可以使用同一个文件名\n同一个文件可能有不同的文件名\n文件数据，元数据\n\n\n\n\n空目录≠文件数为0的目录：不存在文件数为0的目录！\n\n单级目录结构\n\n所有文件都包含在同一目录中\n缺点：查找速度慢；不允许重名；不便于共享；不能分组\n\n\n两级目录结构\n\n为每个用户创建单独的目录\n用户文件目录UFD 主文件目录MFD\n\n优点：不同用户可以有相同的文件名；提高了检索速度；将一个用户与另一个用户有效隔开  \n缺点：不利于文件的共享\n\n\n树状目录结构\n\n\n每一级目录可以包含文件，也可以包含下一级目录。\n只有一个根目录，除根目录外，其余每个目录或者文件都有唯一的一个上级目录。（父目录、子目录）\n优点：文件的层次和隶属关系清晰；便于实现不同级别的存取保护和文件系统的动态装卸\n缺点：不便于共享（相比较而言）\n\n\n\n路径从树根(namespace)到节点的唯一表达\n不同文件→文件可以同名，但路径名不同。（路径名不同 ≠ 文件不同）\n文件可按照相对于工作目录的方式访问：\n绝对路径(absolute)：从根目录开始指定\n相对路径(relative)：从当前工作目录开始（.&#x2F;当前目录）（..&#x2F;上一级目录）\n练习：当前目录&#x2F;spell&#x2F;mail&#x2F;copy 请用绝对和相对路径表达红色箭头文件\n\nprog: .&#x2F;prog ; &#x2F;spell&#x2F;mail&#x2F;prog\nfind:  …&#x2F;programs&#x2F;p&#x2F;find ; &#x2F;programs&#x2F;p&#x2F;find\nall: &#x2F;all ; &#x2F;spell&#x2F;mail&#x2F;copy&#x2F;all\nfirst: .&#x2F;prt&#x2F;first ; &#x2F;spell&#x2F;mail&#x2F;prt&#x2F;first\n无环图目录在树型目录的基础上，允许多个目录项指向同一个数据文件或者目录文件，实现了目录或者数据文件的共享\n一个文件或者目录在多个父目录中占有项目\n目录结构不再是一颗树，而是一个无环图\n\n实现共享文件：多个用户同时访问一个文件，可节约存储空间\n数据复制：数据不一致\n通过路径名共享：不灵活\n链接：在多个目录中对要共享的文件建立相应的表项，一个文件或目录在目录树中多处出现（引用） 在外存上只有一份物理存储。\n链接\n硬链接：多个文件名链接到同一个索引结点，链接文件和被链接文件必须位于同一个文件系统中。\n软链接：符号链接(symbolic link, shortcut) 特殊类型的文件，其内容是另一个目录或文件的路径。 无硬链接的限制，可跨盘，跨目录，甚至跨机器。建立符号链接文件，并不影响原文件→它们是独立的文件。 \n缺点： 空间和时间开销更大；如果设置不当，上下级目录关系可能会形成环状\n硬链接和软链接的比较\n硬链接\n只允许文件链接，不允许目录链接；\n只能在同一个文件系统范围内进行，不允许跨文件系统。\n删除文件时，如果还有其他链接链至该文件，则该文件不能被删除。\n软链接\n访问速度相对慢一些，但适用范围和灵活性要大一些。\n允许目录链接，允许在不同的文件系统间进行链接，这两个文件系统可以在同一个计算机上，也可以在不同的计算机上。\n被链接文件的删除和符号链接的删除是完全独立的\n通用图目录无环图目录结构中，加上允许子目录对上层目录的引用的条件\n\n允许环存在：搜索子目录时要避免无穷地循环搜索——限制访问目录的次数来确定；释放孤立环（orphan cycle）——垃圾回收（garbage collection） 。\n\n文件管理：磁盘管理磁盘存储器\n文件存储空间的分配单位是磁盘块而非字节；\n文件系统必须记录存储空间的使用情况；\n文件系统对存储空间进行分配和回收；\n常用的磁盘空间的管理方式有：\n\n\n空闲分区表概念将空闲分区登记在一张表中，一个分区对应一个表项，每个表项包含有空闲分区号、分区起始块号、分区长度等主要信息，按起始块序号排序\n\n特点\n实现简单\n将各空闲分区按照长度有序进行排列，能很快找到需要大小的空闲分区。 (排序规则不固定）\n当空闲分区分布较分散且数量较多时，空闲分区表将会很大。\n\n  \n\n空闲分区链表概念利用空闲分区空间通过指针将各个空闲分区连接起来，并记载各空闲分区大小。\n无空闲分区表的额外空间开销。\n特点回收由许多离散小分区组成的文件时，小分区链接到空闲分区链表中需要很长时间（按照某种规则，大小或者位置）。\n类比可变分区管理\n\n\n位示图\n一个向量，每位(bit)对应于磁盘中的一个块(block)\n\n空闲块：0，已使用块：1\n\n\n方便地查找一个或一组连续的空闲分区。\n\n位示图需要占用的存储空间大小\n\n磁盘容量（字节数）/ （8×数据块大小） Byte\n\n\n大位示图搜索将会降低文件系统的性能\n\n\n \n\n成组块链接法\n将所有空闲块每n块划分为一组，用索引表表示\n\n每组的第一块用来存放后一组中各块的块号和总块数\n\n各组间自然构成链表\n\n\n第一组的块号与总块数放在一个专用栈中：空闲盘块号栈\n\n栈计数count：栈中的空闲块数目\n栈中的元素是空闲块编号\n\n\n对块的分配和释放在栈中进行\n\n\n\n分配方法\n查看栈中是否count&#x3D;&#x3D;1，若不是，那么就弹出栈顶元素N（表示可用磁盘块号），分配出去，–count；若是，弹出栈顶元素N，把空闲块N中的内容读入到栈中；返回空闲块编号N。因为所分配的磁盘块号是栈中最后一个可用盘块号，由于在该盘块中存放了下一组的所有盘块号，于是要先将该块的内容读入栈中，然后才能将该块分配出去\n\n释放方法\n被释放空闲块为编号N。查看是否栈已满，若不是，则N入栈，++count； 若是，则将栈（包括栈计数）写入到空闲块N，然后把N放入栈顶并置count为1。说明栈已满，须先将栈中所有盘块号复制到新回收的盘块中，再将新回收盘块的编号放到栈中，成为栈中第一个盘块\n\n例题\n**解：92&#x3D;41+50+1，所以是&#x2F;#400最下面的一个，也就是401。 **\n\n文件一致性：盘块链接数一致性检查每个目录项都含有一个索引结点号\n共享文件的索引结点号会在目录中出现多次\n若某文件被共享（硬链接）N次，其索引结点号会在目录中出现N次；\n另一方面，该共享文件索引结点中的链接计数count，用来指出共享本文件的引用数。\n正常情况下这两个数据应该一致\n数据块使用数组和空闲数组互补\n\n\n文件执行\n数据结构用户打开文件表：每个进程一个，记录用户打开文件 \n系统文件打开表：整个系统一张：放在内存，用于保存已打开文件的FCB文件号、共享计数（打开共享）、读写位置、打开模式、修改标志等；指向内存inode（也有共享计数）\n内存inode表：操作文件时要将磁盘inode加载到内存中；访问速度；共享控制（计数）\n三张表之间的关系\n\n文件共享不同进程独立访问\n\n同进程复制fd：dup() &#x2F; dup2() &#x2F; fcntl()\n\n跨进程复制fd：fork() \n\nfork()可以共享文件，但是**fork()以后打开文件则不共享 **\n文件操作\n执行过程create：实质是建立FCB，返回一个文件描述符\nopen：把FCB送到内存，创建用户、系统打开文件表项，建立与内存inode三者关联，返回文件描述符\nclose：缓存数据写回磁盘；清理用户文件打开表；清理系统文件打开表；清理内存inode表\n\n虚拟文件系统 VFS支持面向对象式的文件系统实现——多态\n用户程序：统一接口\n底层支持：不同文件系统\nVFS接口：API，而非具体的文件系统实现\n\n","slug":"OSreview3","date":"2023-03-16T14:27:01.000Z","categories_index":"复习笔记","tags_index":"OS","author_index":"涛"},{"id":"bfead0d4bc485b773913efadd71ce0ad","title":"人工智能复习笔记","content":"第一部分 搜索问题目录\n​\t前言\n​\t人工智能历史\n​\t搜索问题\n​\t\t什么是搜索问题？\n​\t不知情搜索算法（Uninformed Search） \n​\t\t一些重要概念\n​\t\t深度优先搜索（DFS）\n​\t\t广度优先搜索（BFS） \n​\t\t代价敏感搜索（CCS） \n​\t\t代价一致搜索（UCS） \n​\t知情搜索算法（Informed Search） \n​\t\t启发式搜索（Heuristics Search） \n​\t\t贪心搜索（Greedy Search） \n​\t\tA*搜索\n​\t\t图搜索（Graph Search） \n​\t\t例题\n​\t\t实验：A*算法解决八数码问题\n​\t对抗搜索\n​\t\t零和游戏（Zero-sum Games）\n​\t\t极小化极大算法（Minimax Algorithm）\n​\t\tAlpha-Beta剪枝算法（Alpha-Beta Pruning） \n​\t\t例题\n\n人工智能历史\n\n搜索问题什么是搜索问题？​\t\t一个搜索问题包括一个状态空间，一个后续函数（包括动作，成本），一个开始状态和一个目标状态。\n​\t\t状态空间：当前“世界”所处的状态所有可能性的集合，假设整个状态空间是一段视频，那么状态就是视频的某一帧截图，它就是组成\t\t状态空间的一种可能。\n​\t\t后续函数：搜索问题的核心，它决定了代理下一步的动作是什么，也就是通过搜索算法来得出当前状态下如何决策是最符合预期的。\t\t后续函数中的参数必然含有动作和成本等协助判断的重要条件，通过这些条件就可以比对出当前状态下最好的决策。\n​\t\t解决方案：搜索问题的目标，是指将开始状态转换为目标状态的一系列操作（计划）。\n​\t计算状态空间的大小\n将所有可能的环境&#x2F;动作全部相乘。\n\n很好理解，总状态空间就是代理位置、食物数量、敌人位置、代理方向四个因素来决定，而代理位置有120种可能，每一颗食物有存在&#x2F;不存在两个状态，所以是2^30种可能，敌人有两个，一共有12种位置，所以敌人位置就有12^2种可能，代理的朝向有四种，就是4种可能。所以总状态空间的大小就是将它们相乘即可。 \n状态空间图与决策树\n\n搜索树中的每个节点都是状态空间图中的一个完整路径，两者都可以按需构建，还可以互相转化，例如根据状态空间图绘制决策树。\n例：将图示状态空间图转化为决策树\n\n我们引入两个列表：open_list 与 closed_list ，分别表示当前正在搜索的节点和已经搜索完毕的节点。open_list 初始只有起始状态S节点，而 closed_list 初始是空的。\n求解过程：（这里其实使用了广度优先搜索）\n\n\n不知情搜索算法（Uninformed Search）一些重要概念​\t完备：如果有解，一定能找到\n​\t最优：保证能找到代价最小的路径\n​\t时间复杂度：算法中的基本操作的执行次数，为算法的时间复杂度。\n​\t空间复杂度：空间复杂度算的是变量的个数\n深度优先搜索（DFS）从上到下，从左到右\n边缘节点是后进先出的堆栈形式\n\n在有限状态空间中，DFS是完备的\nDFS不是最优的 （它只能找到解，在一定条件下也并不保证代价最小）\n广度优先搜索（BFS）从左到右，从上到下\n边缘节点是先进先出的队列形式\n\n在有限状态空间中，BFS是完备的\n在动作未加权时，BFS是最优的\n补充：迭代深化（Iterative Deepening）是旨在将DFS和BFS的优势结合在一起，既然BFS能够找到最浅的(最优的)解，而DFS可能会先找到较深的解，因此我们可以限制深度，先限制DFS的深度为3去搜索，如果没有找到就用最大深度为4的DFS去找，以此类推......这样就可以找到最浅的解从而节约算力。\n\t为什么？明明多次迭代，为何反而节约算力？这是因为**大量的计算通常在更深层**，我们在浅层多次迭代不会影响太多时间&#x2F;空间复杂度。\n\n \n代价敏感搜索（CCS）如下图，如果使用上述方法，无论是DFS，BFS抑或是迭代深化，都只能得到经过节点最少的路径，但是如果每个动作标明代价（加权）的话，经过最少节点的路径就不一定是最优解了。因此，上述方法并不能在代价敏感搜索当中得到最优解，只能通过进一步计算，算出代价从而选出代价最小的路径来实现。\n \n如上图，一共能找到两条路径：SderfG，SerfG。然而代价却分别是3+2+2+2+2&#x3D;11和9+2+2+2&#x3D;15，反而是经过节点较多的SderfG为最优解！\n代价一致搜索（UCS）优先扩展代价最小的节点\n（类似Dijkstra算法）\n\n它是完备的且最优的\n但缺点是每个方向都可能扩展，且不知道目标的确切方向会显得盲目（不知情搜索&#x2F;Uninformed Search是这样的）\n*【解决方法：将UCS和Greedy（贪心算法）结合起来形成A&#x2F;算法…下文会讲到】\n\n知情搜索算法（Informed Search）\n如上图，知情搜索算法要讲解的分别为：启发式搜索，贪心搜索，A-star搜索，图搜索。\n启发式搜索（Heuristics Search）一个启发式是：\n\n▪一个函数，估计一个状态与目标的距离\n\n▪为一个特定的搜索问题设计\n\n▪例子：曼哈顿距离，欧氏距离\n\n\n如图，10+5就是曼哈顿距离：横坐标之差与纵坐标之差的和；11.2是欧氏距离：直线距离。\n这样的函数就叫作启发式函数，记作h(x)。 \n贪心搜索（Greedy Search）**优先扩展当前状态下最优的节点 **\n\n与UCS不同，UCS只考虑当前代价，而Greedy考虑了距离终点的距离。\n它不是最佳的！通常它只考虑了距离而非代价，贪心算法的优劣很大程度上取决于启发式函数h(x)。 \nA*搜索A*搜索综合了UCS和Greedy，有两个评估函数g(x)与h(x)，而A&#x2F;*搜索的决策取决于f(x)&#x3D;g(x)+h(x)，综合考虑了前驱因素与后继因素。\n\nA*是完备且最优的。当f(x)&#x3D;g(x)+0时就找到了最优解。\n【但这里有一个大前提】：那就是估计节点到终点的距离时（h(x)）一定要小于等于实际中s点到终点的距离才行，这叫做可采纳的试探（Admissible Heuristics）\n\n 例如下图：\n\n因此，提出一个可接受的启发式方法是A*算法的需要解决的重要内容（实际上上文提到过的曼哈顿距离和欧氏距离就是很好的启发式方法）。 \n总结：\n\nA*用前驱和（估计的）后继成本来决策；\n\nA*在可接受的启发式方法下是最优的；\n\n启发式设计是关键所在，常用于宽松问题（Relaxed Problems）\n\n\n图搜索（Graph Search）一种在图中寻找路径的方法。\no 图中每个节点对应状态空间中的一个状态 ;o 每条连线对应一个操作符 ( 多数包含它的代价 ) 。** \n 常用开关列表来解决问题：\n1) 建立一个只含有 起始节点 S 的 搜索图 G ， 把 S 放到一个叫做 OPEN 的未扩展节点表中\n2) 建立一个叫做 CLOSED 的已扩展节点表， 其 初始为空表\n3)LOOP ：若 OPEN 表是空表，则失败退出\n4) 选择 OPEN 表上的第一个节点 , 把它从 OPEN 表移出并放进 CLOSED 表中。称此节点为 节点 n\n5) 若 n 为 目标节点， 则有解并成功退出，此解是追踪图 G 中沿着指针从 n 到 S 这条路径而得到的 ( 指针将在第 7 步中设置 )\n6) 扩展 节点 n ，同时 生成不是 n 的祖先的那些后继节点 的 集合 M 。把 M 的这些成员作为 n 的后继节点添入 图 G 中\n7) 生成并记入 M 的子节点有以下三种情况：\n① 未曾在G中出现过 的每个M成员：设置一个通向n的指针，并把它们加进OPEN表\n② 已经在OPEN表上 的每一个M成员，确定是否需更改通到n的指针方向。\n③ 已在CLOSED表上 的每一个M成员：除需确定该子节点指向父节点的指针外，还需确定其后继节点指向 父节点 的指针(也就是，如该子节点的父节点根据需要(如代价值等)改变了，那就把该子节点 移回Open表 )\n8) 按某一任意方式或按某个探试值， 重排 OPEN 表\n9)GO LOOP\n\n** **\n例题用要求的五种搜索算法计算从A到E的最优路径\n 解：\n\n\n实验：A*算法解决八数码问题八数码问题是在 3×3 的九宫格棋盘上，摆有 8 个刻有 1 ～ 8 数码的将牌。棋盘中有一个空格，允许紧邻空格的某一将牌可以移到空格中，这样通过平移将牌可以将某一将牌布局变换为另一布局。针对给定的一种初始布局或结构（目标状态），问如何移动将牌，实现从初始状态到目标状态的转变。如下图表示了一个具体的八数码问题求解。\n解：\n\n选用已经走过的步数为g(n)，选择当前状态与目标状态相异的数字的曼哈顿距离之和为h(n)，得到**估价函数f(n)&#x3D;g(n)+h(n)**。\n选用open表与close表来维护状态图，如果当前状态已经在开&#x2F;关列表中，取最小的一个保留。每次都选当前f(n)最小的作为待搜索节点。\n判断无解情况：将当前状态与目标状态的九宫格转化为线性，分别计算逆序数的个数，如果逆序数奇偶性一致则有解，反之则无解。\n\n\n对抗搜索零和游戏（Zero-sum Games）\n代理有着相反的目标\n\n一个代理的分数高，另一个的分数就会必然变低\n\n\n极小化极大算法（Minimax Algorithm）Minimax算法又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。Minimax算法常用于棋类等由两方较量的游戏和程序，这类程序由两个游戏者轮流，每次执行一个步骤。我们众所周知的五子棋、象棋等都属于这类程序，所以说Minimax算法是基于搜索的博弈算法的基础。该算法是一种零总和算法，即一方要在可选的选项中选择将其优势最大化的选择，而另一方则选择令对手优势最小化的方法。\nMinimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。\n例子：\n现在考虑这样一个游戏：有三个盘子A、B和C，每个盘子分别放有三张纸币。A放的是1、20、50；B放的是5、10、100；C放的是1、5、20。单位均为“元”。有甲、乙两人，两人均对三个盘子和上面放置的纸币有可以任意查看。游戏分三步：\n\n甲从三个盘子中选取一个。\n乙从甲选取的盘子中拿出两张纸币交给甲。\n甲从乙所给的两张纸币中选取一张，拿走。\n\n其中甲的目标是最后拿到的纸币面值尽量大，乙的目标是让甲最后拿到的纸币面值尽量小。\n解：由于示例问题格局数非常少，我们可以给出完整的格局树。这种情况下我可以找到Minimax算法的全局最优解。而真实情况中，格局树非常庞大，即使是计算机也不可能给出完整的树，因此我们往往只搜索一定深度，这时只能找到局部最优解。\n正方形表示甲决策（挑选最大），三角形表示乙决策（挑选最小）：\n最终甲期望得到的纸币面值为20，所以他应当选1号盘子为最优决策。 总结一下Minimax算法的步骤：\n\n首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。\n在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。\n自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。\n每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。\n\n注意：\n\n真实问题一般无法构造出完整的格局树，所以需要确定一个最大深度D，每次最多从当前格局向下计算D层。\n因为上述原因，Minimax一般是寻找一个局部最优解而不是全局最优解，搜索深度越大越可能找到更好的解，但计算耗时会呈指数级膨胀。\n也是因为无法一次构造出完整的格局树，所以真实问题中Minimax一般是边对弈边计算局部格局树，而不是只计算一次，但已计算的中间结果可以缓存。\n\nAlpha-Beta剪枝算法（Alpha-Beta Pruning）剪枝算法规则：\n1. Max层的α &#x3D; max(α， 它的所有子结点的评价值)，Max层的β &#x3D; 它的父结点的β2. Min层的β &#x3D; min(β， 它的所有子结点的评价值)，Min层的 α &#x3D; 它的父结点的α3. 当某个结点的 α &gt;&#x3D; β，停止搜索该节点的其他子结点4. 叶结点没有 α 和 β \n它极大减小了时间复杂度，在深层的搜索中减少了计算的负担。\n我们一一说明这四条性质：首先我们假设所有非叶结点的α初始化为负无穷，β初始化为正无穷。\n\n若Max层中发现有一个子结点的评价值比当前所能达到的评价值更大，换句话说就是子结点的操作更优，那么将当前所能达到的评价值换成该子节点的评价值。并且由于它的父结点是从该Max层中选择最小的评价值，那么他就要判断一下当前的α是否大于它父结点的β。为了方便起见，我们将父结点的β赋给它自己的β，这样我们只需要比较它自己的α和β就可以了。\n跟第一条类似，如果发现子结点中有比当前更优的操作（对对手更优，即对自己更差），那么就替换β，同时比较父结点最优解与当前解的大小，如果父结点已经有一个更优解，则不必继续搜索了。\nMax层中，若某个结点的最优解已经大于它的父结点的最差解，则不必继续搜索，剪枝；Min层中，若某个结点的最差解已经小于它的父结点的最优解，则不必继续搜索，剪枝。\n由于叶结点没有子结点，自然不需要计算 α 和 β。\n\n例题\n解：\n\n\n第二部分 MDP和强化学习目录\n​\t前言\n​\t期望最大搜索（Expectimax Search）\n​\t⭐马尔科夫决策（MDP）——offline（超重点）\n​\t\t先来看一个例子\n​\t\t基本概念 \n​\t\t\t政策（Policy）\n​\t\t\t折扣（Discounting）\n​\t\t\t如何停止循环？\n​\t\t\t价值迭代（Value Iteration） \n​\t\t\t例题 \n​\t\t固定策略（Fixed Policies）\n​\t\t策略提取（Policy Extraction）\n​\t\t策略迭代（Policy Iteration）\n​\t\t策略迭代和价值迭代的比较\n​\t强化学习（Reinforcement Learning, RL）——online\n​\t\t简介\n​\t\t基于模型的强化学习（Model-Based RL，MBRL）\n​\t\t无模型强化学习（Model-Free RL，MFRL）\n​\t\t\t直接评估(Direct Evaluation)\n​\t\t\t时间差分学习(Temporal Difference Learning)\n​\t\t主动强化学习（Active Reinforcement Learning）\n​\t\t\tQ-Learning \n​\t\t\t探索与利用 \n\n前言在上一节中，我们提到了Minimax是一种悲观算法，即考虑最坏的情况（Worst Case）从而使损失最小化。然而在实际操作过程中，对手并不是始终能做到最优决策，会有一定概率的失误，因此我们应当计算平均能得到的分数。\n\n当不确定的结果会偶然出现时，也就是在不确定性搜索（Non-Deterministic Search）下，我们的算法就需要做出调整。\n\n期望最大搜索（Expectimax Search）在前言的条件下，对手不一定足够smart去得到最优解，因此，我们将对手节点视作chance nodes，它具有一定的概率去实行一定的策略，此时的策略是使得expected utility最大。值现在应该反映平均情况（预期）结果，而不是最坏情况（最小）结果。上一节提到的minimax实际上是expected max的一种概率为1或0的特例。\n▪期望搜索：计算平均分数下最优玩法\n\n▪最大节点和Minimax一致\n\n▪机会节点类似Minimax的最小节点但结果不确定\n\n▪计算他们的预期效用\n\n▪即加权平均（期望）子节点\n\n注意：在expectimax中最好不要进行剪枝操作，因为min层的计算需要依据下一层的每一个值（如果概率不是非0即1那种）\n\n选择minimax策略的agent总是过于悲观，因此分数不会太高，但胜率会很高；而选择expectimax策略的agent过于乐观（比如万一有一种情况分数很高但概率相对不高，在计算的结果中，导致此算出来的期望值很高，agent会选择这种策略，但事实上，opponent很有可能选择其他路并且令agent分数减少）\n\n\n\n\n⭐马尔科夫决策（MDP）——offline（超重点）MDP是一个五元组&lt;S，A，T，R，γ&gt;——状态空间、行为、状态转移概率、奖励、折扣因子\n先来看一个例子\n只有一个主体，存在障碍，惩罚出口和奖励出口，主体可以任意移动但是有概率出现偏差移动，如果移动碰到墙体则呆在原地，每行动一步会有小的存活奖励（正&#x2F;负&#x2F;0都可）.。\n我们的目标是使主体得到的分数最大化。 \n如下图，以前的决策是左边的情况，而现在要解决的是随机问题\n\n基本概念这就要用到马尔科夫决策过程（MDP）：\nMDP定义为：\n\n▪一组状态集S\n\n▪一组动作集A\n\n▪一个过渡函数T（s,a,s&#39;）\n\n        ▪从状态s到状态s&#39;的概率，例如，P（s&#39;|s, a）\n\n        ▪也称为模型或动态\n\n▪奖励函数R（s,a,s&#39;）\n\n        ▪有时只是R (s)或R (s&#39;)\n\n▪一个起始状态\n\n▪也许存在结束状态\n\n▪马尔科夫决策过程，“马尔科夫”意味着行动结果只取决于当前状态\n\n▪这就类似搜索，后继函数只能取决于当前状态（而非历史状态）\n\n▪MDPs是**非确定性搜索问题**\n\n▪解决它们的一种方法是**期望最大搜索\n\n政策（Policy）在确定性单代理搜索问题，我们想要一个从起始节点到目标节点的最优计划，或序列的行动。\n在MDP中，我们需要一个最优政策，它在每一个状态下都给出一个动作，并且尝试在最后得到最大的效益，显式的策略定义了主体的反应倾向，如下图：\n\n能观察到，在不同的生存奖励下，主体的行动倾向都有所不同。 \n折扣（Discounting）如上图，当生存奖励的负分偏小时，在更为危险的地块中agent会宁愿选择一直对墙试错从而让自己滑行到两侧而非冒险按正确的朝向走，这可能会与我们的实际预期不符，因为它走做了太多无用的动作。这时我们就要给奖励添加折扣，让agent尽可能快的拿到最大的奖励：\n▪最大化奖励的总和是合理的\n\n▪更喜欢马上获得的奖励而非以后的奖励也是合理的\n\n▪一个解决方案：奖励的值呈指数衰减\n\n\n例如，折扣为0.5时，U([1,2,3]) &lt; U([3,2,1])。\n**U([1,2,3]) &#x3D; 1&#x2F;*1 + 0.5&#x2F;*2 + 0.25&#x2F;*3；U([3,2,1]) &#x3D; 1&#x2F;*3 + 0.5&#x2F;*2 + 0.25&#x2F;*1  **\n例如：\n\n在状态d时，γ为多少时往左或右的收益一致？\n解： ，解得γ＝ 。\n如何停止循环？如果一个游戏可以一直进行，怎么让它停下来并呈现出我们的分数？\n\n可以设置在进行n步之后必须结束游戏（life&#x2F;生命周期）\n\n可以设置动态变化的政策，例如随着可用步数的减少，政策随之变化\n\n可以设置折扣，到最后奖励值会趋于收敛，当分数变化小于某个临界时可以结束游戏 \n\n可以设置一个“吸收节点”，当进入这个节点时必须退出游戏，这个节点在前面的阶段不会进入，但到后面终将有可能进入这个状态。\n\n\n价值迭代（Value Iteration）\n起始价值和为0，因为还没有开始迭代\n给定某一向量的价值，开始向后迭代\n\n\n\n重复迭代直至收敛\n\n \n值迭代缺点：\n\n速度慢——每次迭代时间复杂度 O(S²A)\n每个状态的“最大值”很少改变\npolicy通常早在values之前收敛\n\n \n举例：汽车运行问题\n\n\n例题\n\n\n固定策略（Fixed Policies）固定每一步的action由函数π(s)得到，那么V值计算如下，其实和价值迭代没太大区别\n\n\n策略提取（Policy Extraction）在知道每一步的最优价值V&#x2F;*(s)时，还需要进行一个arg max()操作来求得执行哪个action会得到此最优价值\n\n \n\n\n策略迭代（Policy Iteration）包括两部分：\n 策略评估：对于固定策略π ，通过策略评估得到V值，迭代直至v值收敛\n\n策略提升：对于固定策略的V值，使用策略提取获得更好的策略：\n\n局限：在不知道T和R时无法更新V\nidea：对结果 s’（通过做动作！）和平均值进行采样\n\n\n策略迭代和价值迭代的比较两者本质上都是计算最优value，都是用于解决MDP的动态程序\n价值迭代：\n\n每次迭代都更新value和policy\n不跟踪policy，但在选择最大Q值时会隐式的重新计算他\n\n策略迭代：\n\n使用固定策略进行了几次更新实用程序的传递（每次传递都很快，因为我们只考虑一个动作，而不是所有动作）\nAfter the policy is evaluated, a new policy is chosen（慢如值迭代传递）\n新policy会更优\n\n\n强化学习（Reinforcement Learning, RL）——online简介强化学习与MDP的区别就在于：我们不明确转化函数和奖励函数的具体内容，必须切实地去尝试以后才能得出结论！\n\n所以说，强化学习是一种在线学习方式，只能靠自己试错来得出正确的决策。 \n基于模型的强化学习（Model-Based RL，MBRL）*step1.通过training过程，计算状态转移矩阵T（）和动作reward R（），通过学习得到经验MDP模型\n*step2. 使用价值迭代或策略迭代求解最优values\n过程：\n\n选出所有状态\n\n用模型模拟转移函数\n\n模拟奖励函数并且得出价值\n\n用MDP完成剩余的价值迭代等工作\n\n\n例题:\n\n无模型强化学习（Model-Free RL，MFRL）直接评估(Direct Evaluation)计算当前政策下所有动作的价值, 将观察到的样本值作平均\n\n根据政策做出动作\n每次遇到一种情形, 都把(折扣)奖励加起来\n平均这些样本, 得到直接评估结果\n\n例题:\n\n计算过程：\nA &#x3D; [-10] &#x2F; 1 &#x3D;10\n\nB &#x3D; [(-1-1+10)+(-1-1+10)]&#x2F;2 &#x3D; +8\n\nC &#x3D; [(-1+10)+(-1+10)+(-1+10)+(-1-10)]&#x2F;4 &#x3D; +4\n\nD &#x3D; [10+10+10]&#x2F;3 &#x3D; +10\n\nE &#x3D; [(-1-1+10)+(-1-1-10)]&#x2F;2 &#x3D; -2\n\n优点：简单易理解；不需要计算T、R；最终你那个计算出正确的平均value\n\n缺点：浪费了状态连接的信息，每个状态必须单独学习，会花费较长时间学习\n\n\n\n时间差分学习(Temporal Difference Learning)从每段经验中学习 \n\n每次经过一个转移函数(动作)就更新V(s)\n以至于新的状态将会为更新策略作出更多贡献\n政策固定, 始终作评估\n将当前值提供给任何一个后继者并作平均\n\n例题:\n\n计算过程：\n\n \n主动强化学习（Active Reinforcement Learning）Q-Learning我们可以计算出下一个状态的价值并取最大值,但我们也可以计算Q-state(Q状态)的值, 在我理解, 它属于一个未决策的中间态（更关注当前状态和动作）, 计算出它的值可以帮助我们决策, 并且更加有用。\n\n如果知道转化函数和奖励函数：\n如果不知道：\n取一个实例，作为转化函数与奖励函数的值来迭代。\nQ-Learning的属性\n即使没有按最优方式迭代，Q-Learning也始终能够最终迭代为最优结果（非政策学习） \n*  前提条件：\n\n你必须探索足够的次数\n你必须最终使学习率足够小\n但不要太快减少它\n不管你如何选择行动，要求基本上在限制下内\n\n \n探索与利用我们通常利用各种函数来帮助我们得出价值等数值帮助决策行为，但这样也不一定是最优解，需要偶尔去进行探索，但在什么条件下进行探索呢？\n\n有几种方案可以强迫探索\n\n最简单：随机行动（ε-贪婪）\n\n每次行动，随机一次（使ε为0到1之间的任意数，每次随机出一个0到1的数与它比较）\n\n比ε小，行动随机\n\n比ε大，行动按当前策略\n\n随机行动的问题？\n\n我们最终会探索其他可能性，但必须在学习完成后继续研究\n\n解决方案：随着时间的推移降低ε\n\n\n\n第三部门  一阶逻辑目录\n​\t逻辑基础\n​\t\t命题的定义\n​\t\t命题的真值\n​\t\t原子公式\n​\t连词和量词\n​\t\t合式公式的真值表\n​\t等价关系\n​\t永真蕴含式\n​\t置换与合一 \n​\t消解原理 \n​\t鲁滨逊归结原理\n​\t总结\n​\t例题\n\n逻辑基础命题的定义断言：一个陈述句称为一个断言(assertion)\n\n命题：具有真假意义的断言\n\n命题的真值\nT：命题的意义为真\n\nF：命题的意义为假注意：\n\n一个命题不能同时为真和假\n\n一个命题可以在某些条件下为真，某些条件下为假\n\n\n原子公式原子公式：由谓词符号和若干项组成的谓词演算，是谓词演算基本积木块。\n项包括 : 常量符号、变量符号、函数符号等。\n\n定义原子公式为真值或假值就表示了某种语义(semantics)\n若t1,t2, …, tn是项，p是谓词，则称P(t1,t2,…,tn)为原子谓词公式（原子公式）。\n无变量的原子公式取值确定，包含变量的原子公式取值不定。\n\n举例：\n“机器人（ROBOT）在1号房间（room1）内”\n\n INROOM（ROBOT，room1）为真\n INROOM （ROBOT，room2）为假\n\n\n\n\n连词和量词1. 与、合取（conjunction)：用连词∧把几个公式连接起来而构成的公式。\n合取项是合取式的每个组成部分。\n例：LIKE(I，MUSIC)∧LIKE(I，PAINTING)\n（我喜爱音乐和绘画。）\n2. 或、析取（disjunction）：用连词∨把几个公式连接起来而构成的公式。\n析取项是析取式的每个组成部。\n例：PLAYS(LILI，BASKETBALL)∨PLAYS(LILI，FOOTBALL)\n（李力打篮球或踢足球。）\n3. 蕴涵（Implication）:“→”表示“如果—那么”（IF—THEN）关系，其所构成的公式叫做蕴涵。\n4. 非（Not）表示否定，¬、～均可表示\n5.连词的优先级 ：¬, ∧, ∨ (\\exists, \\forall) , →, ↔\n\n\n\n合式公式的真值表\n\n等价关系等价(Equivalence): 如果两个合式公式，无论如何解释，其真值表都是相同的，那么我们就称此两合式公式是等价的。\n\n注意：（10)说明在一个量化的表达式中的约束变量是一类虚元，它可用任何一个不在表达式中出现过的其他变量符号来代替\n\n永真蕴含式\n\n置换与合一\n置换定义：置换是形如&#123;t1 &#x2F;x1 ,t2 &#x2F;x2 ,…,tn &#x2F;xn &#125;的有限集合，其中t1 ,t2 ,…,tn是项；x1 ,x2 ,…,xn 是互不相同的变元；ti &#x2F;xi 表示用项ti 替换变元xi 。\n\n要求：ti与xi 不能相同，xi 不能循环地出现在另一个ti 中。\n\n例如：&#123;a&#x2F;x, c&#x2F;y, f(b)&#x2F;z&#125; 是一个置换， 但 &#123;g(z)&#x2F;x, f(x)&#x2F;z&#125;不是一个置换，原因是x和z之间出现了循环置换现象，若改为&#123;g(a)&#x2F;x, f(x)&#x2F;z&#125;即可**\n\n设θ&#x3D;&#123;t1 &#x2F;x1 ,t2 &#x2F;x2 ,…,tn &#x2F;xn &#125;是一个置换，F是一个谓词公式， 把公式F中出现的所有xi 换成ti(i&#x3D;1,2,…,n)，得到一个新的公式G， 称G为F在置换θ 下的例示，记作**G&#x3D;Fθ\n\n置换的合成（了解）\n\n\n合一定义：设有公式集F&#x3D;&#123;F1 , F2 ,…,Fn &#125;，若存在一个置换θ，可使 F1θ&#x3D;F2θ&#x3D;…&#x3D;Fnθ， 则称θ是F的一个合一。称F1 ,F2 ,…,Fn是可合一的。\n\n例：\n\n设有公式集F&#x3D;&#123;P(x, y, f(y)), P(a, g(x), z)&#125;，则 λ&#x3D;&#123;a&#x2F;x, g(a)&#x2F;y, f(g(a))&#x2F;z&#125; 是它的一个合一。\n\n一般情况下,一个公式集的合一不惟一。\n\n最一般合一：设σ是谓词公式集F的一个合一，如果对F的**任意一个合一θ都存在一个置换λ，使得 θ&#x3D; σ· λ，则称σ是一个最一 般(或最简单)合一\n\n\n\n\n消解原理消解:对谓词演算公式进行分解、化简，消去一些符号，以求得导出子句，又称归结\n消解原理：\n\t(1)一种用于子句公式集的重要推理规则\n     (2)子句是由文字的析取组成的公式\n\t(3)一个原子公式、原子公式的否定叫作文字\n注意： 不含任何文字的子句称为空子句。\n\n由子句、空子句所构成的集合称为子句集\n消解过程：消解规则应用于母体子句对，以便产生导出子句\n\n举例：&#123; E1∨E2 ,～E2∨E3 &#125;消解导出E1∨E3\n\n\n\n归结的方法：鲁滨逊归结原理\n\n鲁滨逊归结原理核心：两个子句的归结式、\n定义1：若P是原子谓词公式，则称P与﹁P为互补文字\n定义2：设C1和C2是子句集中的任意两个子句，如果C1中的文字L1与C2中的文字L2互补，那么可从C1和C2中分别消去L1和L2，并将C1和C2中余下的部分按析取关系构成一个新的子句C12，则称这一过程为归结，称C12为C1和C2的归结式，称C1和C2为C12的亲本(父辈)子句\n\n\n总结9步法求取子句集\n\n(1)消去蕴涵符号\n(2)缩小否定符号的辖域(狄·摩根定律)\n(3)变量标准化(哑元唯一)\n(4)消去存在量词\n(5)化为前束形\n(6)化为合取范式(∧)\n(7)消去全称量词\n(8)消去连词符号(∧)\n(9)更换变量名(同一变量名不出现在一个以上子句)\n\n\n例题解：\n \n\n由①和⑦，用zhang置换x     Pass(zhang, computer)∨Win(zℎang,prize)   ⑧\n由③和⑤，用zhang置换u Pass(zhang, v) ⑨\n由⑧和⑨，用computer置换v ~Win(zhang, prize)   ⑩\n由⑥和⑩，用zhang置换w ~Lucky（zhang）  （11）\n由⑤和11可得空子句NIL，所以结论成立，消解树如上图所示。\n\n \n\n第四部分  概率与贝叶斯网络目录\n​\t概率\n​\t\t概率公式\n​\t\t\t贝叶斯公式\n​\t\t\t链式条件概率\n​\t\t例题\n​\t\t\t1. 求联合概率分布&#x2F;边缘概率分布&#x2F;条件概率分布\n​\t\t\t2. 灵活运用贝叶斯公式 \n​\t   概率总结\n​\t贝叶斯网络\n​\t\t判断独立性\n​\t\t\t两个事件独立的判断\n​\t\t\t条件独立性的判断\n​\t\t\t假设条件独立的链式法则\n​\t\t⚠Active &#x2F; Inactive Paths 判断独立性\n​\t\t贝叶斯网络中的条件概率\n​\t\t编辑\n​\t\t多重连接和多重消除 Multiple Joins &amp; Multiple Elimination\n​\t\t贝叶斯网络抽样(Bayes’ Nets Sampling) \n​\t\t\t采样是什么？——Sampling\n​\t\t\t先验抽样        ▪ Prior Sampling\n​\t\t\t拒绝抽样        ▪ Rejection Sampling\n​\t\t\t似然加权        ▪ Likelihood Weighting\n​\t\t\t吉布斯抽样     ▪ Gibbs Sampling\n​\t\t\t总结\n​\t⚠作业题\n\n概率\n概率公式贝叶斯公式 \n链式条件概率\n\n例题1. 求联合概率分布&#x2F;边缘概率分布&#x2F;条件概率分布\n首先明确，P(W |  dry)是一个概率分布，而不是一个概率值。不能写成 P(W |  dry)&#x3D;….\n①求联合概率分布P(D,W);\n②求边缘概率分布P(D);\n③求条件概率分布P(W | D).\n\n\n2. 灵活运用贝叶斯公式\n\n概率总结\n\n贝叶斯网络\n判断独立性两个事件独立的判断\n\n条件独立性的判断\n假设条件独立的链式法则\n\n⚠Active &#x2F; Inactive Paths 判断独立性要判断X，Y的独立性：\n\n找到X到Y的所有路径paths\n\n如果一个path的所有三元组都是active那么此path就是active\n\n\n​\t3. 若存在一个path为active，那么X、Y就是非独立的，反之独立\n简言之：找到一条path的所有三元组都是active那么就非独立；\n\n若只存在一条路径，那么找到一个inactive的三元组就独立，如果全部active才非独立。\n\n⭐可以把X、Y理解为两个水池，如果有一根连通水管（path）里的开关全打开了（active）那么二者连通，不独立（independence）；如果就只有一根水管连接，那么只要有一个开关被关闭（inactive）那么就独立。\n\n【上图阴影表示确定条件，即given。】\n⭐只需要记间接因果（中间条件已知）、已知同因（父节点已知）、未知共果是active（子节点未知），其他三个对立的象限自己就出来了。\n\n贝叶斯网络中的条件概率\n文字描述： 遍历每一项，分别以它们的父节点为条件，连乘即可。\n举例说明比较直观：\n\n多重连接和多重消除 Multiple Joins &amp; Multiple Elimination对应乘起来就行了，没什么。\n\n\n\n贝叶斯网络抽样(Bayes’ Nets Sampling)贝叶斯网络的抽样大致分为：\n\n先验抽样        ▪Prior Sampling\n拒绝抽样        ▪Rejection Sampling\n加权抽样        ▪Likelihood Weighting\n吉布斯抽样     ▪Gibbs Sampling\n\n其目的是进一步加快贝叶斯网络近似的速度。\n采样是什么？——Sampling采样，顾名思义就是从特定的概率分布中抽取相应样本点的过程。它可以将复杂的分布简化为离散的样本点、可以用于随机模拟已进行复杂模型的近似求解或推理等。\n先验抽样        ▪ Prior Sampling获取样本的方式为祖先抽样，从父节点开始逐渐扩展，类似于贝叶斯网络中的联合分布，下面以一个经典的例题直观感受一下：\n\n如图，它的核心思想是根据有向图的顺序，先对祖先节点进行采样，只有当某个节点的所有父节点都已完成采样，采对该结点进行采样。以上图为场景，先对Cloudy变量进行采样，然后对Sprinkle和Rain变量进行采样，最后对WetGrass变量采样。根据贝叶斯网络的全概率公式\n\n        可以看出祖先采样得到的样本服从贝叶斯网络的联合概率分布。        如果只需要对贝叶斯网络中一部分随机变量的边缘分布进行采样，可以用祖先采样对全部随机变量进行采样，然后直接忽视那些不需要的变量的采样值即可。由图可见，如果需要对边缘分布p(Rain)进行采样，先用祖先采样得到全部变量的一个样本，如（Cloudy&#x3D;T，Sprinkler&#x3D;T，Rain&#x3D;T，WetGrass&#x3D;T），然后忽略掉无关变量，直接把这个样本看成是Coludy&#x3D;T即可。 大致流程：\n\n设一个事件的样本数为：\n计算生成样本的概率：\n套用公式：\n采样程序是一致的，这样就估计出联合分布的概率。\n\n例题：\n\n从贝叶斯网络中得到的样本：\n\n需要求P（W）\n\n计数：+w——4；-w——1\n计算概率：+w——4&#x2F;5&#x3D;0.8；-w——1&#x2F;5&#x3D;0.2\n（样本越多越接近真实概率）\n\n总结：\n\n拒绝抽样        ▪ Rejection Sampling类似，就不赘述了，它采样的方式就是根据条件取，不符合条件的丢弃：\n假设在上例中我们要求C的概率，此时保留所有样本就没有意义了，我们选择对C计数；\n假设我们想要Ｐ（C|+s），同样的，我们要统计C结果，但忽略（拒绝）没有+s的样本。\n这就是拒绝抽样，它对于条件概率而言也是一致的。\n\n似然加权        ▪ Likelihood Weighting举一个例子：在有观测变量（Sprikeler &#x3D; T, WetGrass &#x3D; T）时，可以先对Cloudy进行采样，再对Rain进行采样，对于Sprikeler、WetGrass则直接赋观察值，得到下面的一个样本：\n这样得到的样本的重要性权值为：\nw 正比于 p(Sprinkler &#x3D; T| Cloudy &#x3D; T)*p(WetGrass &#x3D; T| Sprinkler &#x3D; T,Rain &#x3D; T) &#x3D; 0.1&#x2F;**0.99 &#x3D; 0.099\n该式子可以理解为：当其他变量取得样本中的取值时(Cloudy &#x3D; T,Rain &#x3D; T)，预测变量取得其确定值的可能性。 \n\n\n吉布斯抽样     ▪ Gibbs Sampling\n\n总结直接采样：按照拓扑顺序依次对每个变量进行采样。变量值被采样的概率分布依赖于父结点已得到的赋值。\n拒绝采样：给定一个易于采样的分布，为一个难于采样的分布生成采样样本。\n似然加权（likelihood weighting）只生成与证据e一致的事件，从而避免拒绝采样算法的低效率。\nGibbs采样算法：贝叶斯网络的Gibbs采样算法从任意的状态出发，通过(给定马尔可夫覆盖)对一个非证据变量Xi随机采样而生成下一个状态。对Xi的采样条件依赖于Xi的马尔可夫覆盖中的变量的当前值。\n\n\n⚠作业题\n\n\n第五部分  机器学习目录\n​\t监督学习  vs 无监督学习\n​\t回归 vs 分类 Regression vs Classification\n​\t训练集 vs 测试集 vs 验证集\n​\t泛化和过拟合 Generalization &amp; Overfitting\n​\t线性分类器 Linear Classifiers\n​\t激活函数 - 概率决策\n​\t⚠线性回归 \n​\t决策树 Decision Trees\n​\t\t决策树构建递归退出条件C\n​\t\t信息熵 Entropy\n​\t\t信息增益 Information Gain\n​\t\t⚠ID3算法实例\n\n监督学习  vs 无监督学习监督学习：输入已知类别的数据样本         分类、回归\n无监督学习：输入未知类别的数据样本      聚类\n\n回归 vs 分类 Regression vs Classification分类：对输入数据进行离散值标签的预测\n回归：预测连续的、具体的数值\nOutput： 连续 vs 离散\n分类需要激活函数\n\n\n训练集 vs 测试集 vs 验证集训练集用于学习参数（例如模型概率）\n测试集用于计算模型的准确率\n验证集用于调节超参数\n\n泛化和过拟合 Generalization &amp; Overfitting在有监督学习中，我们会在训练数据集上建立一个模型，之后会把这个模型用于新的，之前从未见过的数据中，这个过程称为模型的泛化\n模型在训练集上表现好，在测试集验证集表现差就说明出现了过拟合问题，出现这种情况的主要原因是训练数据中存在噪音或者训练数据太少\n解决办法：选取合适的停止训练标准；使用验证数据集；获取额外数据进行交叉验证；正则化Relative frequency parameters will overfit the training data\n相对频率参数会过拟合训练数据\n\n线性分类器 Linear Classifiers输入特征向量 f(x) \n权重**向量 ** w\n在二分类中：\n真实标签为 y&#x2F;*∈{-1，1}，\n预测标签为 y ，w和f(x)在同一平面则为正样本，y&#x3D;1，反之y&#x3D;-1\n\n如果分类正确，不更新w，分类错误则更新 w\nw &#x3D; w + y&#x2F; · f(x)  ** 其中y&#x2F; &#x3D; 1或-1\n\n在多分类中：\n输入特征向量 f(x) \n每个类别的权重 **向量 **\n 预测标签为 y ，取最大的一个类别标签\n\n如果分类正确，不更新w；分类错误则更新 w，此时需要分别对正确和错误的两个w进行更新\n关键点：减小错分类别的向量点积，增大真实类别的向量点积\n          \n\n激活函数 - 概率决策\n \n\n⚠线性回归\n\n L2 loss：所有样本的平方误差和\n\n例：\n\n​                       \n​                                \n\n决策树 Decision Trees决策树构建递归退出条件C\n当前样本集D包含的样本属于同一类别C\n当前属性集A为空或样本集D中所有样本在所有属性上取值相同（但类别可能不相同）\n当前结点包含的样本集为空\n\n信息熵 Entropy信息熵是度量样本集合纯度的指标\n假定当前样本集合D中第k类样本所占比例为pk（k&#x3D;1，2，…，|y|）则D的信息熵的定义为：\n\n Ent(D)的取值范围为 [0,log2|y| ]，值越小，纯度越高\n计算信息熵时约定：若p&#x3D;0，则&#x3D;0\n信息增益 Information Gain样本集D的某个离散属性a有V个可能的取值，用a来对D进行划分则会产生V个分支结点，其中第v个分支结点包含了D中所有在在属性a上取值为的样本，记为。定义用属性a对样本集D进行划分所获得的信息增益为：\n\n一般而言，信息增益越大，意味着使用属性a来进行划分获得的纯度提升越大\n在ID3算法中选择信息增益大的属性来划分样本集\n⚠ID3算法实例\n\n \n\n\n \n\n\n","slug":"AIreview","date":"2023-03-16T09:59:30.000Z","categories_index":"复习笔记","tags_index":"AI","author_index":"涛"},{"id":"13496e257353ba6c01963033a6fae016","title":"毛中特复习提纲","content":"毛泽东思想毛泽东思想发展：\n历史条件：\n帝国主义、无产阶级革命时代，社会主义革命；冷战，和平演变。\n\n发展过程：\n第一次国内革命战争时期，《中国社会各阶级的分析》《湖南农民运动考察报告》，提出新民主主义革命思想\n土地革命战争时期，开辟农村包围城市、武装夺取政权道路，《中国的红色政权？》《井冈山的斗争》《星星之火可以燎原》《反对本本主义》，标志着毛思想初步形成\n遵义会议以后，《实践论》《矛盾论》中用马原知识分析“左”和右的错误认识根源；《中国革命与中国共产党》《新民主主义论》系统阐述了新民主主义革命总路线。新民主主义革命总路线的系统阐述，实现了马主义与中国革命相结合的历史性飞跃，标志毛思想成熟\n建国后，找出适合中国国情的社会主义建设道路艰辛探索，是毛思想丰富与发展\n\n\n毛思想 主要内容 活的灵魂 历史地位主要内容\n新民主主义革命理论\n基本点：1）资产阶级分为大资产阶级和（动摇性但有革命需求）民族资产阶级。无产阶级领导的统一战线，应该拉拢后者。“又团结又斗争、以斗争求团结”。2）中国革命只能以长期的武装斗争为主要形式。统一战线和武装斗争，是战胜敌人的两个基本武器。（加上党自身建设，成为三个主要法宝）\n\n社会主义革命和社会主义建设理论\n采取社会主义工业化、社会主义改造并举的方针，实施逐步改造生产资料私有制的具体政策，解决了在中国建立社会主义制度的重大问题\n\n革命军队建设和军事战略\n\n政策和策略\n战略上藐视战术重视。。。\n\n思想政治工作和文化工作\n又红又专；百花齐放百家争鸣\n\n党的建设理论\n中共区别于其他政党显著标志：理论和实践相结合、和人民群众紧密联系、自我批评三大作风\n\n\n活的灵魂（重要）\n实事求是\n\n深入实际了解事物的本来面貌\n清醒认识和正确把握我国基本国情\n不断推进实践基础上的理论创新\n\n\n群众路线\n一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。是党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝。本质上体现：马克思主义关于人民群众是历史的创造者这一基本原理。\n\n坚持人民是推动历史发展的根本力量\n坚持全心全意为人民服务的根本宗旨\n保持党同人民群众的血肉联系\n\n\n独立自主\n\n坚持独立思考，走自己的路，坚定不移地维护民族独立，捍卫国家主权，立足自己的同时学习外国一切对我们有益的先进事物。\n坚持中国的事情必须由中国人民自己处理\n坚持独立自主的和平外交政策，坚定不移走和平发展道路\n\n\n\n历史地位\n马克思主义中国化的第一个重大理论成果\n中国革命和建设的科学指南\n中国共产党和中国人民宝贵的精神财富\n\n新民主主义革命理论中国国情半殖民地半封建\n近代中国革命的时代特征（重要）仍然是资产阶级民主革命。但经历了从旧民主主义革命向新民主主义革命的转变，具有鲜明的时代特征。\n\n俄国十月革命的胜利为标志：中国资产阶级民主革命的时代背景发生根本转换（属于世界无产阶级社会主义革命的一部分）\n\n五四运动的爆发为标志：中国资产阶级民主革命进入新民主主义革命的崭新阶段\n\n自在阶级变为自为阶级（描述无产阶级转变）\n\n崭新阶段：无产阶级领导，马列主义指导，建立各革命阶级联合专政的民主共和国。\n\n是反帝反封建的新民主主义革命。\n\n中国革命分两步走，第一步是完成反帝反封建的新民主主义革命，第二步是完成社会主义革命\n\n\n\n\n新民主主义革命理论的实践基础\n旧民主主义革命的失败\n新民主主义革命艰辛探索\n\n新民主主义革命理论的总路线总路线：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。\n\n对象：帝国主义 封建主义 官僚资本主义\n\n动力\n\n无产阶级：中国革命最基本的动力。新的社会生产力的代表，近代中国最进步的阶级，中国革命的领导力量\n农民：中国革命的主力军。（贫雇农：无产阶级最可靠的同盟军，中农：无产阶级可靠的同盟军）农民问题：中国革命的基本问题；新民主主义革命：党领导下的农民革命；中国革命战争：党领导下的农民战争。但是要保持工人阶级对农民的领导。\n城市小资产阶级：无产阶级的可靠同盟者\n民族资产阶级：也是动力之一，两面性。受三座大山压迫，但是有动摇性。不可能是革命的主要力量也不会是领导力量。要积极争取，又斗争又联合。\n\n\n领导力量\n\n区别新旧不同范畴的民主主义革命根本标志：革命的领导权掌握在无产阶级还是资产阶级手中\n无产阶级及其政党，是绝对的领导者\n无产阶级优点：\n深受三座大山压迫，所以革命彻底\n分布集中，有利于无产阶级队伍组织团结，有利于传播革命思想\n大部分出身破产农民，和农民结成亲密的联盟。\n\n\n必须建立以工农联盟为基础的广泛的统一战线：首先建立巩固的工农联盟；在和资产阶级建立统一战线时，必须坚持独立自主，又联合又斗争。\n必须建立和发展人民的武装力量。无产阶级领导、农民为主体的武装力量\n\n\n性质和前途\n\n性质：不是无产阶级社会主义革命，而是资产阶级民主主义革命。但是，中国革命已不是旧式的、一般的资产阶级民主主义的革命，而是新的民主主义革命。\n与社会主义革命性质不同（仍属于资产阶级民主主义革命范畴）。建立无产阶级领导的各个革命阶级联合专政，而非无产阶级专政。\n与社会主义革命互相联系、紧密衔接。不容许横插一个资产阶级专政\n\n\n\n新民主主义革命的政治纲领\n政治纲领：推翻帝国主义的统治，建立一个无产阶级领导的、工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。新民主主义政治：国体——各革命阶级联合专政，政体——民主集中制的人民代表大会制度。\n经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。\n文化纲领：新民主主义文化：无产阶级领导的人民大众的反帝反封建的文化，民族的科学的大众的文化。\n\n新民主主义革命的道路农村包围城市、武装夺取政权\n\n新民主主义革命道路的内容及意义：（重要！）\n中国革命走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村根据地建设三者之间的关系。\n土地革命——民主革命的基本内容\n武装斗争——中国革命的主要形式\n农村革命根据地建设——进行武装斗争和开展土地革命的依托\n\n\n新民主主义革命三大法宝（重要）统一战线、武装斗争、党的建设\n\n统一战线：\n由1.中国半殖民地半封建的阶级状况决定2.由中国革命的长期性、残酷性、发展的不平衡性决定\n主要在于：\n建立巩固的工农联盟\n正确对待资产阶级，又联合又斗争\n采取区别对待的方针（坚持发展进步势力，争取中间势力，孤立顽固势力）\n坚持独立自主的原则\n\n\n\n\n武装斗争：\n坚持党对军队的绝对领导\n建设全心全意为人民服务的人民军队\n坚持争取的战略战术原则\n\n\n党的建设：\n必须把思想建设放在党的建设的首位\n必须在任何时候都重视党的组织建设（贯彻民主集中制这一根本组织原则）\n重视党的作风建设\n\n\n\n社会主义改造理论党在过渡时期的总路线\n总路线主要内容：一化三改。社会主义工业化+三大改造（对个体农业、手工业和资本主义工商业的社会主义改造）\n理论依据：马克思列宁主义+中国的国情\n\n社会主义改造道路\n农业、手工业的社会主义改造\n第一，积极引导农民组织起来，走互助合作道路。不挫伤个体经济的积极性的同时，及发展互助合作的积极性，收到农民的拥护\n第二，遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。\n第三，正确分析农村的阶级和阶层状况，制定正确的阶级政策。贫、下中农是党在农村的依靠力量，建立了农村的无产阶级优势。党制定了依靠平下中农发展互助合作，从逐步限制到最后消灭富农剥削的农村阶级政策。这使得农业合作化有了坚实的阶级基础和群众基础。\n第四，坚持积极领导、稳步前进的方针，采取循序渐进的步骤。\n农业：互助组、初级社、高级社\n手工业：手工业供销小组、手工业供销合作社、手工业生产合作社\n\n\n\n\n资本主义工商业的社会主义改造\n和平赎买的方法改造资本主义工商业（国家有偿地将私营企业变为国营企业）。和平改造背景：\n民族资产阶级两面性\n民族资产阶级和党长期统一战线\n私人资本主义依赖社会主义经济\n\n\n从低级到高级的国家资本主义的过渡形式\n把资本主义工商业改造成为自食其力的社会主义劳动者\n\n\n\n社会主义改造经验\n坚持社会主义工业化建设与社会主义改造同时并举\n积极引导、逐步过渡的方式\n用和平方法进行改造\n\n社会主义制度确立社会主义制度的确立过程、理论根据1956年，三大改造基本完成，社会主义公有制已经成为我国社会的经济基础，标志着社会主义基本制度的确立\n1954年第一部宪法，明确：\n\n国体——人民民主专政；政体——人民代表大会制度\n表明我国由一个新民主主义国家变为社会主义国家\n\n确立社会主义基本制度的重大意义（重要）\n社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展\n逐步建立起独立的工业体系、国民经济体系\n完成了最为广泛而深刻的社会变革，中国几千年来阶级关系的最根本变革\n加强了社会主义力量\n对半殖民地半封建中国如何进行社会主义革命问题的系统回答和正确解决\n\n社会主义建设道路初步探索的理论成果初步探索的重要理论成果\n调动一切积极因素为社会主义事业服务\n1956年《论十大关系》，要以苏为鉴，根据本国情况走自己的道路。标志着党探索中国社会主义建设道路良好开端\n\n提出：调动一切积极因素为社会主义事业服务。消极因素向积极因素转化。\n怎么调动：\n坚持中国共产党的领导\n发展社会主义民主政治\n认识社会主义发展阶段和社会主义建设规律\n\n\n\n\n正确认识和处理社会主义社会矛盾的思想\n\n毛指出社会主义社会同样存在矛盾。（斯大林认为不存在）\n\n社会主义社会矛盾是非对抗性的（因为:生产关系和生产力基本适应，人民根本利益一致），可以通过社会主义制度本身不断地得到解决。\n\n我国的矛盾：\n\n已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾\n已经是人民对于经济文化迅速发展需要同当前经济文化不能满足人民需要的状况之间的矛盾\n\n\n存在两类矛盾：\n\n敌我矛盾（分清敌我——专政）\n人民内部的矛盾：工人阶级同民族资产阶级之间属于人民内部的矛盾（分清是非——民主）\n\n可以互相转化\n\n\n\n走中国工业化道路的思想\n以农业为基础，以工业为主导，以农（业）轻（工业）重（工业）为序发展国民经济的总方针。\n必须：\n\n明确战略目标和战略步骤：“两步走”，1. 建成一个独立的比较完整的工业体系和国民经济体系。2. 全面实现工业、农业、国防和科学技术现代化，使中国走在世界前列。\n采取正确的经济建设方针\n发展科学技术和文化教育。”向科学进军““双百方针”\n重视知识份子工作\n调整和完善所有制结构\n积极探索适合我国情况的经济体制和运行机制\n\n\n\n初步探索的意义和教训\n意义\n巩固和发展了我国的社会主义制度\n为开创中国特色社会主义提供了宝贵经验、理论准备和物质基础\n完善了科学社会主义的理论和实践\n\n\n经验教训\n必须把马克思主义和中国实际相结合，探索符合中国特点的社会主义建设道路。\n必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力\n必须从实际出发进行社会主义建设，建设规模和速度要和国力适应，不能急于求成\n必须发展社会主义民主，健全社会主义法制\n必须坚持党的民主集中制和集体领导制度，加强执政党建设\n必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关门搞建设\n\n\n\n邓小平理论邓小平理论形成\n形成条件\n\n时代背景——和平与发展\n和平问题：东西问题；发展问题：南北问题。\n\n历史根据——社会主义建设的经验教训\n\n现实依据——改革开放和现代化建设的实践\n\n\n\n形成过程\n1978年十一届三中全会，解放思想、实事求是，停止使用“以阶级斗争为纲”\n1982年十二大开幕词，邓小平指出“建设有中国特色的社会主义”。从此，中国特色社会主义成为我们党的全部理论和实践创新的主题。\n1984年，提出《关于经济体制改革的决定》，指出社会主体经济是公有制基础上的有计划的商品经济\n1987年十三大——系统论述我国社会主义初级阶段理论，明确概括全面阐发了党“一个中心两个基本点”的路线。邓小平理论轮廓的形成。\n1992年南方谈话，打消人们顾虑，邓小平理论逐步成熟。1992十四大高度评价。1997提出邓小平理论。1999写入宪法\n\n\n邓小平理论基本问题和主要内容（重要）\n回答的基本问题：\n什么是社会主义、怎么建设社会主义\n强调必须坚持社会主义基本制度，同时概括社会主义本质解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕（科学概括）。纠正了过去忽视生产力发展的错误观念；同时，阐明了我们发展生产力，与剥削阶级统治的社会发展生产力，是完全不同的。\n这一科学概括，为我们坚持公有制又完善和发展公有制指出了明确的方向。毫不动摇地坚持公有制和按劳分配，维护公有制和按劳分配的主体地位是体现社会主义本质的前提。\n\n主要内容：\n\n解放思想实事求是的思想路线\n\n社会主义初级阶段理论\n\n党的基本路线：\n领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗\n\n第一：建设“富强民主文明的社会主义现代化国家”\n第二：”一个中心、两个基本点“（以经济建设为中心，坚持四项基本原则，坚持改革开放）\n第三：领导和团结全国各族人民\n第四：自力更生，艰苦创业\n\n（十九大——富强民主文明和谐美丽的社会主义现代化强国）\n\n社会主义根本任务的理论。社会主义根本任务：发展生产力\n\n”三步走“战略。\n\n第一步：1981-1990，gdp翻一番解决温饱；\n第二步：1991-2000，再翻一番，达到小康\n第三步，到21世纪中叶，再翻两番，达到中等发达国家水平，基本实现现代化\n\n允许和鼓励一部分地区一部分人先富起来。\n\n改革开放理论。\n\n改革作为一次新的革命，不允许否定和抛弃社会主义基本制度，而是社会主义基本制度的自我完善和发展。\n\n改革是社会主义社会发展的直接动力\n\n改革是一项崭新的事业，是一个大试验\n\n开放也是改革，对外开放是建设中国特色社会主义的一项基本国策。开放是对所有国家的开放。\n应当怎么做：\n\n正确对待资本主义社会创造的现代文明成果\n\n高度珍惜、坚决维护中国人民经过长期奋斗得来的独立自主权利\n\n\n\n\n\n社会主义市场经济理论\n\n概述：社会主义经济是公有制基础上有计划的商品经济，市场经济不等于资本主义，社会主义也有市场\n要点：\n计划经济和市场经济不是划分社会制度的标志\n计划和市场都是经济手段，对经济活动调节各有优势长处，社会主义实行市场经济要将两者结合\n市场经济作为资源配置的一种方式，本身不具有制度属性，可以和不同的社会制度结合表现出不同的特征\n\n\n\n\n”两手抓，两手都要硬“\n物质文明和精神文明两手抓，两手都要硬。其他两手抓思想：一手抓建设一手抓法制。一手抓改革开放一手抓惩治腐败。\n\n一国两制\n“和平统一，一国两制”：坚持一个中国是核心。两制并存，在祖国统一的前提下，国家的主体部分实行社会主义制度，同时在台湾、香港、澳门保持原有的社会制度和生活方式长期不变；高度自治。\n\n中国问题的关键在于党\n\n\n\n\n邓小平理论的历史地位\n马克思列宁主义、毛泽东思想的继承与发展\n中国特色社会主义理论体系的开篇之作\n改革开放和社会主义现代化建设的科学指南\n\n三个代表重要思想形成条件\n是在对冷战后国际局势的科学判断的基础上形成的\n苏联解体，美国寻求单极化，中国处于社会制度对立斗争最前沿。\n但和平与发展仍然是时代的主题，世界多极化曲折发展；经济全球化发展\n科学技术发展迅猛\n\n\n是在科学判断党的历史方位和总结历史经验的基础上提出来的\n这一时期，党的队伍要整体性交接，年轻人走上岗位；一些党员和干部存在腐败动摇。\n\n\n是在建设中国特色社会主义伟大实践的基础上形成的。\n\n形成过程（略）\n核心观点中国共产党必须：\n\n始终代表中国先进生产力的发展要求\n\n党领导人民进行改革，是为了促进生产力，特别是先进生产力的解放和发展\n不断提高工人、农民、知识分子（推动我国先进生产力发展和社会全面进步的根本力量）和其他劳动群众以及全人民的_思想道德素质和科学文化素质_，不断提高他们的劳动技能和创造才能，充分发挥他们的积极性主动性创造性，始终是我们党代表中国先进生产力发展要求必须履行的首要任务。\n大力推动科技进步和创新，不断用先进科技改造提高国民经济，努力实现我国生产力发展的跨越，这是我们党代表中国先进生产力发展要求必须履行的重要职责\n加强国家创新体系建设，深化科技体制改革，加速科技成果向生产力转化……\n\n\n始终代表中国先进文化的前进方向\n发展社会主义先进文化，就是：\n\n建设社会主义精神文明\n发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化\n\n发展社会主义先进文化，必须：\n\n必须弘扬民族精神\n必须加强社会主义思想道德建设\n必须做好思想道德工作\n\n\n始终代表中国最广大人民的根本利益\n\n我们党来自于人民，根植于人民，服务于人民\n\n我们党始终坚持人民的利益高于一切\n\n要努力使工人、农民、知识分子和其他群众共同享受到经济社会发展的成果\n使得群众获得应该得到的、看得见的物质利益，才能使群众深刻认识到改革开放和社会主义现代化是祖国的富强之道也是个人的富裕之道。\n\n妥善处理好各方面的利益关系\n\n\n\n\n主要内容\n发展是党执政兴国的第一要务\n建立社会主义市场经济体制\n必须坚持和完善公有制为主体，多种所有制共同发展的社会主义基本经济制度\n对公有制：进一步探索多种有效实现形式，改革\n对市场：健全统一、开放、竞争、有序的现代市场体系，促进商品和生产要素在全国市场自由流动\n完善按劳分配为主体、多种分配方式并存的分配制度。效率优先、兼顾公平，初次分配注重效率，再分配注重公平。\n建立和完善社会保障体系\n\n\n全面建设小康社会\n建设社会主义政治文明\n最根本：坚持党的领导、人民当家作主、依法治国的有机统一\n坚持依法治国\n进行政治体制改革\n\n\n推进党的建设新的伟大工程\n坚持党的领导\n核心：坚持党的先进性\n重点是加强党的执政能力\n领导干部要讲学习、讲政治、讲正气。\n坚持党要管党、从严治党\n坚决反对和防止腐败\n\n\n\n\n\n历史地位\n中国特色社会主义理论体系的接续发展\n是对马列毛邓思想的继承和发展。始终做到三个代表，是我们党的立党之本、执政之基、力量之源\n坚持把人民的根本利益作为出发点和归宿\n强调社会主义社会是全面发展、全面进步的社会，必须从“三个代表”指出的三个方面全面衡量党的方针政策的成败得失\n强调要努力促进人的全面发展\n\n\n加强和改进党的建设，推进中国特色社会主义事业的强大理论武器\n从根本上统一了发展生产力、发展先进文化、实现最广大人民的利益\n在三个代表的指引下，1）推进社会主义市场经济改革；2）积极稳妥推进政治体制改革；3）加强社会主义精神文明建设\n提出了党建新要求\n从新的高度提出，必须不断改进党的领导方式和执政方式\n\n\n\n总之，三个代表重要思想进一步回答了什么是社会主义、怎样建设社会主义的问题，创造性地回答了建设什么样的党、怎样建设党的问题，集中起来就是深化了对中国特色社会主义的认识。三个代表重要思想反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和党的建设、推进我国社会主义自我完善和发展的强大理论武器，是党和国家必须长期坚持的指导思想。\n科学发展观形成\n形成条件\n\n深刻把握我国基本国情和新的阶段性特征（进入发展关键期、改革攻坚期和矛盾凸显期）\n深入总结改革开放以来特别是党的十六大以来实践经验\n深刻分析国际形势、顺应世界发展趋势、借鉴国外发展经验\n\n\n形成过程\n\n在抗击非典疫情和探索完善社会主义市场经济体制的过程中逐步形成\n（略）\n\n\n\n\n科学内涵第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾\n\n推动经济社会发展是科学发展观的第一要义\n在当代中国，坚持发展是硬道理的本质要求就是坚持科学发展\n坚持科学发展，必须加快转变经济发展方式。经济结构战略性调整、科技进步和创新、保障和改善民生、建设资源节约型环境友好型社会。正确认识发展好与快的辩证关系，从主要依靠第二产业带动变成依靠一二三产业协同带动转变\n坚持科学发展，必须善于抓住和用好机遇\n\n\n以人为本是科学发展观的核心立场\n以人为本就是以最广大人民的根本利益为本\n坚持以人为本，就要坚持发展为了人民\n坚持以人为本，就要坚持发展依靠人民\n坚持以人为本，就要坚持发展成果由人民共享，着力提高人民物质文化生活水平\n坚持以人为本，最终是为了实现人的全面发展\n\n\n全面协调可持续是科学发展观的基本要求\n坚持全面发展，就是：\n要按照中国特色社会主义事业总体布局，正确认识和把握经济建设、政治建设、文化建设、社会建设、生态文明建设是相互联系、相互促进的有机统一体\n保证中国特色社会主义各个领域协调推进\n必须走生产发展、生活富裕、生态良好的文明发展道路\n必须建设生态文明\n\n\n\n\n统筹兼顾是科学发展观的根本方法\n坚持统筹兼顾，\n必须正确认识和妥善处理中国特色社会主义事业中的重大关系：\n统筹城乡发展\n统筹人与自然和谐发展\n统筹国内发展和对外开放\n\n\n必须认真考虑和对待各方面的发展需要，正确反应和兼顾各阶层各群体的利益要求\n要牢牢掌握统筹兼顾的科学思想方法，努力提高战略思维\n还要求我们既立足当前，又着眼长远\n\n\n\n\n\n主要内容\n加快转变经济发展方式\n08次贷危机引发\n要着力激发市场活力，增强创新驱动发展新动力，着力培育开放型经济发展，把推动发展的立足点转到提高质量和效益上来\n让经济发展更多依靠内需特别是消费需求拉动\n更多依靠现代服务业和战略性新兴产业（科技进步、劳动者素质提高、管理创新）带动\n全面深化经济体制改革、实施创新驱动发展战略、推动经济结构战略性调整、促进区域协调发展、城乡发展一体化……\n\n\n发展社会主义民主政治\n本质和核心：人民当家作主\n坚持好、发展好适合我国国情的社会主义政治制度\n社会主义协商民主。胡指出：人民通过选举和投票行使权利&amp;人民内部各方面在重大决策之前进行充分协商，尽可能就共同性问题达成一致意见\n\n\n推进社会主义文化强国建设\n文化越来越成为民族凝聚力和创作力的重要源泉、越来越成为综合国力竞争的重要因素、越来越成为经济社会发展的重要支撑\n树立高度的文化自觉和文化自信\n社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。社会主义核心价值体系构成：\n中国特色社会主义共同理想\n以爱国主义为核心的民族精神和以改革创新为核心的时代精神\n社会主义荣辱观\n\n\n\n\n构建社会主义和谐社会\n推进生态文明建设\n全面提高党的建设科学化水平\n\n历史地位\n中国特色社会主义理论体系的接续发展\n进一步回答了什么是社会主义、怎样建设社会主义（邓）和建设什么样的党、怎样建设党的问题（江），同时创造性地回答了新形势下实现什么样的发展、怎样发展等重大问题\n\n发展中国特色社会主义必须长期坚持的指导思想\n\n\n","slug":"maoreview","date":"2023-03-16T08:59:30.000Z","categories_index":"复习笔记","tags_index":"Maxist","author_index":"涛"},{"id":"1a14118a4d87c78d0b5b85be0125d252","title":"共产党宣言","content":"《共产党宣言》全文\n\n《共产党宣言》全文\n卡•马克思 弗•恩格斯\n1847年12月—1848年1月\n英文：The Communist Manifesto\n(Manifesto of the Communist Party)\n德文：Manifest der Kommunistischen Partei\n\n\n引言一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力：教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。\n有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？\n从这一事实中可以得出两个结论：\n共产主义已经被欧洲的一切势力公认为一种势力；\n现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿出自己党的宣言来批驳关于共产主义幽灵的神话的时候了。\n为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。\n一、资产者和无产者⑴至今一切社会的历史⑵都是阶级斗争的历史。\n自由民和奴隶、贵族和平民、领主和农奴、行会师傅⑶和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局，或是整个社会受到革命改造，或是斗争的各阶级同归于尽。\n在过去的各个历史时代，无论何处我们都可以看到社会被划分为各个不同的阶级，社会地位分成多种多样的等级。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的等级。\n从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只不过是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。\n但是，我们现在这个时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。\n从中世纪的农奴中产生了初期城市的市民（自由民）；从这个市民等级中发展出最初的资产阶级分子。\n美洲和绕过非洲的航海线路的发现，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般商品的增加，使商业、航海业和工业空前高涨，因而促使正在崩溃的封建社会内部的革命因素得到迅速的发展。\n以前那种封建的或行会的工业经营方式，已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失。\n但是，市场总是在扩大，需求总是在增加。甚至工场手工业也再不能满足需要。于是，蒸汽和机器引起了工业生产的革命。现代大工业化代替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替工业的中间等级占据的重要位置。\n由于美洲的发现，促使大工业建立起早已准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展，这种发展反过来又促进了工业的扩展，同时，随着工业、商业、航海业和铁路的扩展，资产阶级也得到在同一程度上的发展，资本的增加，把中世纪遗留下来的一切阶级都尽情地排挤掉。\n由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。\n资产阶级每一个阶段的这种发展，都伴随着在政治上取得相应的进展。它在封建主统治下也是被压迫的阶级，在公社⑷里是武装的和自治的团体，在一些地方组成独立的城市共和国（如德国和意大利），在另一些地方组成君主国中的纳税的第三等级（如法国）⑸；后来，在工场手工业时期，它是等级制君主国或专制君主国用以同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治权力。现代的国家政权只不过是管理整个资产阶级的共同事务的一个委员会罢了。\n资产阶级在历史上，也曾经起过非常革命的作用。\n资产阶级，在它已经取得统治的地方，把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了“传统”的形形色色的封建礼教束缚人们的羁绊，它使人和人之间除了赤裸裸的利害关系和冷酷无情的“现金交易”，就再也没有任何别的联系。它把人们对宗教的虔诚、骑士的热忱血性和小市民的伤感温情这些情感的爆发，淹没在一切都为自己打算的冰水之中。把人的尊严变成了交换价值，把无数特许的和自力挣得的自由用一种没有良心的贸易自由代替。总而言之，它用赤裸裸的、公开的、无耻的、直接的、露骨的和残忍的剥削代替了由宗教和政治带着欺骗的假面具掩盖着的剥削。\n资产阶级，抹去了一切素来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和科学家变成了它出钱雇佣的仆役。\n资产阶级，撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。\n资产阶级，揭示了深受保守派赞许的那种中世纪崇尚人力的野蛮勇武行为，是和极端的怠惰因循习气相辅相成。它首次证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军东征的远征。\n资产阶级如果不是对生产工具进行变革，进而对生产关系，直至对全部社会关系不断地进行革命，就不能生存下去。反之，过去的一切工业阶级生存的首要条件，就是要原封不动地保持旧的生产方式。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。\n由于不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。\n资产阶级由于开拓了世界市场，使一切国家的生产和消费都成为世界性。使反动派大为伤心惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭，并且每天都还在被消灭。它们被新的工业模式排挤掉了，新工业模式的建立已经成为一切文明民族生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠本国产品来满足的需要，被新的、要靠极其遥远的国家和气候悬殊地带的产品来满足的需要所代替。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替。物质的生产是如此，精神的生产也是如此。各民族在精神活动方面的成果，已经成为共同享受的东西。民族的片面性和局限性日益变得不可能存在，于是由许多种民族的和地方的文学形成了一种世界的文学。\n资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至是最野蛮的民族，都卷到文明中来。它的商品的低廉价格，就是它用来摧毁一切万里长城、征服野蛮人最顽强仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓文明，即变成资产者。一句话，它按照自己的形象为自己创造出一个世界。\n资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正象它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。\n资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。原先各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的“民族”。\n资产阶级在不到一百年的阶级统治中所创造的生产力，比过去一切世代所创造的全部生产力加起来还要大，还要多。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整片整片大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——试问过去哪一个世纪能料想到在社会劳动里蕴藏有这样巨大的生产力？\n由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不能再同已经发展的生产力相适应。这种生产关系已经在阻碍生产而不是促进生产。它变成了束缚生产的桎梏。它必须被打破，而且已经被打破。\n取而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。\n现在，在我们眼前又进行着类似的运动。拥有资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用魔术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。要证明这一点，只要指出在周期性的重复中越来越凶猛、越来越危及整个资产阶级社会生存的商业危机就足够了。在每次商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力同样被毁灭掉。在危机期间，发生一种在过去一切时代看来都是非常荒唐的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己转瞬回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上“文明”过度，生活资料“太多”，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；反过来说，就是生产力已经强大到这种生产关系所不能适应的地步，生产力已经受到这种生产关系的阻碍；而生产力一着手突破这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所创造的财富。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的下一次危机的办法，不过是使防止危机的手段越来越少的办法。\n资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己。\n但是，资产阶级不仅锻造了置自身于死地的武器；同时它还造就了将要运用这种武器来反对它的人——现代的工人，即无产者。\n随着资产阶级即资本愈发展，无产阶级即现代工人阶级也在同一程度上愈得到发展；现代的工人只有当他们找到工作的时候才能生存，并且只有当他们的劳动给资本带来增殖的时候才能找到工作。这些不得不把自己零星出卖的工人，像其他任何货物一样，也是一种商品，所以他们同样避免不了要受到竞争的一切变化、市场的一切波动的影响。\n由于机器的推广和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，一切商品的价格，包括劳动的价格⑹，同它的生产费用相等。因此，劳动越使人感到厌恶，工资也就越减少。不仅如此，机器越推广，分工越细致，劳动量也就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。\n现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就象士兵一样被组织起来。他们是产业大军的普通士兵，受着各级“军士”和“军官”的层层监视。他们不仅是资产阶级的、资产阶级国家的奴隶，并且每日每时都受机器、受监工，首先是受各个经营工厂的资本家的奴役。这种专制制度越是公开地把发财营利宣布为自己的最终目的，它就越显得可鄙、可恨和可恶。\n手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。\n当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。\n以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来，有的是因为他们的小资本不足以经营大工业，经不起与较大资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱。无产阶级的队伍就是这样从居民的所有阶级中得到补充。\n无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始。\n最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。\n在这个阶段上，工人们还是分散在全国各地并因为相互竞争所分裂而根本无法联合的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果。当时资产阶级为了达到自己的政治目的，不得不发动并且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产阶级和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。\n但是，随着工业的发展，无产阶级不仅人数增加了，而且结合成更大的群体，它的力量日益增长，也越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎降到同样低的水平，因而无产阶级内部的利益和生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；个别工人和个别资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟⑺；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便一旦发生冲突时使自己有所保障。有些地方，斗争爆发为起义。\n工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得实际利益，而是工人的越来越大的团结。这种团结由于大工业所创造的交通工具的日益发达而得到发展，这种交通工具为各地的工人彼此联系创造了便利。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争本质都是政治斗争。中世纪的市民由于交通不便，靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路的便捷，只要几年就可以达到。\n无产者组织成为阶级，进而组织成为政党这件事，不断由于工人的自相竞争而受到破坏。但是，这种组织总是一次又一次地重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。\n旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族：后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级就把自己的一部分经验知识⑻传授给无产阶级，也就是把反对资产阶级的武器给予了无产阶级。\n其次，我们已经看到，工业的进步把统治阶级的一批批成员抛到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的经验知识。\n最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，转到无产阶级方面来，这就是水平已经提高到从理论上认识整个历史运动进程的一部分资产阶级思想家。\n在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。\n中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的继续存在，以免于灭亡。所以，他们不是革命，而是保守。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是指他们行将转入到无产阶级的队伍里来。指他们维护的已不是他们目前的利益，而是维护他们将来的利益。指他们已离开自己原来的立场，而站到无产阶级的立场上来。\n流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。\n在无产阶级的生活条件中，旧社会的生活条件已经被消灭。无产者没有财产；他们和妻子儿女的关系与资产阶级的家庭关系相比，再没有任何共同之处；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都是一样的，都使无产者失去了任何民族性。法律、道德、宗教本质都是后面隐藏着资产阶级利益的资产阶级的偏见。\n过去一切阶级在争得统治之后，总是企图以此来巩固它们已经获得的生活地位，使全社会都服从于保障它们发财致富这个前提条件。无产者只有废除自己现存的占有方式，进而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么必须加以保护的东西，他们必须摧毁至今保护和保障私有财产的一切。\n至今发生过的一切运动，都是少数人的运动，或者说都是为少数人谋利益的运动。而无产阶级的运动是绝大多数人为绝大多数人的独立自主谋利益的运动。无产阶级是现代社会的最下层，如果它不摧毁压在自己头上的那些全部由官方阶层所构成的上层建筑，就不能抬起头来，挺起胸来。\n如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每个国家的无产阶级，当然首先应该打倒本国的资产阶级。\n在叙述无产阶级发展的最一般阶段⑼的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。\n我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少能够有勉强维持它奴隶般生存的条件。农奴曾经在农奴制度下挣扎到公社社员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却正相反，他们并不是随着工业的进步而上升，而是每况愈下，越来越降到本阶级原有的生存条件以下。工人变成赤贫者，贫困的速度比人口和财富增长得速度还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级，再不能把本阶级的生存条件当做支配一切的规律强加于全社会。资产阶级再无法统治下去，因为它的疯狂榨取已经不能保证被自己统治的阶级能维持奴隶般生存，因为它们让被统治阶级落到无力养活它们，反而还要它们来养活的地步。社会再不能在它们统治下继续运转下去，就是说，它的存在不再同社会相容。\n资产阶级赖以生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本存在的前提条件是雇佣劳动。雇佣劳动完全是建立在工人为了生存的相互间的竞争之上。但是，资产阶级为了获取更多资本而无意间造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合，代替了他们之间为了生存而相互竞争所造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。\n二、无产者和共产党人共产党人同全体无产者的关系是怎样的呢？\n共产党人不是同其他工人政党相对立的特殊政党。\n他们没有任何同整个无产阶级的利益不同的利益。\n他们不提出任何特殊的⑽原则，用以塑造无产阶级的运动。\n共产党人同其他无产阶级政党不同的地方只是：一方面，在各国无产者的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。\n因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的⑾部分；在理论方面，他们胜过其余的无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。\n共产党人的最近目的是和其他一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。\n共产党人的理论原理，决不以这个或那个世界改革家所臆想或发现的思想、原则为根据。\n这些原理不过是现在正在进行的阶级斗争和我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。\n一切所有制关系都经历了经常发生的历史更替和经常发生的历史变更。\n例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。\n共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。\n但是，现代资产阶级的私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削⑿上面的产品生产和占有的最后而又最完备的表现。\n从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。\n有人责备我们共产党人，说我们要消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。\n好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级所有制以前的那种小资产阶级的、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天还都在消灭。\n或者，你们说的是现代的资产阶级的私有财产吧？\n但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的是资本，即剥削雇佣劳动所得到的财产，也即只有在不断产生出新的雇佣劳动用来提供重新加以剥削的条件下，才能增加起来的财产。现今，这种财产正在资本和雇佣劳动的对立运动中演进。让我们来看看这种对立的两个方面吧。\n做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会的地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。\n因此，资本不是一种个人力量，而是一种社会力量。\n因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这时所改变的只是财产的社会性质。它将失掉它的阶级性质。\n现在，我们来看看雇佣劳动。\n雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。\n在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。\n因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。\n而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。\n在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。\n但是，买卖一旦消失，自由买卖也就会消失。关于自由买卖的言论，也象我们的资产阶级的其他一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才有意义。而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义。\n我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制之所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们指责我们要消灭的，是以社会上的绝大多数人没有财产为必要条件的所有制。\n总而言之，你们指责我们，是说我们要消灭你们的那种所有制。的确，我们就是要这样做。\n从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，也就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性就被消灭了。\n由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。\n共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。\n有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。\n这样说来，资产阶级社会早就应该因懒惰而灭亡，因为在这个社会里是劳者不获，获者不劳。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动。\n所有这些对共产主义的物质产品的占有方式和生产方式的责备，也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。\n资产者唯恐失去的那种教育，对绝大多数人来说是把人训练成机器。\n但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正象你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件来决定的。\n你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解，谈到封建所有制的时候你们所能理解，可一谈到资产阶级所有制的时候，你们就再也不愿理解了。\n消灭家庭！连极端的激进派也对共产党人的这种“可耻”的意图表示愤慨。\n现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。\n资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。\n你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。\n你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。但是，你们的教育不也是由社会决定的吗？不也是由你们进行教育的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？\n共产党人并没有发明社会对教育的影响；他们仅仅是要改变这种影响的性质，要使教育摆脱统治阶级的影响。\n无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。\n但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。\n资产者把自己的妻子，看作单纯的生产工具。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。\n他们想也没有想到，问题正在于要使妇女不再处于单纯生产工具的地位。\n其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有。\n我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。\n资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。\n还有人责备共产党人，说他们要取消祖国，取消民族。\n工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级⒀，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。\n随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族隔绝和对立日益消失。\n无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。\n人对人的剥削一消灭，民族对民族的剥削就会随之消灭。\n民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。\n从宗教的、哲学的和一般意识形态的观点对共产主义提出的种种责难，都不值得详细讨论。\n人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？\n思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。\n当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解同旧生活条件的瓦解步调一致。\n当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明自由竞争在信仰的领域里占统治地位罢了。\n“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然不断改变，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。\n此外，还存在着一切社会状态所共有的永恒的真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展进程相矛盾的。”\n这种责难归结为什么呢？至今的一切社会的历史，都在阶级对立中运动，而这种对立在各个不同的时代具有不同的形式。\n但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。\n共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。\n不过，我们还是把资产阶级对共产主义的种种责难撇开吧。\n前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。\n无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。\n要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会超出本身⒁，而且作为变革全部生产方式的手段必不可少。\n这些措施在不同的国家里当然会不同。\n但是，最先进的国家几乎都可以采取下面的措施：\n1．剥夺地产，把地租用于国家支出。\n2．征收高额累进税。\n3．废除继承权。\n4．没收一切流亡分子和叛乱分子的财产。\n5．通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。\n6．把全部运输业集中在国家手里。\n7．按照总的计划增加国营工厂和生产工具，开垦荒地和改良土壤。\n8．实行普遍劳动义务制，成立产业军，特别是在农业方面。\n9．把农业和工业结合起来，促使城乡对立⒂逐步消灭。\n10．对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。\n当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立和阶级本身的存在条件，从而消灭了它自己这个阶级的统治。\n代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。\n三、社会主义和共产主义的文献1．反动的社会主义（甲）封建的社会主义法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败。从此就再谈不上激烈的政治斗争。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时代⒃的老调。为了激起同情，贵族们不得不装模做样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用以泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。\n这样就产生了封建的社会主义，半是挽歌，半是谤文；半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论刺中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。\n为了拉拢人民，贵族们把无产阶级的乞食袋当做旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。\n一部分法国正统派和“青年英国”⒄，都演过这出戏。\n封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。\n不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。\n他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。\n因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果⒅，不顾信义、仁爱和名誉去做羊毛、甜菜和烧酒的买卖获取暴利⒆。\n正如牧师总是同封建主携手同行一样，牧师的社会主义也总是同封建的社会主义携手同行。\n要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有制，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是牧师用来使贵族的怨愤神圣化的圣水罢了。\n（乙）小资产阶级的社会主义封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。\n在现代文明已经发展的国家里，形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争抛到无产阶级队伍里去。而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。\n在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度，是从小资产阶级的立场出发替工人说话。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。\n这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。\n但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产数据和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产数据和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想。\n工业中的行会制度，农业中的宗法经济，——这就是它的最后结论。\n这一思潮在它以后的发展中变成了一种怯懦的悲叹⒇。\n（丙）德国的或“真正的”社会主义法国的社会主义和共产主义的文献，是在居于统治地位的资产阶级的压迫下产生，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。\n德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹意志、本来的意志、真正人的意志的规律。\n德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者不如说，就是从他们的哲学观点出发去演绎法国的思想。\n这种演绎，就象掌握外国语一样，是通过翻译的。\n大家知道，牧师们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化（Entau-Berung）”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。\n这种在法国人的论述下面塞进自己哲学词句的作法，他们称之为“行动的哲学”、“真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。\n法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实世界，而只存在于云雾弥漫的哲学幻想的太空。\n这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。\n德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重。\n于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判(德国的社会主义是这种批判的可怜的回声)是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。\n这种社会主义成了德意志各邦专制政府及其随从——牧师、教员、容克(21)和官僚们求之不得的、吓唬来势汹汹的资产阶级的稻草人。\n这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。\n既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。\n保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义象瘟疫一样流行起来。\n德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。\n同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。\n它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己不偏不倚的超乎任何阶级斗争之上。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献(22)。\n2．保守的或资产阶级的社会主义资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。\n这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形式色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。\n我们可以举蒲鲁东的《贫困的哲学》作为例子。\n社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要抛弃他们关于这个社会的可恶的观念。\n这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的消灭，而是一些行政上的改良，这些改良是在这种生产关系的基础上实行的，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。\n资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。\n自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真的最后要说的话。\n资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。\n3．批判的空想的社会主义和共产主义在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献(巴贝夫等人的著作)。\n无产阶级在普遍躁动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没有具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。\n本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，在无产阶级和资产阶级之间的斗争还不发展的最初时期出现。关于这个时期，我们在前面已经叙述过了(见《资产阶级和无产阶级》)。\n诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。\n由于阶级对立的发展，同工业的发展步调一致，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。\n社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由他们特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。\n诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们的心目中，无产阶级只是一个受苦最深的阶级。\n但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己高高超乎这种阶级对立之上。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。\n因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。\n这种对未来社会的幻想的描绘，是在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，同无产阶级对社会普遍改造的最初的本能的渴望相适应。\n但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立(23)，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。\n批判的空想的社会主义和共产主义的意义，是同历史的发展成反比。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚(24)，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。\n因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生。\n在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派(25)。\n四、共产党人对各种反对党派的态度看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。\n共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来(26)反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。\n在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成，其中一部分是法国式的民主社主义者，一部分是激进的资产者。\n在波兰人中间，共产党人支持那个把土地革命当做民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。\n在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。\n但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。\n共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。\n总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。\n在所有这些运动中，他们都特别强调所有制问题，把它作为运动的基本问题，不管这个问题当时的发展程度怎样。\n最后，共产党人到处都努力争取全世界的民主政党之间的团结和协调。\n共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。\n全世界无产者，联合起来！\n卡•马克思和弗•恩格斯写于1847年12月—1848年1月\n1848年2月第一次以单行本在伦敦出版\n原文是德文\n俄文译自1890年德文版并曾与1848年、1872年和1883年版本核对\n选自《马克思恩格斯全集》第四卷第461-504页\n注释：⑴资产阶级是指现代资本家阶级，现代资本家是占有社会生产资料、使用雇佣劳动的。无产阶级是指现代雇佣工人阶级，现代雇佣工人是没有自己的生产资料、不得不靠出卖劳动力来维持生活的。（恩格斯在1888年英文版上加的注。）\n⑵即有文字可考的全部历史。在1847年的时候，关于社会的史前状态，即关于全部成文史以前的社会组织，几乎还完全没有人知道。后来，哈克斯特豪森发现了俄国的公社土地所有制，毛勒证明了这种所有制是一切日耳曼部落的历史发展所由发源的社会基础，从而逐渐搞清楚，土地公有的村社乃是或者曾经是从印度起到爱尔兰止各地社会的原始形态。最后，摩尔根发现了氏族的真正的本质及其在部落中的地位，才把这个原始共产社会的典型的内部结构弄明白了。随着这种原始公社的解体，社会开始分裂为各个独特的、终于彼此对抗的阶级。关于这个解体过程，我试图在《DerUrsprung der Familie，des Privateigentums und desStaats》，2．Aufl．，Stuttgart，1886〔“家庭、私有制和国家的起源”，1886年，斯图加特，第二版〕一书中加以探讨。（恩格斯在1888年英文版上加的注。）恩格斯也曾经把这一个附注加在1890年出版的德文版“共产党宣言”中去，只是省去了最后的一句话。\n⑶行会师傅就是在行会中享有全权的会员，他是行会内部的工匠，而不是行会的首长。（恩格斯在1888年英文版上加的注。）\n⑷在法国新兴的城市，甚至在它们还没有从封建领主手里争得地方自治权和“第三等级”各项政治权利以前，就已经称为“公社”了。一般说来，这里是把英国看成资产阶级经济发展的典型国家，而把法国看成资产阶级政治发展的典型国家。（恩格斯在1888年英文版上加的注。）\n意大利和法国的市民，从他们的封建领主手中购买或争得了最初的自治权利以后，把自己的城市团体称为公社。（恩格斯在1890年德文版上加的注。）\n⑸在经恩格斯校订过的1888年的英文版中，“独立的城市共和国”后面加有“（如在意大利和德国）”，在“君主国中纳税的第三等级”后面加有“（如在法国）”。\n⑹在比较后期的各种著作中，马克思和恩格斯用“劳动力价值”和“劳动力价格”等等比较确切的概念（这是由马克思开始采用的）分别代替了“劳动价值”和“劳动价格”等等概念（见本卷说明第Ⅺ页）。\n⑺在1888年的英文版中，“同盟”后面添了“（工会）”。\n⑻在1888年的英文版中，“自己的一部分知识”改为“自己的一部分政治知识和普通知识”。\n⑼“最一般的阶段”是辩证法中“一般与特殊”所说的“一般”，也就是“普遍规律”。按照这个“最一般的阶段”的发展，最主要的内容和顺序就是：1、小资产阶级不断破产，无产阶级队伍不断壮大；2、无产阶级为争取自己利益的斗争，逐渐转变上升为政治斗争；3、无产阶级在斗争中不断联合起来。\n针对每个国家的情况不同，有可能存在着“特殊”，这是典型的辩证法表达方式。苏联的十月革命和中国革命，都证明了马克思在这里指出的“国内战争”到“无产阶级建立自己的统治”的普遍真理性。而东欧几个社会主义的小国，却在没有国内战争的情况下，在反法西斯战争中，建立了无产阶级的统治。这就是“特殊性”的具体表现。\n资本主义“最一般的阶段”，是相对于“特殊阶段”而言。比如，特色复辟资本主义，它就跳过了资本主义发展的“最一般的阶段”，即：自由竞争的发展阶段。那么，当今中国无产阶级所进行的社会主义革命的准备工作，也就跳过了它发展的“最一般的阶段”。——【重在人人参与】注\n⑽在1888年的英文版中，“特殊的”改为“宗派的”。\n⑾在1888年的英文版中，“始终鼓舞大家前进的”改为“最先进的”。\n⑿在1888年的英文版中，“一部分人对另一部分人的剥削”改为“少数人对多数人的剥削”。\n⒀在1888年的英文版中，“上升为民族的阶级”改为“上升为民族的主导阶级”。\n⒁在1888年的英文版中，在“越出本身”后面添了“使进一步向旧的社会制度举行进攻成为必要”。\n⒂在1848年的版本中是“城乡之间的对立”。在1872年的版本中和以后的历次德文版本中，“对立”改为“差别”。在1888年的英文版本中，“促使城乡之间的差别逐步消灭”改为“通过全国各地居民更加平均的分布，逐步消灭城乡之间的差别”。\n⒃这里所指的不是英国1660—1689年间的复辟时代，而是法国1814—1830年间的复辟时代。（恩格斯在1888年英文版上加的注。）\n⒄法国正统主义者是1830年被推翻的、代表世袭大地主利益的波旁王朝的拥护者。在反对以金融贵族和大资产阶级为支柱的当政的奥尔良王朝时，一部分正统主义者常常抓住社会问题进行蛊惑宣传，说自己维护劳动者，使他们不受资产者的剥削。\n“青年英国”是英国托利党中的一些政治活动家和著作家的集团，成立于19世纪40年代初。“青年英国”的活动家们反映了土地贵族对资产阶级经济势力和政治势力的增强心怀不满，他们采取蛊惑手段，企图把工人阶级置于自己的影响之下并利用工人阶级来反对资产阶级。\n卡•马克思和弗•恩格斯在《共产党宣言》中，把这些集团的代表人物的观点叫做封建的社会主义。\n⒅在1888年的英文版中，“黄金果”前面加有“从工业树上落下来的”。\n⒆这里主要是指德国说的，那里的土地贵族和容克地主通过自己的管事自行经营自己的大部分地产，他们还开设大规模的甜菜糖厂和酿酒厂。较富有的英国贵族还没有达到这种地步；但是，他们也知道怎样让人家用他们的名义创办颇为可疑的股份公司，以补偿地租的下降。（恩格斯在1888年英文版上加的注。）\n⒇在1888年的英文版中，“这一思潮在它以后的发展中已经变成了一种胆怯的怨声”改为：“最后，当确鑿不移的历史事实使幻想的安慰作用消灭无余的时候，这种社会主义就变成了一种可怜的怨声”。\n(21)容克（Junker，德语Junker的音译），意为“地主之子”或“小主人”。原指无骑士称号的贵族子弟，容克地主阶级原为普鲁士的贵族地主阶级，后泛指普鲁士贵族和大地主。容克贵族制度在中世纪以来主要盛行于普鲁士，主要的内容是在一个封地上只有这个家族的长子才有资格继承家族的封地和爵位，而其他的兄弟在其兄长继承家业以后必须离开家去创自己的天地，去寻找一些无主的土地或是有主的非本国的土地，然后通过决斗等方式取得土地后向普鲁士皇帝申请封号，由于这一类的贵族众多最终形成了一个特殊的贵族阶级，也是所有贵族阶层中最具侵略性的阶层，这是一种解决贵族阶层人数不断增长的办法。容克贵族出身的德国人往往在姓之前加一个“冯”（或译“封”）（Von），这是其贵族出身的特殊标志。容克贵族在16世纪起长期垄断军政要职，掌握国家领导权。在德国文献中容克被分为作战容克、宫廷容克、议院容克和乡村容克等不同类型。在德国历史上真正起过较大作用的是乡村容克。\n19世纪以来普鲁士资本主义的迅速发展,全面瓦解了容克的经济基础－封建庄园。为此普鲁士王朝把重要军官职位和政府官位赐给容克作为“补偿”。1848年德国革命后，容克的庄园经济逐渐转变为资本主义性质的农场，大部分容克开始资产阶级化，但仍保留许多封建残余。容克地主阶级在政治方面属于极端的保守主义，主张君主专制，崇尚武力，赞成对农业采取保护主义，其代表人物是O.von俾斯麦（于1862至1890年任德意志帝国第一任总理）。1871年普鲁士“自上”统一德意志，标志容克资产阶级统治的最后形式。帝国国会中的德意志保守党和国会外的农民同盟均代表容克利益，军队中的军官也多出身于容克，从而使整个德意志帝国打上容克的烙印。魏玛共和国时期，容克敌视共和政体，支持阿道夫•希特勒执政。\n(22)1848年的革命风暴已经把这个可恶的流派扫除净尽，并且使这一流派的代表人物再也不高兴拿社会主义来投机了。格律恩先生就是这一派的主要代表者和典型人物。（恩格斯在1890年德文版上加的注。）\n(23)在1888年的英文版中，这一处改为“它们所提出的一些实际措施，例如消灭城乡之间的差别”。\n(24)法伦斯泰尔是傅立叶所设计的社会主义移民区的称呼；伊加利亚是卡贝给自己的理想国和后来他在美洲创立的共产主义移民区所起的名称。（恩格斯在1888年英文版上加的注。）\n国内移民区（Homecolonies）是欧文给他的示范性的共产主义社会所起的名称。傅立叶所设计的社会宫叫做法伦斯泰尔。卡贝所描绘的那种建立了共产主义制度的空想臆造国叫做伊加利亚。（恩格斯在1890年德文版上加的注。）\n(25)改革派，这里指的是《改革报》（《Réforme》）的支持者。他们主张建立共和国并实行民主改革和社会改革。\n(26)当时这个党在议会中的代表是赖德律－洛兰，在著作方面的代表是路易•勃朗，在报纸方面的代表是“改革报”（《Réforme》）。他们所发明的名称——社会主义民主党，是他们曾经用以表明民主党或共和党中一部分多少涂上社会主义颜色的人的。（恩格斯在1888年英文版上加的注。）\n法国以社会民主党自称的政党，在政治生活中的代表是赖德律－洛兰，在著作方面的代表是路易•勃朗；所以，它同现代德国社会民主党的不同有如天渊之别。（恩格斯在1890年德文版上加的注。）\n其他《共产党宣言》是科学共产主义最伟大的纲领性文献。“这虽然是一个薄薄的小册子，但是它的价值却不亚于整整的好几卷书：它的精神至今还鼓舞并推动着文明世界整个有组织的和战斗的无产阶级”（列宁）。卡•马克思和弗•恩格斯作为共产主义者同盟的纲领而写成的《共产党宣言》，最初于1848年2月在伦敦用共有23页的单行本发表。1848年3月至7月，《共产党宣言》又在德国流亡者的民主派机关报《德意志伦敦报》（《DeutschelondonerZeitung》）上连载。德文原本也是1848年在伦敦再版的，这是一个共有30页的小册子；这次更正了第一版中一些印错的字，并改进了标点符号。这一原本后来被马克思和恩格斯规定为以后各个经作者同意的版本的基础。1848年《宣言》同时又被翻译成许多种欧洲文字（法文、波兰文、意大利文、丹麦文、弗拉曼特文和瑞典文）。在1848年的各个版本中未提《宣言》作者的名字。1850年宪章派的机关刊物《赤色共和党人》（《RedRepublican》）登载《宣言》的第一个英文译文时，该杂志的编辑乔•哈尼在序言中第一次指出作者的名字。\n1872年《宣言》出版了新的，作者作了某些不大的修改，马克思和恩格斯合写了一篇序言。这一版本以及后来在1883年和1890年出版的各个版本，都是以《共产主义宣言》为题出版的。\n《共产党宣言》的第一个俄文译本是由巴枯宁翻译的，1869年在日内瓦出版，他在许多地方歪曲了《宣言》的内容。1882年在日内瓦出版的普列汉诺夫的译本消灭了第一个版本中的缺陷。普列汉诺夫的译本给《宣言》的思想在俄国广乏传播奠定了基础。马克思和恩格斯认为在俄国宣传马克思主义具有重大的意义，他们特地给这一译本写了一篇。\n在马克思逝世之后，《宣言》出版了许多种曾经由恩格斯校阅过的版本，例如在1883年出版了附有恩格斯写的序言的；在1888年出版了由赛•穆尔翻译的，这一版本是由恩格斯校订过的，并附有恩格斯补写的序言和附注；在1890年出版了附有恩格斯写的序言的。在最后的这一版本中，恩格斯也曾加上了几个附注。1885年，在《社会主义者报》（《Socialiste》）上发表了《宣言》的法文译文，这是马克思的女儿劳拉•拉法格翻译的，并由恩格斯校阅过。恩格斯曾给1892年的《宣言》和1893年的《宣言》分别写过序言。\n\n\n\n","slug":"maxist","date":"2023-03-15T09:26:44.000Z","categories_index":"Maxist","tags_index":"Maxist","author_index":"涛"}]